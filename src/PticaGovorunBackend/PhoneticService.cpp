#include "stdafx.h"
#include "PhoneticService.h"
#include <array>
#include <QFile>
#include <QDir>
#include <QDirIterator>
#include <QDebug>
#include <QXmlStreamReader>
#include <QString>
#include "CoreUtils.h"

namespace PticaGovorun
{
	namespace
	{
		const wchar_t Letter_Hyphen = L'-';
		const wchar_t Letter_Apostrophe = L'\'';
		const wchar_t Letter_A = L'à';
		const wchar_t Letter_B = L'á';
		const wchar_t Letter_H = L'ã';
		const wchar_t Letter_D = L'ä';
		const wchar_t Letter_E = L'å';
		const wchar_t Letter_JE = L'º';
		const wchar_t Letter_ZH = L'æ';
		const wchar_t Letter_Z = L'ç';
		const wchar_t Letter_I = L'³';
		const wchar_t Letter_JI = L'¿';
		const wchar_t Letter_K = L'ê';
		const wchar_t Letter_N = L'í';
		const wchar_t Letter_S = L'ñ';
		const wchar_t Letter_T = L'ò';
		const wchar_t Letter_U = L'ó';
		const wchar_t Letter_TS = L'ö';
		const wchar_t Letter_CH = L'÷';
		const wchar_t Letter_SH = L'ø';
		const wchar_t Letter_SHCH = L'ù';
		const wchar_t Letter_SoftSign = L'ü';
		const wchar_t Letter_JU = L'þ';
		const wchar_t Letter_JA = L'ÿ';
	}

	void Pronunc::setPhones(const std::vector<std::string>& phones)
	{
		for (const std::string& ph : phones)
		{
			pushBackPhone(ph);
		}
	}

	void Pronunc::pushBackPhone(const std::string& phone)
	{
		if (!StrDebug.empty())
			StrDebug.push_back(' ');
		std::copy(std::begin(phone), std::end(phone), std::back_inserter(StrDebug));
		Phones.push_back(phone);
	}

	bool operator == (const Pronunc& a, const Pronunc& b)
	{
		bool eqSize = a.Phones.size() == b.Phones.size();
		if (!eqSize)
			return false;
		for (int i = 0; i < a.Phones.size(); ++i)
		{
			auto p1 = a.Phones[i];
			auto p2 = b.Phones[i];
			bool eqPhones = p1 == p2;
			if (!eqPhones)
				return false;
		}
		return true;
	}

	bool operator < (const Pronunc& a, const Pronunc& b)
	{
		size_t minSize = std::min(a.Phones.size(), b.Phones.size());
		for (int i = 0; i < minSize; ++i)
		{
			auto p1 = a.Phones[i];
			auto p2 = b.Phones[i];
			bool eq = p1 == p2;
			if (!eq)
				return std::less<>()(p1, p2);
		}
		if (     a.Phones.size() < b.Phones.size())
			return true;
		else if (a.Phones.size() > b.Phones.size())
			return false;
		return false;
	}

	PhoneId PhoneRegistry::extendPhoneId(int validPhoneId) const
	{
		PhoneId result;
		result.Id = validPhoneId;
#if PG_DEBUG
		static std::string phoneStr;
		bool toStrOp = phoneToStr(*this, validPhoneId, phoneStr);
		PG_DbgAssert(toStrOp && "Invalid PhoneId:int");
		result.fillStr(phoneStr);
#endif
		return result;
	}

	PhoneRegistry::BasicPhoneIdT PhoneRegistry::extendBasicPhoneId(int basicPhoneId) const
	{
		BasicPhoneIdT result;
		result.Id = basicPhoneId;
#ifdef PG_DEBUG
		int basicPhoneStrInd = basicPhoneId - 1;

		PG_DbgAssert(basicPhoneStrInd >= 0 && basicPhoneStrInd < basicPhones_.size());
		const BasicPhone& basicPhone = basicPhones_[basicPhoneStrInd];

		result.fillStr(basicPhone.Name);
#endif
		return result;
	}

	PhoneRegistry::BasicPhoneIdT PhoneRegistry::getOrCreateBasicPhone(const std::string& basicPhoneStr, CharGroup charGroup)
	{
		auto it = basicPhonesStrToId_.find(basicPhoneStr);
		if (it != basicPhonesStrToId_.end())
			return extendBasicPhoneId(it->second);

		int newId = basicPhones_.size() + 1;

		BasicPhone basicPhone;
		basicPhone.Id = newId;
		basicPhone.Name = basicPhoneStr;
		basicPhone.DerivedFromChar = charGroup;
		basicPhones_.push_back(basicPhone);
		basicPhonesStrToId_[basicPhoneStr] = newId;
		return extendBasicPhoneId(newId);
	}

	PhoneRegistry::BasicPhoneIdT PhoneRegistry::basicPhoneId(const std::string& basicPhoneStr, bool* success) const
	{
		*success = false;

		auto it = basicPhonesStrToId_.find(basicPhoneStr);
		if (it != basicPhonesStrToId_.end())
		{
			*success = true;
			return extendBasicPhoneId(it->second);
		}
		return PhoneRegistry::BasicPhoneIdT();
	}

	const BasicPhone* PhoneRegistry::basicPhone(BasicPhoneIdT basicPhoneId) const
	{
		int basicPhoneInd = basicPhoneId.Id - 1;
		if (basicPhoneInd < 0 || basicPhoneInd >= basicPhones_.size())
			return nullptr;
		return &basicPhones_[basicPhoneInd];
	}

	PhoneId PhoneRegistry::newVowelPhone(const std::string& basicPhoneStr, bool isStressed)
	{
		int phoneId = nextPhoneId_++;

		Phone phone;
		phone.Id = phoneId;
		phone.BasicPhoneId = getOrCreateBasicPhone(basicPhoneStr, CharGroup::Vowel);
		phone.IsStressed = isStressed;
		phoneReg_.push_back(phone);
		return extendPhoneId(phoneId);
	}

	PhoneId PhoneRegistry::newConsonantPhone(const std::string& basicPhoneStr, boost::optional<SoftHardConsonant> softHard)
	{
		int phoneId = nextPhoneId_++;

		Phone phone;
		phone.Id = phoneId;
		phone.BasicPhoneId = getOrCreateBasicPhone(basicPhoneStr, CharGroup::Consonant);
		phone.SoftHard = softHard;
		phoneReg_.push_back(phone);
		return extendPhoneId(phoneId);
	}

	void PhoneRegistry::findPhonesByBasicPhoneStr(const std::string& basicPhoneStr, std::vector<PhoneId>& phoneIds) const
	{
		auto basicPhoneIt = basicPhonesStrToId_.find(basicPhoneStr);
		if (basicPhoneIt == basicPhonesStrToId_.end())
			return;
		int basicPhoneId = basicPhoneIt->second;

		for (size_t phoneInd = 0; phoneInd < phoneReg_.size(); ++phoneInd)
		{
			const Phone& ph = phoneReg_[phoneInd];
			if (ph.BasicPhoneId.Id == basicPhoneId)
				phoneIds.push_back(extendPhoneId(phoneInd + 1));
		}
	}

	int PhoneRegistry::phonesCount() const
	{
		assumeSequentialPhoneIdsWithoutGaps();
		return nextPhoneId_ - 1;
	}

	const Phone* PhoneRegistry::phoneById(int phoneId) const
	{
		int phoneInd = phoneId - 1;
		if (phoneInd < 0 || phoneInd >= phoneReg_.size())
			return nullptr;
		return &phoneReg_[phoneInd];
	}

	const Phone* PhoneRegistry::phoneById(PhoneId phoneId) const
	{
		return phoneById(phoneId.Id);
	}

	boost::optional<PhoneId> PhoneRegistry::phoneIdSingle(const std::string& basicPhoneStr, boost::optional<SoftHardConsonant> softHard, boost::optional<bool> isStressed) const
	{
		bool suc = false;
		auto basicPhId = basicPhoneId(basicPhoneStr, &suc);
		if (!suc)
			return nullptr;
		return phoneIdSingle(basicPhId, softHard, isStressed);
	}

	boost::optional<PhoneId> PhoneRegistry::phoneIdSingle(PhoneRegistry::BasicPhoneIdT basicPhoneStrId, boost::optional<SoftHardConsonant> softHard, boost::optional<bool> isStressed) const
	{
		const BasicPhone* basicPh = basicPhone(basicPhoneStrId);
		if (basicPh == nullptr)
			return nullptr;
		std::vector<PhoneId> candidates;
		findPhonesByBasicPhoneStr(basicPh->Name, candidates);

		if (candidates.empty())
			return nullptr;
		if (candidates.size() == 1)
			return candidates.front();

		std::vector<PhoneId> excactCandidates;
		std::remove_copy_if(candidates.begin(), candidates.end(), std::back_inserter(excactCandidates), [this, softHard, isStressed](PhoneId phoneId)
		{
			const Phone* phone = phoneById(phoneId);
			if (softHard != nullptr && softHard != phone->SoftHard)
				return true;
			if (isStressed != nullptr && isStressed != phone->IsStressed)
				return true;
			return false;
		});

		if (excactCandidates.size() == 1)
			return excactCandidates.front();

		// exact candidates size:
		// = 0 then we may fallback to basic phone candidates; but there is no way to choose the best one
		// > 1 then again the best one can't be chosen
		return nullptr;
	}

	bool PhoneRegistry::allowSoftHardConsonant() const
	{
		return allowSoftHardConsonant_;
	}

	bool PhoneRegistry::allowVowelStress() const
	{
		return allowVowelStress_;
	}

	boost::optional<SoftHardConsonant> PhoneRegistry::defaultSoftHardConsonant() const
	{
		if (allowSoftHardConsonant())
			return SoftHardConsonant::Hard;
		return nullptr;
	}

	boost::optional<bool> PhoneRegistry::defaultIsVowelStressed() const
	{
		if (allowVowelStress())
			return false;
		return boost::none;
	}

	void initPhoneRegistryUk(PhoneRegistry& phoneReg, bool allowSoftHardConsonant, bool allowVowelStress)
	{
		phoneReg.allowSoftHardConsonant_ = allowSoftHardConsonant;
		phoneReg.allowVowelStress_ = allowVowelStress;

		phoneReg.newVowelPhone("A", false); // A
		if (allowVowelStress)
			phoneReg.newVowelPhone("A", true); // A1
		phoneReg.newConsonantPhone("B", SoftHardConsonant::Hard); // B, hard only
		phoneReg.newConsonantPhone("V", SoftHardConsonant::Hard); // V, hard only
		phoneReg.newConsonantPhone("G", SoftHardConsonant::Hard); // G, hard only (gudzyk)
		phoneReg.newConsonantPhone("H", SoftHardConsonant::Hard); // H, hard only (gluhi)
		phoneReg.newConsonantPhone("D", SoftHardConsonant::Hard); // D
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("D", SoftHardConsonant::Soft); // D1
		phoneReg.newConsonantPhone("DZ", SoftHardConsonant::Hard); // DZ
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("DZ", SoftHardConsonant::Soft); // DZ1
		phoneReg.newConsonantPhone("DZH", SoftHardConsonant::Hard); // DZH
		phoneReg.newVowelPhone("E", false); // E
		if (allowVowelStress)
			phoneReg.newVowelPhone("E", true); // E1
		phoneReg.newConsonantPhone("ZH", SoftHardConsonant::Hard); // ZH, hard only
		phoneReg.newConsonantPhone("Z", SoftHardConsonant::Hard); // Z
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("Z", SoftHardConsonant::Soft); // Z1
		phoneReg.newVowelPhone("Y", false); // Y
		if (allowVowelStress)
			phoneReg.newVowelPhone("Y", true); // Y1
		phoneReg.newVowelPhone("I", false); // I
		if (allowVowelStress)
			phoneReg.newVowelPhone("I", true); // I1
		phoneReg.newConsonantPhone("J", SoftHardConsonant::Hard); // J, hard only (é)
		phoneReg.newConsonantPhone("K", SoftHardConsonant::Hard); // K, hard only
		phoneReg.newConsonantPhone("L", SoftHardConsonant::Hard); // L
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("L", SoftHardConsonant::Soft); // L1
		phoneReg.newConsonantPhone("M", SoftHardConsonant::Hard); // M, hard only
		phoneReg.newConsonantPhone("N", SoftHardConsonant::Hard); // N
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("N", SoftHardConsonant::Soft); // N1
		phoneReg.newVowelPhone("O", false); // O
		if (allowVowelStress)
			phoneReg.newVowelPhone("O", true); // O1
		phoneReg.newConsonantPhone("P", SoftHardConsonant::Hard); // P, hard only (ï'ÿòü)
		phoneReg.newConsonantPhone("R", SoftHardConsonant::Hard); // R
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("R", SoftHardConsonant::Soft); // R1
		phoneReg.newConsonantPhone("S", SoftHardConsonant::Hard); // S
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("S", SoftHardConsonant::Soft); // S1
		phoneReg.newConsonantPhone("T", SoftHardConsonant::Hard); // T
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("T", SoftHardConsonant::Soft); // T1
		phoneReg.newVowelPhone("U", false); // U
		if (allowVowelStress)
			phoneReg.newVowelPhone("U", true); // U1
		phoneReg.newConsonantPhone("F", SoftHardConsonant::Hard); // F, hard only
		phoneReg.newConsonantPhone("KH", SoftHardConsonant::Hard); // KH, hard only (õ'þ)
		phoneReg.newConsonantPhone("TS", SoftHardConsonant::Hard); // TS
		if (allowSoftHardConsonant)
			phoneReg.newConsonantPhone("TS", SoftHardConsonant::Soft); // TS1
		phoneReg.newConsonantPhone("CH", SoftHardConsonant::Hard); // CH, hard only (÷àñ)
		phoneReg.newConsonantPhone("SH", SoftHardConsonant::Hard); // SH, hard only (ø'º)
	}

	std::tuple<bool, const char*> loadPronunciationVocabulary(const std::wstring& vocabFilePathAbs, std::map<std::wstring, std::vector<std::string>>& wordToPhoneList, const QTextCodec& textCodec)
	{
		// file contains text in Windows-1251 encoding
		QFile file(QString::fromStdWString(vocabFilePathAbs));
		if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			return std::make_tuple(false, "Can't open file");

		// 
		std::array<char, 1024> lineBuff;

		// each line has a format:
		// sure\tsh u e\n
		while (true) {
			auto readBytes = file.readLine(lineBuff.data(), lineBuff.size());
			if (readBytes == -1) // EOF
			{
				break;
			}

			// read the first word

			char* pMutStr = lineBuff.data(); // note, strtok modifies the buffer
			char* pMutStrNext = nullptr;

			const char* DictDelim = " \t\n";

			// strtok seems to be quicker than std::regex or QString::split approaches
			pMutStr = strtok_s(pMutStr, DictDelim, &pMutStrNext);
			if (pMutStr == nullptr)
			{
				// the line contains only the whitespace
				continue;
			}

			QString word = textCodec.toUnicode(pMutStr);

			// read the tail of phones
			std::vector<std::string> phones;
			while (true)
			{
				pMutStr = strtok_s(nullptr, DictDelim, &pMutStrNext);
				if (pMutStr == nullptr)
					break;

				auto len = strlen(pMutStr);
				std::string phoneStr(pMutStr, len);
				phones.push_back(std::move(phoneStr));
			}

			wordToPhoneList.insert(std::make_pair<std::wstring, std::vector<std::string>>(word.toStdWString(), std::move(phones)));
		}

		return std::make_tuple(true, nullptr);
	}

	std::tuple<bool, const char*> loadPronunciationVocabulary2(const std::wstring& vocabFilePathAbs, std::map<std::wstring, std::vector<Pronunc>>& wordToPhoneList, const QTextCodec& textCodec)
	{
		// file contains text in Windows-1251 encoding
		QFile file(QString::fromStdWString(vocabFilePathAbs));
		if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			return std::make_tuple(false, "Can't open file");

		// 
		std::array<char, 1024> lineBuff;

		// each line has a format:
		// sure\tsh u e\n
		while (true) {
			auto readBytes = file.readLine(lineBuff.data(), lineBuff.size());
			if (readBytes == -1) // EOF
			{
				break;
			}
			//if (rand() % 50 >= 1) // filter for speed
			//	continue;

			// read the first word

			char* pMutStr = lineBuff.data(); // note, strtok modifies the buffer
			char* pMutStrNext = nullptr;

			const char* DictDelim = " \t\n";

			// strtok seems to be quicker than std::regex or QString::split approaches
			pMutStr = strtok_s(pMutStr, DictDelim, &pMutStrNext);
			if (pMutStr == nullptr)
			{
				// the line contains only the whitespace
				continue;
			}

			QString word = textCodec.toUnicode(pMutStr);

			// read the tail of phones
			std::vector<std::string> phones;
			while (true)
			{
				pMutStr = strtok_s(nullptr, DictDelim, &pMutStrNext);
				if (pMutStr == nullptr)
					break;

				auto len = strlen(pMutStr);
				std::string phoneStr(pMutStr, len);
				phones.push_back(std::move(phoneStr));
			}

			std::wstring wordW = word.toStdWString();
			auto it = wordToPhoneList.find(wordW);
			if (it == std::end(wordToPhoneList))
			{
				std::vector<Pronunc> prons;
				wordToPhoneList.insert({ wordW, prons });
				it = wordToPhoneList.find(wordW);
				assert(it != std::end(wordToPhoneList) && "Element must be in the map");
			}
			Pronunc pron;
			pron.setPhones(phones);
			it->second.push_back(std::move(pron));
		}

		return std::make_tuple(true, nullptr);
	}

	std::tuple<bool, const char*> loadPhoneticDictionaryPronIdPerLine(const std::basic_string<wchar_t>& vocabFilePathAbs, const PhoneRegistry& phoneReg, const QTextCodec& textCodec, std::vector<PhoneticWord>& words, std::vector<std::basic_string<char>>& brokenLines)
	{
		// file contains text in Windows-1251 encoding
		QFile file(QString::fromStdWString(vocabFilePathAbs));
		if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			return std::make_tuple(false, "Can't open file");

		// 
		std::array<char, 1024> lineBuff;
		PhoneticWord curPronGroup;
		std::vector<PhoneId> phones;

		// each line has a format:
		// sure\tsh u e\n
		while (true) {
			auto readBytes = file.readLine(lineBuff.data(), lineBuff.size());
			if (readBytes == -1) // EOF
				break;

			if (readBytes < 3) // 3=min length of Word->PhoneList
				continue;

			boost::string_ref line(lineBuff.data(), readBytes);
			if (line.back() == '\n')
				line.remove_suffix(1);

			const char* DictDelim = " \t\n";
			size_t phoneListInd = line.find_first_of(DictDelim);
			if (phoneListInd == boost::string_ref::npos)
				return std::make_tuple(false, "The word is too long (>1024 bytes)");

			boost::string_ref wordRef(line.data(), phoneListInd);
			if (wordRef.empty()) // empty line
				continue;

			boost::string_ref phoneListRef = line.substr(phoneListInd + 1);
			if (phoneListRef.empty()) // word without the list of phones
			{
				brokenLines.push_back(lineBuff.data());
				continue;
			}
			std::transform(phoneListRef.begin(), phoneListRef.end(), (char*)phoneListRef.begin(), toupper);

			phones.clear();
			bool parseOp = parsePhoneList(phoneReg, phoneListRef, phones);
			if (!parseOp)
			{
				brokenLines.push_back(line.data());
				continue;
			}

			QString word = textCodec.toUnicode(line.data(), phoneListInd);
			std::wstring wordW = word.toStdWString();

			if (curPronGroup.Word != wordW)
			{
				// finish previous pronunciation group
				if (!curPronGroup.Word.empty())
				{
					words.push_back(curPronGroup);
					curPronGroup.Word.clear();
					curPronGroup.Pronunciations.clear();
				}

				// start new group
				PG_DbgAssert(curPronGroup.Pronunciations.empty() && "Old pronunciation data must be purged");
				curPronGroup.Word = wordW;
			}

			PronunciationFlavour pron;
			pron.PronAsWord = wordW;
			pron.Phones = phones;
			curPronGroup.Pronunciations.push_back(pron);
		}

		if (!curPronGroup.Word.empty())
		{
			words.push_back(curPronGroup);
			curPronGroup.Word.clear();
			curPronGroup.Pronunciations.clear();
		}
		return std::make_tuple(true, nullptr);
	}

	void trimPhoneStrExtraInfos(const std::string& phoneStdStr, std::string& phoneStrTrimmed, bool toUpper, bool trimNumbers)
	{
		QString phoneStr = QString::fromStdString(phoneStdStr);
		if (trimNumbers)
		{
			if (phoneStr[phoneStr.size() - 1].isDigit())
			{
				phoneStr = phoneStr.left(phoneStr.size() - 1); // remove last digit
			}
		}
		if (toUpper)
			phoneStr = phoneStr.toUpper();
		phoneStrTrimmed = phoneStr.toStdString();
	}

	void normalizePronunciationVocabulary(std::map<std::wstring, std::vector<Pronunc>>& wordToPhoneList, bool toUpper, bool trimNumbers)
	{
		std::string phoneStrTrimmed;
		for (auto& pair : wordToPhoneList)
		{
			std::vector<Pronunc>& prons = pair.second;
			for (auto& pron : prons)
			{
				for (auto& phone : pron.Phones)
				{
					trimPhoneStrExtraInfos(phone, phoneStrTrimmed, toUpper, trimNumbers);
					phone = phoneStrTrimmed;
				}
			}

			std::sort(std::begin(prons), std::end(prons));
			auto it = std::unique(std::begin(prons), std::end(prons));
			size_t newSize = std::distance(std::begin(prons), it);
			prons.resize(newSize);
		}
	}

	boost::optional<PhoneId> parsePhoneStr(const PhoneRegistry& phoneReg, boost::string_ref phoneStrRef)
	{
		if (phoneStrRef.empty())
			return nullptr;

		boost::string_ref basicPhoneStrRef = phoneStrRef;

		// truncate last digit
		char ch = phoneStrRef.back();
		bool lastIsDigit = ::isdigit(ch);
		if (lastIsDigit)
			basicPhoneStrRef.remove_suffix(1);

		bool basicOp = false;
		std::string basicPhoneStr = std::string(basicPhoneStrRef.data(), basicPhoneStrRef.size());
		PhoneRegistry::BasicPhoneIdT basicPhoneId = phoneReg.basicPhoneId(basicPhoneStr, &basicOp);
		if (!basicOp)
			return nullptr;
		const BasicPhone* basicPhone = phoneReg.basicPhone(basicPhoneId);

		// defaults for phone name without a number suffix
		boost::optional<SoftHardConsonant> softHard = nullptr;
		if (basicPhone->DerivedFromChar == CharGroup::Consonant)
			softHard = phoneReg.defaultSoftHardConsonant();

		boost::optional<bool> isStressed = nullptr;
		if (basicPhone->DerivedFromChar == CharGroup::Vowel)
			isStressed = phoneReg.defaultIsVowelStressed();

		if (lastIsDigit)
		{
			// number on a consonant derived phone means softness
			if (basicPhone->DerivedFromChar == CharGroup::Consonant)
				softHard = SoftHardConsonant::Soft;

			// number on a vowel derived phone means stress
			else if (basicPhone->DerivedFromChar == CharGroup::Vowel)
				isStressed = true;
		}

		boost::optional<PhoneId> result = phoneReg.phoneIdSingle(basicPhoneId, softHard, isStressed);
		return result;
	}

	bool parsePhoneList(const PhoneRegistry& phoneReg, boost::string_ref phoneListStr, std::vector<PhoneId>& result)
	{
		boost::string_ref curPhonesStr = phoneListStr;
		while (!curPhonesStr.empty())
		{
			size_t sepPos = curPhonesStr.find(' ');
			if (sepPos == boost::string_ref::npos)
				sepPos = curPhonesStr.size();

			boost::string_ref phoneRef = curPhonesStr.substr(0, sepPos);
			if (phoneRef.empty()) // a phone can't be an empty string
				continue;

			boost::optional<PhoneId> phoneId = parsePhoneStr(phoneReg, phoneRef);
			if (!phoneId)
				return false;

			result.push_back(phoneId.get());

			curPhonesStr.remove_prefix(sepPos + 1);
		}
		return true;
	}

	std::tuple<bool, const char*> parsePronuncLines(const PhoneRegistry& phoneReg, const std::basic_string<wchar_t>& prons, std::vector<PronunciationFlavour>& result)
	{
		QString pronsQ = QString::fromStdWString(prons);
		QStringList pronItems = pronsQ.split('\n', QString::SkipEmptyParts);
		for (int pronInd = 0; pronInd < pronItems.size(); ++pronInd)
		{
			QString pronLine = pronItems[pronInd];
			int pronAsWordEndInd = pronLine.indexOf('\t');
			if (pronAsWordEndInd == -1)
				return std::make_tuple(false, "First part of line doesn't contain pronunciation id");

			QString pronAsWord = pronLine.left(pronAsWordEndInd);
			QString phonesStr = pronLine.mid(pronAsWordEndInd+1);

			std::vector<PhoneId> phones;
			bool parseOp = parsePhoneList(phoneReg, phonesStr.toStdString(), phones);
			if (!parseOp)
				return std::make_tuple(false, "Can't parse the list of phones");

			PronunciationFlavour pron;
			pron.PronAsWord = pronAsWord.toStdWString();
			pron.Phones = phones;
			result.push_back(pron);
		}
		return std::make_tuple(true, nullptr);
	}

	bool phoneToStr(const PhoneRegistry& phoneReg, int phoneId, std::string& result)
	{
		const Phone* phone = phoneReg.phoneById(phoneId);
		if (phone == nullptr)
			return false;
		const BasicPhone* basicPh = phoneReg.basicPhone(phone->BasicPhoneId);
		result = basicPh->Name;

		if (phoneReg.allowSoftHardConsonant() && phone->SoftHard == SoftHardConsonant::Soft) // is soft consonant
			result.push_back('1');
		else if (phoneReg.allowVowelStress() && phone->IsStressed == true)
			result.push_back('1');

		return true;
	}

	bool phoneToStr(const PhoneRegistry& phoneReg, PhoneId phoneId, std::string& result)
	{
		return phoneToStr(phoneReg, phoneId.Id, result);
	}

	bool phoneListToStr(const PhoneRegistry& phoneReg, wv::slice<PhoneId> phones, std::string& result)
	{
		if (phones.empty())
			return true;

		std::string phStr;
		if (!phoneToStr(phoneReg, phones.front(), phStr))
			return false;
		result += phStr;

		for (int i = 1; i < phones.size(); ++i)
		{
			result.push_back(' ');

			if (!phoneToStr(phoneReg, phones[i], phStr))
				return false;
			result += phStr;
		}
		return true;
	}

	std::tuple<bool, const char*> spellWordUk(const PhoneRegistry& phoneReg, const std::wstring& word, std::vector<PhoneId>& phones)
	{
		// Half made phone.
		// The incomplete phone's data, so that complete PhoneId can't be queried from phone registry.
		typedef decltype(static_cast<Phone*>(nullptr)->BasicPhoneId) BasicPhoneStrIdT;
		struct PhoneBillet
		{
			BasicPhoneStrIdT BasicPhoneStrId;
			boost::optional<CharGroup> DerivedFromChar = boost::none;
			boost::optional<SoftHardConsonant> SoftHard = boost::none; // valid for consonants only
			boost::optional<bool> IsStressed = boost::none; // valid for for vowels only
		};
		auto newConsonantPhone = [&phoneReg](const std::string& basicPhoneStr, boost::optional<SoftHardConsonant> SoftHard) -> PhoneBillet
		{
			bool success = false;
			BasicPhoneStrIdT basicId = phoneReg.basicPhoneId(basicPhoneStr, &success);
			PG_Assert(success && "Unknown basic phone str");

			PhoneBillet billet;
			billet.BasicPhoneStrId = basicId;
			billet.DerivedFromChar = CharGroup::Consonant;
			billet.SoftHard = SoftHard;
			return billet;
		};
		auto newVowelPhone = [&phoneReg](const std::string& basicPhoneStr, boost::optional<bool> isStressed) -> PhoneBillet
		{
			bool success = false;
			BasicPhoneStrIdT basicId = phoneReg.basicPhoneId(basicPhoneStr, &success);
			PG_Assert(success && "Unknown basic phone str");

			PhoneBillet billet;
			billet.BasicPhoneStrId = basicId;
			billet.DerivedFromChar = CharGroup::Vowel;
			billet.IsStressed = isStressed;
			return billet;
		};
		// return true if the char was sucessfully mapped.
		auto simpleMap = [&newVowelPhone, &newConsonantPhone](wchar_t letter, PhoneBillet& ph) -> bool
		{
			switch (letter)
			{
			case L'à':
				ph = newVowelPhone("A", nullptr);
				break;
			case L'â':
				ph = newConsonantPhone("V", SoftHardConsonant::Hard);
				break;
			case L'´':
				ph = newConsonantPhone("G", SoftHardConsonant::Hard);
				break;
			case L'è':
				ph = newVowelPhone("Y", nullptr);
				break;
			case L'é':
				ph = newConsonantPhone("J", SoftHardConsonant::Hard);
				break;
			case L'ê':
				ph = newConsonantPhone("K", SoftHardConsonant::Hard);
				break;
			case L'ë':
				ph = newConsonantPhone("L", nullptr);
				break;
			case L'ì':
				ph = newConsonantPhone("M", SoftHardConsonant::Hard);
				break;
			case L'î':
				ph = newVowelPhone("O", nullptr);
				break;
			case L'ï':
				ph = newConsonantPhone("P", SoftHardConsonant::Hard);
				break;
			case L'ð':
				ph = newConsonantPhone("R", nullptr);
				break;
			case L'ó':
				ph = newVowelPhone("U", nullptr);
				break;
			case L'ô':
				ph = newConsonantPhone("F", SoftHardConsonant::Hard);
				break;
			case L'õ':
				ph = newConsonantPhone("KH", SoftHardConsonant::Hard);
				break;
			case L'ö':
				ph = newConsonantPhone("TS", nullptr);
				break;
			case L'÷':
				ph = newConsonantPhone("CH", SoftHardConsonant::Hard);
				break;
			case L'ø':
				ph = newConsonantPhone("SH", SoftHardConsonant::Hard);
				break;
			default:
				return false;
			}
			return true;
		};
		std::vector<PhoneBillet> billetPhones;
		for (size_t i = 0; i < word.size(); ++i)
		{
			wchar_t letter = word[i];

			PhoneBillet phone;
			bool mappedOk = simpleMap(letter, phone);
			if (mappedOk)
			{
				billetPhones.push_back(phone);
				continue;
			}

			// letter is converted in more complicated way

			bool isFirstLetter = i == 0;
			bool isLastLetter = i + 1 == word.size();

			if (letter == Letter_B || letter == Letter_H || letter == Letter_D || letter == Letter_ZH || letter == Letter_Z)
			{
				if (letter == Letter_D)
				{
					if (isLastLetter)
					{
						billetPhones.push_back(newConsonantPhone("D", nullptr));
						continue;
					}
					else
					{
						wchar_t nextLetter = word[i + 1];
						if (nextLetter == Letter_Z)
						{
							billetPhones.push_back(newConsonantPhone("DZ", nullptr));
							i += 1; // skip next letter
							continue;
						}
						else if (nextLetter == Letter_ZH)
						{
							billetPhones.push_back(newConsonantPhone("DZH", SoftHardConsonant::Hard));
							i += 1; // skip next letter
							continue;
						}
					}
				}
				if (letter == Letter_Z)
				{
					if (i + 1 < word.size()) // size(ZH)=1
					{
						// Z ZH -> ZH ZH
						// çæåð [ZH ZH E R]
						if (word[i + 1] == Letter_ZH)
						{
							// skip first T
							billetPhones.push_back(newConsonantPhone("ZH", SoftHardConsonant::Hard));
							billetPhones.push_back(newConsonantPhone("ZH", SoftHardConsonant::Hard));
							i += 1;
							continue;
						}
					}
					if (i + 2 < word.size()) // size(D ZH)=2
					{
						// Z D ZH -> ZH DZH
						// ç'¿çäæàþòü [Z J I ZH DZH A J U T]
						if (word[i + 1] == Letter_D && word[i + 2] == Letter_ZH)
						{
							// skip first T
							billetPhones.push_back(newConsonantPhone("ZH", SoftHardConsonant::Hard));
							billetPhones.push_back(newConsonantPhone("DZH", SoftHardConsonant::Hard));
							i += 2;
							continue;
						}
					}
				}

				// B->P, H->KH, D->T, ZH->SH, Z->S before unvoiced sound
				// B->P íåîáõ³äíî [N E O P KH I D N O]
				// H->KH äîïîìîãòè [D O P O M O KH T Y]
				// D->T øâèäêî [SH V Y T K O]
				// ZH->SH äóæ÷å [D U SH CH E]
				// Z->S áåçïåêè [B E S P E K A]
				bool beforeUnvoiced = false;
				bool isNextSoftSign = false;
				if (!isLastLetter)
				{
					wchar_t nextLetter = word[i + 1];
					if (isUnvoicedCharUk(nextLetter))
						beforeUnvoiced = true;
					else
					{
						// check if the next letter is a soft sign and then the unvoiced consonant
						if (nextLetter == Letter_SoftSign)
						{
							isNextSoftSign = true;
							if (i + 2 < word.size())
							{
								wchar_t nextNextLetter = word[i + 2];
								if (isUnvoicedCharUk(nextNextLetter))
									beforeUnvoiced = true;
							}
						}
					}
				}
				if (!beforeUnvoiced)
				{
					PhoneBillet ph;
					if (letter == Letter_B)
						ph = newConsonantPhone("B", SoftHardConsonant::Hard);
					else if (letter == Letter_H)
						ph = newConsonantPhone("H", SoftHardConsonant::Hard);
					else if (letter == Letter_D)
						ph = newConsonantPhone("D", nullptr);
					else if (letter == Letter_ZH)
						ph = newConsonantPhone("ZH", SoftHardConsonant::Hard);
					else if (letter == Letter_Z)
						ph = newConsonantPhone("Z", nullptr);
					else PG_Assert(false);
					billetPhones.push_back(ph);
				}
				else
				{
					PhoneBillet ph;
					if (letter == Letter_B)
						ph = newConsonantPhone("P", SoftHardConsonant::Hard);
					else if (letter == Letter_H)
						ph = newConsonantPhone("KH", SoftHardConsonant::Hard);
					else if (letter == Letter_D)
						ph = newConsonantPhone("T", nullptr);
					else if (letter == Letter_ZH)
						ph = newConsonantPhone("SH", SoftHardConsonant::Hard);
					else if (letter == Letter_Z)
						ph = newConsonantPhone("S", nullptr);
					else PG_Assert(false);

					if (isNextSoftSign)
						ph.SoftHard = SoftHardConsonant::Soft; // softened by soft sign
					billetPhones.push_back(ph);
				}
				continue;
			}
			else if (letter == Letter_E)
			{
				if (!billetPhones.empty())
				{
					// Rule: the vowel E dictates that the previous consonant is always hard
					PhoneBillet& prevPh = billetPhones.back();
					if (prevPh.DerivedFromChar == CharGroup::Consonant)
					{
						boost::optional<SoftHardConsonant> prevValue = prevPh.SoftHard;
						if (prevValue != nullptr)
						{
							bool ok = prevValue == SoftHardConsonant::Hard;
							PG_DbgAssert(ok && "otherwise, hardening the soft consonant?");
						}
						prevPh.SoftHard = SoftHardConsonant::Hard;
					}
				}
				billetPhones.push_back(newVowelPhone("E", nullptr));
				continue;
			}
			else if (letter == Letter_I)
			{
				if (!billetPhones.empty())
				{
					// Rule: the vowel I dictates that the previous consonant is always soft
					// TODO: what to do if the previous letter is always hard (â³ëüÿì, ï³ð'ÿ)
					PhoneBillet& prevPh = billetPhones.back();
					if (prevPh.DerivedFromChar == CharGroup::Consonant && prevPh.SoftHard == nullptr)
					{
						//boost::optional<SoftHardConsonant> prevValue = prevPh.SoftHard;
						//if (prevValue != nullptr)
						//{
						//	bool ok = prevValue == SoftHardConsonant::Soft;
						//	PG_DbgAssert(ok && "otherwise, softening the hard consonant?");
						//}
						prevPh.SoftHard = SoftHardConsonant::Soft;
					}
				}
				billetPhones.push_back(newVowelPhone("I", nullptr));
				continue;
			}
			else if (letter == Letter_JI)
			{
				// Rule: letter JI always converts as J and I
				billetPhones.push_back(newConsonantPhone("J", SoftHardConsonant::Hard));
				billetPhones.push_back(newVowelPhone("I", nullptr));
			}
			else if (letter == Letter_SHCH)
			{
				billetPhones.push_back(newConsonantPhone("SH", SoftHardConsonant::Hard));
				billetPhones.push_back(newConsonantPhone("CH", SoftHardConsonant::Hard));
			}
			else if (letter == Letter_JE || letter == Letter_JU || letter == Letter_JA)
			{
				bool doublePhone = false;
				if (isFirstLetter)
					doublePhone = true;
				else
				{
					wchar_t prevLetter = word[i - 1];
					bool prevVowel = isUkrainianVowel(prevLetter);
					if (prevVowel)
						doublePhone = true;
				}

				if (doublePhone)
				{
					// First letter:
					// ºâðåé [J E V R E J]
					// þíàê [J U N A K]
					// ÿáëóêî [J A B L U K O]
					// Previous letter is the vowel:
					// âçàºìíî [V Z A J E M N O]
					// íàñòîþ [N A S T O J U]
					// àáèÿê [A B Y J A K]
					billetPhones.push_back(newConsonantPhone("J", SoftHardConsonant::Hard));
				}

				if (letter == Letter_JE)
				{
					// ñóòòºâî [S U T T E V O]
					billetPhones.push_back(newVowelPhone("E", nullptr));
				}
				else if (letter == Letter_JU)
				{
					// îëåêñþê [O L E K S U K]
					// áóðþ [B U R U]
					billetPhones.push_back(newVowelPhone("U", nullptr));
				}
				else if (letter == Letter_JA)
				{
					// áóðÿ [B U R A]
					// çîðÿíèé [Z O R A N Y J]
					billetPhones.push_back(newVowelPhone("A", nullptr));
				}
				else
					PG_Assert(false, "Current letter=JE or JU or JA");
			}
			else if (letter == Letter_N)
			{
				if (i + 3 < word.size()) // size(T S T)=3
				{
					// N T S T -> N S T
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_S && word[i + 3] == Letter_T)
					{
						// skip first T
						billetPhones.push_back(newConsonantPhone("N", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("S", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("T", SoftHardConsonant::Hard));
						i += 3;
						continue;
					}
				}
				if (i + 4 < word.size()) // size(T S 1 K)=4
				{
					// N T S 1 K -> N S1 K
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_S && word[i + 3] == Letter_SoftSign && word[i + 4] == Letter_K)
					{
						// skip first T
						billetPhones.push_back(newConsonantPhone("N", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("S", SoftHardConsonant::Soft));
						billetPhones.push_back(newConsonantPhone("K", SoftHardConsonant::Hard));
						i += 4;
						continue;
					}
				}
				billetPhones.push_back(newConsonantPhone("N", nullptr));
			}
			else if (letter == Letter_S)
			{
				if (i + 1 < word.size()) // size(SH)=1
				{
					// S SH -> SH SH
					// äîí³ñøè [D O N I SH SH Y]
					if (word[i + 1] == Letter_SH)
					{
						billetPhones.push_back(newConsonantPhone("SH", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("SH", SoftHardConsonant::Hard));
						i += 1;
						continue;
					}
				}
				if (i + 2 < word.size()) // size(T D)=2
				{
					// S T D -> Z D
					// ø³ñòäåñÿò [SH I Z D E S A T]
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_D)
					{
						billetPhones.push_back(newConsonantPhone("Z", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("D", SoftHardConsonant::Hard));
						i += 2;
						continue;
					}
				}
				// check STS1K group before STS group, because latter is inside the former
				if (i + 4 < word.size()) // size(T S 1 K)=4
				{
					// S T S 1 K -> S1 K
					// íàöèñòñüêî¿ [N A TS Y S1 K O J I]
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_S && word[i + 3] == Letter_SoftSign && word[i + 4] == Letter_K)
					{
						billetPhones.push_back(newConsonantPhone("S", SoftHardConsonant::Soft));
						billetPhones.push_back(newConsonantPhone("K", SoftHardConsonant::Hard));
						i += 4;
						continue;
					}
				}
				if (i + 2 < word.size()) // size(T S)=2
				{
					// S T S -> S S
					// ø³ñòñîò [SH I S S O T]
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_S)
					{
						billetPhones.push_back(newConsonantPhone("S", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("S", SoftHardConsonant::Hard));
						i += 2;
						continue;
					}
				}
				if (i + 2 < word.size()) // size(T TS)=2
				{
					// S T TS -> S TS
					// â³äïóñòö³ [V I D P U S TS I]
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_TS)
					{
						billetPhones.push_back(newConsonantPhone("S", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("TS", SoftHardConsonant::Hard));
						i += 2;
						continue;
					}
				}
				billetPhones.push_back(newConsonantPhone("S", nullptr));
			}
			else if (letter == Letter_T)
			{
				if (i + 1 < word.size()) // size(S)=1
				{
					// T S -> TS
					// ï'ÿòñîò [P J A TS O T]
					if (word[i + 1] == Letter_S)
					{
						billetPhones.push_back(newConsonantPhone("TS", SoftHardConsonant::Hard));
						i += 1;
						continue;
					}
				}
				if (i + 2 < word.size()) // size(1 S)=2
				{
					// T 1 S -> TS
					// òðèìàòèìåòüñÿ [T R Y M A T Y M E TS1 A]
					if (word[i + 1] == Letter_SoftSign && word[i + 2] == Letter_S)
					{
						// if òö -> TS TS
						billetPhones.push_back(newConsonantPhone("TS", SoftHardConsonant::Soft));
						i += 2;
						continue;
					}
				}
				if (i + 1 < word.size()) // size(TS)=1
				{
					// T TS -> TS TS
					// êë³òö³ [K L I TS TS I]
					if (word[i + 1] == Letter_TS)
					{
						billetPhones.push_back(newConsonantPhone("TS", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("TS", SoftHardConsonant::Hard));
						i += 1;
						continue;
					}
				}
				if (i + 1 < word.size()) // size(CH)=1
				{
					// T CH -> CH CH
					// îò÷å [O CH CH E]
					if (word[i + 1] == Letter_CH)
					{
						billetPhones.push_back(newConsonantPhone("CH", SoftHardConsonant::Hard));
						billetPhones.push_back(newConsonantPhone("CH", SoftHardConsonant::Hard));
						i += 1;
						continue;
					}
				}
				billetPhones.push_back(newConsonantPhone("T", nullptr));
			}
			else if (letter == Letter_SoftSign)
			{
				// soften the previous char
				if (!billetPhones.empty())
				{
					PhoneBillet& ph = billetPhones.back();
					bool ok = ph.DerivedFromChar == CharGroup::Consonant;
					if (!ok)
						return std::make_tuple(false, "Only consonant can be softened");
					ph.SoftHard = SoftHardConsonant::Soft;
				}

				if (!isLastLetter)
				{
					wchar_t nextLetter = word[i + 1];
					if (nextLetter == Letter_JA)
					{
						// êîíüÿêó [K O N1 J A K]
						billetPhones.push_back(newConsonantPhone("J", SoftHardConsonant::Hard));
						billetPhones.push_back(newVowelPhone("A", nullptr));
						i += 1; // skip next letter
					}
					else if (nextLetter == Letter_JE)
					{
						// ìîñüº [M O S1 J E]
						billetPhones.push_back(newConsonantPhone("J", SoftHardConsonant::Hard));
						billetPhones.push_back(newVowelPhone("E", nullptr));
						i += 1; // skip next letter
					}
					else if (nextLetter == Letter_JU)
					{
						// íüþ [N J U]
						billetPhones.push_back(newConsonantPhone("J", SoftHardConsonant::Hard));
						billetPhones.push_back(newVowelPhone("U", nullptr));
						i += 1; // skip next letter
					}
					else
					{
						// ignore it
					}
				}
			}
			else if (letter == Letter_Apostrophe)
			{
				// harden the previous char
				if (!billetPhones.empty())
				{
					PhoneBillet& ph = billetPhones.back();
					bool ok = ph.DerivedFromChar == CharGroup::Consonant;
					if (!ok)
						return std::make_tuple(false, "Only consonant can be hardened");
					ph.SoftHard = SoftHardConsonant::Hard;
				}

				if (isLastLetter)
				{
					// apostrophe is the last char when the given word is a truncated part of some complete word
					// ignore it
				}
				else
				{
					wchar_t nextLetter = word[i + 1];
					if (nextLetter == Letter_JA)
					{
						// áóð'ÿí [B U R J A N]
						billetPhones.push_back(newConsonantPhone("J", SoftHardConsonant::Hard));
						billetPhones.push_back(newVowelPhone("A", nullptr));
						i += 1; // skip next letter
					}
					else if (nextLetter == Letter_JE)
					{
						// êàð'ºð [K A R J E R]
						billetPhones.push_back(newConsonantPhone("J", SoftHardConsonant::Hard));
						billetPhones.push_back(newVowelPhone("E", nullptr));
						i += 1; // skip next letter
					}
					else if (nextLetter == Letter_JU)
					{
						// êîìï'þòåð [K O M P J U T E R]
						billetPhones.push_back(newConsonantPhone("J", SoftHardConsonant::Hard));
						billetPhones.push_back(newVowelPhone("U", nullptr));
						i += 1; // skip next letter
					}
					else
					{
						// ignore it
					}
				}
			}
			else if (letter == Letter_Hyphen)
			{
				// ignore, soft sign has no pronunciation
			}
			else
			{
				return std::make_tuple(false, "Unknown letter");
			}
		}
		{
			// rule: one vowel in a word is always stressed (not works with abbreviation eg USA)
			int numVowels = 0;
			PhoneBillet* lastPhone = nullptr;
			for (PhoneBillet& ph : billetPhones)
			{
				if (ph.DerivedFromChar == CharGroup::Vowel)
				{
					numVowels++;
					lastPhone = &ph;
				}
			}
			if (numVowels == 1)
				lastPhone->IsStressed = true;
		}

		// build phoneIds sequnces from phone billets
		std::transform(billetPhones.cbegin(), billetPhones.cend(), std::back_inserter(phones), [&phoneReg](const PhoneBillet& ph) -> PhoneId
		{
			boost::optional<PhoneId> phoneId = nullptr;
			if (ph.DerivedFromChar == CharGroup::Consonant)
			{
				boost::optional<SoftHardConsonant> softHard = ph.SoftHard;
				if (softHard == nullptr)
					softHard = phoneReg.defaultSoftHardConsonant();
				phoneId = phoneReg.phoneIdSingle(ph.BasicPhoneStrId, softHard, nullptr);
			}
			else if (ph.DerivedFromChar == CharGroup::Vowel)
			{
				boost::optional<bool> isStressed = ph.IsStressed;
				if (isStressed == nullptr)
					isStressed = phoneReg.defaultIsVowelStressed();
				phoneId = phoneReg.phoneIdSingle(ph.BasicPhoneStrId, nullptr, isStressed);
			}
			PG_Assert(phoneId != nullptr && "Can't map phone billet to phoneId");
			return phoneId.get();
		});

		return std::make_tuple(true, nullptr);
	}

	void updatePhoneModifiers(const PhoneRegistry& phoneReg, bool keepConsonantSoftness, bool keepVowelStress, std::vector<PhoneId>& phonesList)
	{
		for (size_t i = 0; i < phonesList.size(); ++i)
		{
			PhoneId phoneId = phonesList[i];

			const Phone* oldPhone = phoneReg.phoneById(phoneId);
			const BasicPhone* basicPhone = phoneReg.basicPhone(oldPhone->BasicPhoneId);

			if (!keepConsonantSoftness && basicPhone->DerivedFromChar == CharGroup::Consonant)
			{
				if (oldPhone->SoftHard == SoftHardConsonant::Soft)
				{
					boost::optional<PhoneId> newPhoneId = phoneReg.phoneIdSingle(oldPhone->BasicPhoneId, SoftHardConsonant::Hard, nullptr);
					PG_DbgAssert(newPhoneId != nullptr);
					phonesList[i] = newPhoneId.get();
					continue;
				}
			}
			if (!keepVowelStress && basicPhone->DerivedFromChar == CharGroup::Vowel)
			{
				if (oldPhone->IsStressed == true)
				{
					boost::optional<PhoneId> newPhoneId = phoneReg.phoneIdSingle(oldPhone->BasicPhoneId, nullptr, false);
					PG_DbgAssert(newPhoneId != nullptr);
					phonesList[i] = newPhoneId.get();
					continue;
				}
			}
		}
	}

	//

	template <typename T>
	bool endsWith(wv::slice<T> items, wv::slice<T> suffix)
	{
		if (suffix.size() > items.size())
			return false; // suffix will not fit the items?

		size_t itemsStartInd = items.size() - suffix.size();
		for (int i = 0; i < suffix.size(); ++i)
		{
			if (suffix[i] == items[itemsStartInd + i])
				continue;
			return false;
		}
		return true;
	}
	template <typename T>
	bool startsWith(wv::slice<T> items, wv::slice<T> prefix)
	{
		if (prefix.size() > items.size())
			return false; // prefix will not fit the items?

		for (int i = 0; i < prefix.size(); ++i)
		{
			if (prefix[i] == items[i])
				continue;
			return false;
		}
		return true;
	}

	// Finds the length of the common prefix of two words.
	template <typename T>
	size_t commonPrefixSize(wv::slice<T> word, wv::slice<T> other)
	{
		size_t minSize = std::min(word.size(), other.size());

		for (size_t i = 0; i < minSize; ++i)
		{
			if (word[i] != other[i])
				return i;
		}
		return minSize;
	}

	struct SuffixEnd
	{
		std::wstring MatchSuffix;
		int TakeCharsCount;
		WordClass WordClass = WordClass::Verb;
		int UsedCount = 0;

		SuffixEnd(const std::wstring& matchSuffix, int takeCharsCount)
			: MatchSuffix(matchSuffix),
			TakeCharsCount(takeCharsCount) {}
		SuffixEnd(const std::wstring& matchSuffix, int takeCharsCount, PticaGovorun::WordClass wordClass)
			: MatchSuffix(matchSuffix),
			TakeCharsCount(takeCharsCount),
			WordClass(wordClass) {}
	};

	std::vector<SuffixEnd> sureSuffixes;
	std::map<std::wstring, std::wstring> participleSuffixToWord;
	std::map<std::wstring, std::wstring> participleSuffixToWord2;

	void ensureSureSuffixesInitialized()
	{
		// good: íàçèâàòè ³ñíóþòü
		// verb+t1
		// èòè
		static std::vector<SuffixEnd> sureSuffixesStatic = {
			{ std::wstring(    L"à"), 1, WordClass::Noun }, // ðó÷ê~à noun
			{ std::wstring(    L"à"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~à ñò~à
			{ std::wstring(    L"à"), 1, WordClass::Adjective }, // áëèæ÷~à adj
			{ std::wstring(  L"àëà"), 2 }, // ñêàçà~ëà
			{ std::wstring(L"óâàëà"), 4 }, // ³ñíó~âàëà àêòóàë³çó~âàëà
			{ std::wstring(L"þâàëà"), 4 }, // áàçàðþ~âàëà
			{ std::wstring(  L"èëà"), 2 }, // æè~ëà áè~ëà
			{ std::wstring(  L"³ëà"), 2 }, // áóðêîò³~ëà
			//{ std::wstring(  L"¿ëà"), 2 }, // áëàãîóñòðî¿~ëà
			{ std::wstring( L"î¿ëà"), 3 }, // áëàãîóñòðî~¿ëà
			{ std::wstring(  L"îëà"), 2 }, // áîðî~ëà
			{ std::wstring(  L"óëà"), 2 }, // áàìêíó~ëà
			{ std::wstring(  L"üìà"), 2, WordClass::Numeral}, // äåâ'ÿòü~ìà
			{ std::wstring(  L"îìà"), 3, WordClass::Numeral}, // äâ~îìà äåâ'ÿòü~îìà
			{ std::wstring(  L"³øà"), 3, WordClass::Adjective }, // àáñóðäí~³øà

			{ std::wstring(  L"àâ"), 1 }, // áóâà~â íàçèâà~â ìà~â âïëèâà~â
			{ std::wstring(L"óâàâ"), 3 }, // àêòóàë³çó~âàâ ³ñíó~âàâ
			{ std::wstring(L"þâàâ"), 3 }, // áàçàðþ~âàâ
			//{ std::wstring(  L"åâ"), 1 }, // ?? NOT äåðåâ~
			{ std::wstring(  L"èâ"), 1 }, // áåç÷åñòè~â áè~â
			{ std::wstring(  L"³â"), 1 }, // áóðêîò³~â
			{ std::wstring(  L"³â"), 2, WordClass::Noun }, // ôóðãîí~³â noun
			{ std::wstring(  L"¿â"), 2, WordClass::Noun }, // àãðàð³~¿â îäíîñòðî~¿â noun
			//{ std::wstring(  L"¿â"), 1 }, // îäíîñòðî¿~â áëàãîóñòðî¿~â
			{ std::wstring( L"³¿â"), 2 }, // áëàãîóñòðî~¿â
			{ std::wstring( L"î¿â"), 2 }, // áëàãîóñòðî~¿â verb
			{ std::wstring(  L"îâ"), 1 }, // áîðî~â (weird word, =áîðîâñÿ)
			{ std::wstring(  L"îâ"), 2, WordClass::Noun }, // öåðê~îâ
			{ std::wstring(  L"óâ"), 1 }, // áàìêíó~â

			{ std::wstring(        L"å"), 1 }, // áåð~å áàìêí~å
			{ std::wstring(        L"å"), 1, WordClass::Adjective }, // áëèæ÷~å áëèçüê~å
			{ std::wstring(        L"å"), 1, WordClass::Noun }, // ôóðãîí~å
			{ std::wstring(        L"å"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~å
			{ std::wstring(      L"èìå"), 2 }, // áðåñòè~ìå
			{ std::wstring(    L"àòèìå"), 4 }, // íàçèâà~òèìå
			{ std::wstring(    L"ÿòèìå"), 4 }, // ðîçìîâëÿ~òèìå
			{ std::wstring(  L"óâàòèìå"), 6 }, // ³ñíó~âà~òèìå àêòóàë³çó~âàòèìå
			{ std::wstring(  L"þâàòèìå"), 6 }, // áàçàðþ~âà~òèìå
			{ std::wstring(    L"èòèìå"), 4 }, // ðîáè~òèìå áè~òèìå
			{ std::wstring(    L"³òèìå"), 4 }, // áóðêîò³~òèìå
			//{ std::wstring(    L"¿òèìå"), 4 }, // ãíî¿~òèìå
			{ std::wstring(   L"î¿òèìå"), 5 }, // ãíî~¿òèìå
			{ std::wstring(    L"îòèìå"), 4 }, // áîðî~òèìå
			{ std::wstring(    L"óòèìå"), 4 }, // áëÿêíó~òèìå
			{ std::wstring(     L"àéòå"), 3 }, // íàçèâà~éòå âïëèâà~éòå
			{ std::wstring(     L"³éòå"), 3 }, // áóð³~éòå
			{ std::wstring(     L"îéòå"), 3 }, // áëàãîóñòðî~éòå
			{ std::wstring(     L"óéòå"), 3 }, // ó~éòå ³ñíó~éòå
			{ std::wstring(     L"þéòå"), 3 }, // äîð³âíþ~éòå
			//{ std::wstring(       L"òå"), 2 }, // áóðêîòü~òå
			{ std::wstring(      L"åòå"), 2 }, // áåðå~òå áàìêíå~òå
			//{ std::wstring(     L"ìåòå"), 4 }, // â³çü~ìåòå
			{ std::wstring(    L"èìåòå"), 4 }, // ³òè~ìåòå
			{ std::wstring(  L"àòèìåòå"), 6 }, // ³ñíó~âà~òèìåòå ìà~òèìåòå áðà-òèìåòå
			{ std::wstring(  L"èòèìåòå"), 6 }, // áåç÷åñòè~òèìåòå áè~òèìåòå
			{ std::wstring(  L"³òèìåòå"), 6 }, // áóðêîò³~òèìåòå
			//{ std::wstring(  L"¿òèìåòå"), 6 }, // ãíî¿~òèìåòå
			{ std::wstring(  L"î¿òèìåòå"), 7 }, // ãíî~¿òèìåòå
			{ std::wstring(  L"îòèìåòå"), 6 }, // áîðî~òèìåòå
			{ std::wstring(  L"óòèìåòå"), 6 }, // áëÿêíó~òèìåòå
			{ std::wstring(L"óâàòèìåòå"), 8 }, // àêòóàë³çó~âàòèìåòå
			{ std::wstring(L"þâàòèìåòå"), 8 }, // äîð³âíþ~âàòèìåòå
			{ std::wstring(    L"üìåòå"), 4 }, // â³çü~ìåòå
			{ std::wstring(     L"àºòå"), 3 }, // çíà~ºòå
			{ std::wstring(     L"³ºòå"), 3 }, // áóð³~ºòå
			{ std::wstring(     L"óºòå"), 3 }, // ³ñíó~ºòå
			{ std::wstring(     L"þºòå"), 3 }, // äîð³âíþ~ºòå
			{ std::wstring(     L"'ºòå"), 3 }, // á'~ºòå
			{ std::wstring(      L"èòå"), 2 }, // áóðêîòè~òå
			{ std::wstring(      L"³òå"), 2 }, // áåð³~òå áàìêí³~òå
			//{ std::wstring(      L"¿òå"), 2 }, // áëàãîóñòðî¿~òå
			{ std::wstring(     L"î¿òå"), 3 }, // áëàãîóñòðî~¿òå
			{ std::wstring(     L"èéòå"), 3 }, // áè~éòå
			{ std::wstring(      L"üòå"), 2 }, // áóðêîòü~òå
			{ std::wstring(      L"³øå"), 3, WordClass::Adjective }, // àáñóðäí~³øå
			{ std::wstring(      L"³øå"), 3, WordClass::Adverb }, // àçàðòí~³øå
			{ std::wstring( L"º"), 1, WordClass::Adjective }, // àâòîäîðîæí~º
			{ std::wstring(L"àº"), 1 }, // âïëèâà~º
			{ std::wstring(L"åº"), 2, WordClass::Adjective }, // áåçïîñàäêîâ~åº áàãàòåíüê~åº áëèçüê~åº adj
			{ std::wstring(L"³º"), 1 }, // áóð³~º
			{ std::wstring(L"óº"), 1 }, // ³ñíó~º
			{ std::wstring(L"þº"), 1 }, // äîð³âíþ~º
			{ std::wstring(L"'º"), 1, WordClass::Noun }, // ñ³ì'~º

			{ std::wstring(     L"è"), 1, WordClass::Noun }, // ðó÷ê~è áóðêí~è áåðåæ~è ðåêëàì~è noun
			{ std::wstring(     L"è"), 1, WordClass::Numeral }, // ø³ñòäåñÿò~è
			{ std::wstring(   L"àëè"), 2 }, // áóâà~ëè
			{ std::wstring( L"óâàëè"), 4 }, // àêòóàë³çó~âàëè ³ñíó~âàëè
			{ std::wstring( L"þâàëè"), 4 }, // áàçàðþ~âàëè (soft U, not J-U)
			{ std::wstring(   L"èëè"), 2 }, // áè~ëè
			{ std::wstring(   L"³ëè"), 2 }, // áóðêîò³~ëè
			//{ std::wstring(   L"¿ëè"), 2 }, // áëàãîóñòðî¿~ëè
			{ std::wstring(  L"î¿ëè"), 3 }, // áëàãîóñòðî~¿ëè
			{ std::wstring(   L"îëè"), 2 }, // áîðî~ëè
			{ std::wstring(   L"óëè"), 2 }, // áàìêíó~ëè
			{ std::wstring(   L"àìè"), 3, WordClass::Numeral }, // ÷îòèðìàñò~àìè
			{ std::wstring(   L"èìè"), 2 }, // âåëèêè~ìè
			{ std::wstring(   L"èìè"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èìè
			//{ std::wstring( L"îâèìè"), 5 }, // adjective
			{ std::wstring(   L"àìè"), 3, WordClass::Noun }, // ðåêëàì~àìè ðóê~àìè ðó÷ê~àìè ôóðãîí~àìè
			{ std::wstring(   L"ÿìè"), 3, WordClass::Noun }, // àãðàð³~ÿìè îáñëóãîâóâàíí~ÿìè
			//{ std::wstring(  L"îÿìè"), 2 }, // è~ëè noun
			{ std::wstring(  L"'ÿìè"), 3, WordClass::Noun }, // ñ³ì'~ÿìè
			{ std::wstring(   L"àòè"), 2 }, // âïëèâà~òè áðà~òè
			{ std::wstring( L"þâàòè"), 4 }, // áàçàðþ~âàòè (soft U)
			{ std::wstring(   L"èòè"), 2 }, // æè~òè àðêàíè~òè áè~òè
			{ std::wstring(   L"³òè"), 2 }, // áóðêîò³~òè
			//{ std::wstring(   L"¿òè"), 2 }, // áëàãîóñòðî¿~òè
			{ std::wstring(  L"î¿òè"), 3 }, // áëàãîóñòðî~¿òè
			{ std::wstring(   L"îòè"), 2 }, // áîðî~òè
			{ std::wstring(   L"óòè"), 2 }, // áàìêíó~òè
			{ std::wstring( L"óâàòè"), 4 }, // àêòóàë³çó~âàòè
			{ std::wstring(   L"à÷è"), 2, WordClass::VerbalAdverb }, // áóðëà÷à~÷è âàíòàæà~÷è
			{ std::wstring(   L"ó÷è"), 2, WordClass::VerbalAdverb }, // áåðó~÷è áåðåæó~÷è
			{ std::wstring(   L"þ÷è"), 3, WordClass::VerbalAdverb }, // áîð~þ÷è ?
			//{ std::wstring(  L"àþ÷è"), 3, WordClass::VerbalAdverb }, // íåçâàæà~þ÷è áóâà~þ÷è
			//{ std::wstring(  L"³þ÷è"), 3, WordClass::VerbalAdverb }, // áóð³~þ÷è áàéäóæ³~þ÷è
			//{ std::wstring(  L"óþ÷è"), 3, WordClass::VerbalAdverb }, // ó~þ÷è ³ñíó~þ÷è
			//{ std::wstring(  L"þþ÷è"), 3, WordClass::VerbalAdverb }, // äîð³âíþ~þ÷è
			//{ std::wstring(  L"'þ÷è"), 3, WordClass::VerbalAdverb }, // á'~þ÷è
			{ std::wstring(   L"ÿ÷è"), 3, WordClass::VerbalAdverb }, // áóðêîò~ÿ÷è âèõîä~ÿ÷è áóä~ÿ÷è
			{ std::wstring(  L"îÿ÷è"), 3, WordClass::VerbalAdverb }, // ãíî~ÿ÷è
			{ std::wstring(  L"àâøè"), 3, WordClass::VerbalAdverb }, // ìà~âøè çíà~âøè áðà~âøè
			{ std::wstring(  L"³âøè"), 3, WordClass::VerbalAdverb }, // áóðêîò³~âøè áóáîò³~âøè
			//{ std::wstring(  L"¿âøè"), 3, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøè
			{ std::wstring( L"î¿âøè"), 4, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøè
			{ std::wstring(  L"óâøè"), 3, WordClass::VerbalAdverb }, // áàìêíó~âøè áó~âøè
			{ std::wstring(  L"èâøè"), 3, WordClass::VerbalAdverb }, // áåç÷åñòè~âøè áè~âøè
			{ std::wstring(  L"îâøè"), 3, WordClass::VerbalAdverb }, // áîðî~âøè
			{ std::wstring(L"þâàâøè"), 5, WordClass::VerbalAdverb }, // ³äîð³âíþ~âàâøè àñîö³þ~âàâøè
			{ std::wstring(L"óâàâøè"), 5, WordClass::VerbalAdverb }, // ³ñíó~âàâøè àêòóàë³çó~âàâøè áó~âàâøè

			{ std::wstring(   L"³"), 1, WordClass::Noun }, // òàê~³ óêðà¿í~³
			{ std::wstring(   L"³"), 1, WordClass::Adjective }, // áëèæ÷~³ áëèçüê~³
			{ std::wstring(   L"³"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³
			{ std::wstring(L"îºâ³"), 3, WordClass::Noun }, // îäíîñòðî~ºâ³ noun
			{ std::wstring( L"åâ³"), 3, WordClass::Noun }, // êíÿç~åâ³
			{ std::wstring( L"ºâ³"), 3, WordClass::Noun }, // àãðàð³~ºâ³
			{ std::wstring( L"îâ³"), 3, WordClass::Noun }, // ôóðãîí~îâ³ noun
			{ std::wstring( L"³ø³"), 3, WordClass::Adjective }, // àáñóðäí~³ø³ adj

			{ std::wstring( L"¿"), 1, WordClass::Adjective }, // á³ëîøè~¿
			{ std::wstring( L"¿"), 1, WordClass::Noun }, // îäíîñòðî~¿
			{ std::wstring(L"å¿"), 1, WordClass::Noun }, // ìóçå~¿
			{ std::wstring(L"º¿"), 2, WordClass::Pronoun }, // ö³~º¿
			{ std::wstring(L"è¿"), 1, WordClass::Noun }, // êîëîìè~¿
			{ std::wstring(L"³¿"), 2, WordClass::Adjective }, // áàãàòåíüê~³¿ áåçïîñàäêîâ~³¿ adj
			{ std::wstring(L"³¿"), 1, WordClass::Noun }, // ïîëîíiçàöi~¿ òåëåïîðòàö³~¿ ë³í³~¿
			{ std::wstring(L"î¿"), 2, WordClass::Adjective }, // çàìîæí~î¿
			{ std::wstring(L"î¿"), 1, WordClass::Noun }, // îäíîñòðî~¿
			{ std::wstring(L"î¿"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~î¿
			{ std::wstring(L"ó¿"), 1, WordClass::Noun }, // áóðæó~¿
			{ std::wstring(L"þ¿"), 1 }, // áðþ~¿
			{ std::wstring(L"ÿ¿"), 1, WordClass::Noun }, // õàçÿ~¿

			{ std::wstring(      L"àé"), 1 }, // íàçèâà~é âïëèâà~é
			{ std::wstring(      L"åé"), 2, WordClass::Noun }, // ñ³ì~åé
			{ std::wstring(      L"èé"), 2, WordClass::Adjective }, // òåïë~èé áàãàòåíüê~èé adj 
			{ std::wstring(      L"èé"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èé
			{ std::wstring(      L"³é"), 2, WordClass::Adjective }, // óêðà¿íñüê~³é îñòàíí~³é àâòîäîðîæí~³é adj
			{ std::wstring(      L"³é"), 1, WordClass::Noun }, // îäíîñòð³~é îðãàí³çàö³~é noun
			{ std::wstring(      L"³é"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³é
			{ std::wstring(      L"³é"), 2, WordClass::Pronoun }, // ¿õí~³é
			{ std::wstring(      L"¿é"), 2, WordClass::Adjective }, // áåçêðà~¿é
			{ std::wstring(      L"îé"), 1 }, // áëàãîóñòðî~é
			{ std::wstring(      L"óé"), 1 }, // ³ñíó~é
			{ std::wstring(      L"þé"), 1 }, // äîð³âíþ~é
			{ std::wstring(    L"³ëèé"), 3, WordClass::Participle }, // áóð³~ëèé áàéäóæ³~ëèé ÈÉ
			{ std::wstring(    L"àíèé"), 3, WordClass::Participle }, // à~íèé áðà~íèé ÈÉ
			{ std::wstring(  L"îâàíèé"), 5, WordClass::Participle }, // àêòóàë³çî~âàíèé àí³ã³ëüî~âàíèé àñîö³éî~âàíèé
			{ std::wstring(  L"óâàíèé"), 5, WordClass::Participle }, // àðåøòîâó~âàíèé
			{ std::wstring(  L"þâàíèé"), 5, WordClass::Participle }, // ï³äîçðþ~âàíèé
			{ std::wstring(    L"åíèé"), 3, WordClass::Participle }, // áåç÷åùå~íèé áåðåæå~íèé âàíòàæå~íèé ÈÉ
			{ std::wstring(    L"ºíèé"), 4, WordClass::Adjective }, // áëàãîóñòðî~ºíèé ãíî~ºíèé çàñïîêî~ºíèé ÈÉ
			{ std::wstring(   L"îºíèé"), 4, WordClass::Adjective }, // áëàãîóñòðî~ºíèé ãíî~ºíèé çàñïîêî~ºíèé
			{ std::wstring(    L"èòèé"), 3, WordClass::Participle }, // áè~òèé
			{ std::wstring(    L"îòèé"), 3, WordClass::Participle }, // áîðî~òèé
			{ std::wstring(    L"óòèé"), 3, WordClass::Participle }, // áîâòíó~òèé
			{ std::wstring(    L"à÷èé"), 3, WordClass::Participle }, // áóðëà÷à~÷èé âàíòàæà~÷èé
			{ std::wstring(    L"ó÷èé"), 3, WordClass::Participle}, // áåðó~÷èé áàìêíó~÷èé áåðåæó~÷èé áóäó~÷èé
			{ std::wstring(    L"þ÷èé"), 4, WordClass::Participle }, // compound áîð~þ÷èé
			//{ std::wstring(   L"àþ÷èé"), 4, WordClass::Participle }, // âïëèâà~þ÷èé
			//{ std::wstring(   L"³þ÷èé"), 4, WordClass::Participle }, // áóð³~þ÷èé áàéäóæ³~þ÷èé
			//{ std::wstring(   L"óþ÷èé"), 4 , WordClass::Participle}, // ³ñíó~þ÷èé
			//{ std::wstring(   L"þþ÷èé"), 4, WordClass::Participle }, // äîð³âíþ~þ÷èé
			//{ std::wstring(   L"'þ÷èé"), 4, WordClass::Participle }, // á'~þ÷èé
			{ std::wstring(    L"ÿ÷èé"), 4, WordClass::Participle }, // áóðêîò~ÿ÷èé áóä~ÿ÷èé
			{ std::wstring(   L"îÿ÷èé"), 4, WordClass::Participle }, // ãíî~ÿ÷èé
			{ std::wstring(     L"øèé"), 3, WordClass::Adjective }, // áàãàò~øèé
			{ std::wstring(   L"àâøèé"), 4, WordClass::Participle }, // áðà~âøèé
			{ std::wstring( L"óâàâøèé"), 6, WordClass::Participle }, // ³ñíó~âàâøèé àêòóàë³çó~âàâøèé áó~âàâøèé
			{ std::wstring( L"þâàâøèé"), 6, WordClass::Participle }, // áàçàðþ~âàâøèé àñîö³þ~âàâøèé
			{ std::wstring(   L"èâøèé"), 4, WordClass::Participle }, // áåç÷åñòè~âøèé áè~âøèé
			{ std::wstring(   L"³âøèé"), 4, WordClass::Participle }, // áóðêîò³~âøèé áóáîò³~âøèé
			//{ std::wstring(   L"¿âøèé"), 4 }, // áëàãîóñòðî¿~âøèé
			{ std::wstring(  L"î¿âøèé"), 5, WordClass::Participle }, // áëàãîóñòðî~¿âøèé
			{ std::wstring(   L"îâøèé"), 4, WordClass::Participle }, // áîðî~âøèé
			{ std::wstring(   L"óâøèé"), 4, WordClass::Participle }, // áàìêíó~âøèé áó~âøèé
			{ std::wstring(    L"³øèé"), 4, WordClass::Adjective }, // àáñóðäí~³øèé

			{ std::wstring(      L"àì"), 2, WordClass::Noun }, // ôóðãîí~àì
			{ std::wstring(      L"àì"), 2, WordClass::Numeral }, // ÷îòèðüîìñò~àì
			{ std::wstring(      L"åì"), 1 }, // áåð~åì áàìêí~åì
			{ std::wstring(      L"åì"), 2, WordClass::Noun }, // ñàáîòàæ~åì ERROR: áóðîçåì~ àíàõòåì~(àíàõòåìà)
			{ std::wstring(    L"èìåì"), 3 }, // áðåñòè~ìåì
			{ std::wstring(  L"àòèìåì"), 5 }, // áðà~òèìåì
			{ std::wstring(  L"îòèìåì"), 5 }, // áîðî~òèìåì
			{ std::wstring(L"óâàòèìåì"), 7 }, // ³ñíó~âà~òèìåì àêòóàë³çó~âàòèìåì
			{ std::wstring(L"þâàòèìåì"), 7 }, // áàçàðþ~âà~òèìåì
			{ std::wstring(  L"èòèìåì"), 5 }, // ðîáè~òèìåì áè~òèìåì
			{ std::wstring(  L"³òèìåì"), 5 }, // òåðï³~òèìåì ?
			//{ std::wstring( L"¿òèìåì"), 5 }, // ãíî¿~òèìåì
			{ std::wstring( L"î¿òèìåì"), 6 }, // ãíî~¿òèìåì
			{ std::wstring(  L"óòèìåì"), 5 }, // áëÿêíó~òèìåì
			{ std::wstring(  L"ÿòèìåì"), 5 }, // ðîçìîâë~ÿòèìåì
			{ std::wstring(      L"ºì"), 2, WordClass::Noun }, // composite
			{ std::wstring(      L"ºì"), 2 }, // composite
			//{ std::wstring(     L"àºì"), 2 }, // çíà~ºì
			//{ std::wstring(     L"åºì"), 2 }, // ïðîìåòå~ºì noun
			//{ std::wstring(     L"³ºì"), 2 }, // êðèòåð³~ºì noun
			//{ std::wstring(     L"îºì"), 2 }, // îäíîñòðî~ºì
			//{ std::wstring(     L"óºì"), 2 }, // ÷ó~ºì
			//{ std::wstring(     L"þºì"), 2 }, // áàçàðþ~ºì
			//{ std::wstring(     L"'ºì"), 2 }, // á'~ºì
			{ std::wstring(      L"èì"), 1 }, // áóðêîòè~ì
			{ std::wstring(      L"èì"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èì
			{ std::wstring(      L"³ì"), 1 }, // áàìêí³~ì áåð³~ì áåðåæ³~ì
			{ std::wstring(      L"³ì"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³ì
			//{ std::wstring(      L"¿ì"), 1 }, // áëàãîóñòðî¿~ì
			{ std::wstring(     L"î¿ì"), 2 }, // áëàãîóñòðî~¿ì
			{ std::wstring(      L"îì"), 2, WordClass::Noun }, // ôóðãîí~îì
			{ std::wstring(      L"îì"), 2, WordClass::Numeral }, // äâ~îì îäèíàäöÿòü~îì
			{ std::wstring(      L"ÿì"), 2, WordClass::Noun }, // compound ëþä~ÿì îáñëóãîâóâàíí~ÿì
			//{ std::wstring(     L"îÿì"), 2, WordClass::Noun }, // îäíîñòðî~ÿì
			//{ std::wstring(     L"'ÿì"), 2, WordClass::Noun }, // ñ³ì'~ÿì

			{ std::wstring(        L"î"), 1 }, // ðó÷ê~î
			{ std::wstring(        L"î"), 1, WordClass::Adverb }, // àçàðòí~î adverb
			{ std::wstring(        L"î"), 1, WordClass::Numeral }, // ñò~î
			{ std::wstring(      L"îãî"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îãî
			{ std::wstring(     L"üîãî"), 3, WordClass::Pronoun }, // ¿õíü~îãî
			{ std::wstring(      L"àëî"), 2 }, // áðàêóâà~ëî
			{ std::wstring(    L"óâàëî"), 4 }, // ³ñíó~âàëî àêòóàë³çó~âàëî
			{ std::wstring(    L"þâàëî"), 4 }, // áàçàðþ~âàëî (soft U)
			{ std::wstring(      L"èëî"), 2 }, // æè~ëî áè~ëî
			{ std::wstring(      L"³ëî"), 2 }, // áóðêîò³~ëî
			//{ std::wstring(      L"¿ëî"), 2 }, // áëàãîóñòðî¿~ëî
			{ std::wstring(     L"î¿ëî"), 3 }, // áëàãîóñòðî~¿ëî
			{ std::wstring(      L"îëî"), 2 }, // áîðî~ëî
			{ std::wstring(      L"óëî"), 2 }, // áàìêíó~ëî
			//{ std::wstring(       L"ìî"), 2 }, // áóðêîòü~ìî áåç÷åñòü~ìî
			{ std::wstring(      L"åìî"), 2 }, // áåðå~ìî áàìêíå~ìî
			{ std::wstring(      L"èìî"), 2 }, // áóðêîòè~ìî
			{ std::wstring(  L"àòèìåìî"), 6 }, // ³ñíó~âà~òèìåìî ìà~òèìåìî
			{ std::wstring(  L"èòèìåìî"), 6 }, // æè~òèìåìî áè~òèìåìî
			{ std::wstring(  L"³òèìåìî"), 6 }, // áóðêîò³~òèìåìî
			//{ std::wstring(  L"¿òèìåìî"), 6 }, // ãíî¿~òèìåìî
			{ std::wstring( L"î¿òèìåìî"), 7 }, // ãíî~¿òèìåìî
			{ std::wstring(  L"îòèìåìî"), 6 }, // áîðî~òèìåìî
			{ std::wstring(  L"óòèìåìî"), 6 }, // áëÿêíó~òèìåìî
			{ std::wstring(L"óâàòèìåìî"), 8 }, // àêòóàë³çó~âàòèìåìî
			{ std::wstring(L"þâàòèìåìî"), 8 }, // äîð³âíþ~âàòèìåìî
			{ std::wstring(     L"àºìî"), 3 }, // çíà~ºìî
			{ std::wstring(     L"³ºìî"), 3 }, // áóð³~ºìî
			{ std::wstring(     L"óºìî"), 3 }, // ³ñíó~ºìî
			{ std::wstring(     L"þºìî"), 3 }, // äîð³âíþ~ºìî
			{ std::wstring(     L"'ºìî"), 3 }, // á'~ºìî
			{ std::wstring(      L"³ìî"), 2 }, // áåð³~ìî áàìêí³~ìî áåðåæ³~ìî
			//{ std::wstring(      L"¿ìî"), 2 }, // áëàãîóñòðî¿~ìî
			{ std::wstring(     L"î¿ìî"), 3 }, // áëàãîóñòðî~¿ìî
			//{ std::wstring(      L"éìî"), 3 }, // NOT êëåé*éìî
			{ std::wstring(     L"àéìî"), 3 }, // íàçèâà~éìî ðóøà~éìî
			//{ std::wstring(     L"åéìî"), 3 }, // no words
			{ std::wstring(     L"èéìî"), 3 }, // áóð³~éìî áè~éìî
			{ std::wstring(     L"³éìî"), 3 }, // áóð³~éìî
			{ std::wstring(     L"îéìî"), 3 }, // áëàãîóñòðî~éìî
			{ std::wstring(     L"óéìî"), 3 }, // ³ñíó~éìî àêòóàë³çó~éìî
			{ std::wstring(     L"þéìî"), 3 }, // äîð³âíþ~éìî
			{ std::wstring(     L"ÿéìî"), 3 }, // ïîð³âíÿ~éìî
			{ std::wstring(      L"üìî"), 2 }, // áóðêîòü~ìî áåç÷åñòü~ìî
			{ std::wstring(      L"åðî"), 3, WordClass::Numeral }, // äåâ'ÿò~åðî
			
			{ std::wstring(      L"ó"), 1, WordClass::Noun }, // noun, ðó÷ê~ó áåð~ó áóðêî÷~ó áåç÷åù~ó áåðåæ~ó
			{ std::wstring(      L"ó"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~ó
			//{ std::wstring(     L"ìó"), 2 }, // not usable (ôîð*ì~ó)
			//{ std::wstring(    L"àìó"), 2 }, // not usable (ñà*ì~ó)
			{ std::wstring(    L"ºìó"), 2, WordClass::Pronoun }, // ñâîº~ìó
			{ std::wstring(    L"èìó"), 2 }, // áåðåã*òè~ìó
			//{ std::wstring(   L"òèìó"), 4 }, // áåðåã*òèìó; ã*òèìó is too rare to use
			{ std::wstring(  L"àòèìó"), 4 }, // áðà~òèìó
			{ std::wstring(  L"èòèìó"), 4 }, // áåç÷åñòè~òèìó áè~òèìó
			{ std::wstring(  L"³òèìó"), 4 }, // áóðêîò³~òèìó
			//{ std::wstring(  L"¿òèìó"), 4 }, // ãíî¿~òèìó
			{ std::wstring( L"î¿òèìó"), 5 }, // ãíî~¿òèìó
			{ std::wstring(  L"îòèìó"), 4 }, // áîðî~òèìó
			{ std::wstring(  L"ñòèìó"), 4 }, // áðåñ~òèìó
			{ std::wstring(  L"óòèìó"), 4 }, // áëÿêíó~òèìó
			{ std::wstring(L"óâàòèìó"), 6 }, // ³ñíó~âàòèìó àêòóàë³çó~âàòèìó
			{ std::wstring(L"þâàòèìó"), 6 }, // áàçàðþ~âàòèìó
			{ std::wstring(    L"îìó"), 3, WordClass::Adjective }, // áþäæåòí~îìó adj
			{ std::wstring(    L"îìó"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îìó
			//{ std::wstring(    L"óìó"), 2 }, // not usable (ðîçó*ì~ó)

			{ std::wstring(  L"àõ"), 2, WordClass::Noun }, // ðó÷ê~àõ ôóðãîí~àõ
			{ std::wstring(  L"àõ"), 2, WordClass::Numeral }, // ÷îòèðüîõñò~àõ
			{ std::wstring(  L"èõ"), 2, WordClass::Adjective }, // áþäæåòí~èõ
			{ std::wstring(  L"èõ"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èõ
			{ std::wstring(  L"îõ"), 2, WordClass::Numeral }, // äåâ'ÿòü~îõ äâ~îõ
			{ std::wstring(  L"ÿõ"), 2, WordClass::Noun }, // compound
			//{ std::wstring( L"îÿõ"), 2, WordClass::Noun }, // îäíîñòðî~ÿõ
			//{ std::wstring(  L"ÿõ"), 2, WordClass::Noun }, // îáñëóãîâóâàíí~ÿõ
			//{ std::wstring( L"'ÿõ"), 2, WordClass::Noun }, // ñ³ì'~ÿõ

			{ std::wstring(      L"åø"), 2 }, // áåð~åø áàìêí~åø
			{ std::wstring(    L"èìåø"), 3 }, // áðåñòè~ìåø
			{ std::wstring(  L"àòèìåø"), 5 }, // áðà~òèìåø íàçèâà~òèìåø
			{ std::wstring(  L"èòèìåø"), 5 }, // áåç÷åñòè~òèìåø áè~òèìåø
			{ std::wstring(  L"³òèìåø"), 5 }, // áóðêîò³~òèìåø
			//{ std::wstring(  L"¿òèìåø"), 5 }, // ãíî¿~òèìåø
			{ std::wstring( L"î¿òèìåø"), 6 }, // ãíî~¿òèìåø
			{ std::wstring(  L"îòèìåø"), 5 }, // áîðî~òèìåø
			{ std::wstring(  L"óòèìåø"), 5 }, // áëÿêíó~òèìåø
			//{ std::wstring(L"èâàòèìåø"), 7 }, // no words with such suffix
			{ std::wstring(L"óâàòèìåø"), 7 }, // àêòóàë³çó~âàòèìåø ³ñíó~âàòèìåø
			{ std::wstring(L"þâàòèìåø"), 7 }, // áàçàðþ~âàòèìåø (soft U)
			{ std::wstring(     L"àºø"), 2 }, // à~ºø ìà~ºø
			{ std::wstring(     L"³ºø"), 2 }, // áóð³~ºø
			{ std::wstring(     L"óºø"), 2 }, // ³ñíó~ºø
			{ std::wstring(     L"þºø"), 2 }, // äîð³âíþ~ºø
			{ std::wstring(     L"'ºø"), 2 }, // á'~ºø
			{ std::wstring(      L"èø"), 1 }, // áóðêîò~èø
			{ std::wstring(      L"³ø"), 2, WordClass::Adverb }, // àçàðòí~³ø
			//{ std::wstring(      L"¿ø"), 1 }, // áëàãîóñòðî¿~ø
			{ std::wstring(     L"î¿ø"), 2 }, // áëàãîóñòðî~¿ø

			{ std::wstring(      L"àëàñü"), 4 }, // íàçèâà~ëàñü
			{ std::wstring(    L"óâàëàñü"), 6 }, // àêòóàë³çó~âàëàñü
			{ std::wstring(    L"þâàëàñü"), 6 }, // àí³ã³ëþ~âàëàñü
			{ std::wstring(      L"èëàñü"), 4 }, // áðèæè~ëàñü áè~ëàñü
			//{ std::wstring(      L"¿ëàñü"), 4 }, // áëàãîóñòðî¿~ëàñü
			{ std::wstring(     L"î¿ëàñü"), 5 }, // áëàãîóñòðî~¿ëàñü
			{ std::wstring(      L"îëàñü"), 4 }, // áîðî~ëàñü
			{ std::wstring(      L"óëàñü"), 4 }, // áåõíó~ëºìîñÿàñü
			{ std::wstring(     L"îÿëàñü"), 5 }, // áî~ÿëàñü
			{ std::wstring(       L"àâñü"), 3 }, // íàçèâà~âñü
			{ std::wstring(     L"óâàâñü"), 5 }, // àêòóàë³çó~âàâñü
			{ std::wstring(     L"þâàâñü"), 5 }, // àí³ã³ëþ~âàâñü
			{ std::wstring(       L"èâñü"), 3 }, // áåç÷åñòè~âñü áè~âñü
			//{ std::wstring(       L"¿âñü"), 3 }, // áëàãîóñòðî¿~âñü
			{ std::wstring(      L"î¿âñü"), 4 }, // áëàãîóñòðî~¿âñü
			{ std::wstring(       L"îâñü"), 3 }, // áîðî~âñü
			{ std::wstring(       L"óâñü"), 3 }, // áåõíó~âñü
			{ std::wstring(       L"ÿâñü"), 4 }, // áî~ÿâñü
			// { std::wstring(        L"åñü"), 2 }, // no words
			{ std::wstring(   L"òèìåòåñü"), 8 }, // áåðåã~òèìåòåñü
			{ std::wstring(  L"àòèìåòåñü"), 8 }, // íàçèâà~òèìåòåñü
			//{ std::wstring(  L"¿òèìåòåñü"), 7 }, // ãíî¿~òèìåòåñü
			{ std::wstring( L"î¿òèìåòåñü"), 9 }, // ãíî~¿òèìåòåñü
			{ std::wstring(  L"îòèìåòåñü"), 8 }, // áîðî~òèìåòåñü
			{ std::wstring(L"óâàòèìåòåñü"), 10 }, // àêòóàë³çó~âàòèìåòåñü
			{ std::wstring(L"þâàòèìåòåñü"), 10 }, // àí³ã³ëþ~âàòèìåòåñü
			{ std::wstring(  L"èòèìåòåñü"), 8 }, // áðèæè~òèìåòåñü áè~òèìåòåñü
			{ std::wstring(  L"ÿòèìåòåñü"), 9 }, // áî~ÿòèìåòåñü
			{ std::wstring(      L"åòåñü"), 4 }, // áåðå~òåñü
			{ std::wstring(      L"ºòåñü"), 5 }, // á'~ºòåñü
			{ std::wstring(     L"óºòåñü"), 5 }, // àêòóàë³çó~ºòåñü
			{ std::wstring(      L"èòåñü"), 4 }, // áåç÷åñòè~òåñü
			{ std::wstring(      L"³òåñü"), 4 }, // áåð³~òåñü áðèæ³~òåñü äèâ³~òåñü
			//{ std::wstring(      L"¿òåñü"), 4 }, // áëàãîóñòðî¿~òåñü
			{ std::wstring(     L"î¿òåñü"), 5 }, // áëàãîóñòðî~¿òåñü áî~¿òåñü
			{ std::wstring(     L"àéòåñü"), 5 }, // íàçèâà~éòåñü
			{ std::wstring(     L"èéòåñü"), 5 }, // áè~éòåñü
			{ std::wstring(     L"³éòåñü"), 5 }, // á³~éòåñü
			{ std::wstring(     L"îéòåñü"), 5 }, // áëàãîóñòðî~éòåñü
			{ std::wstring(     L"óéòåñü"), 5 }, // àêòóàë³çó~éòåñü
			{ std::wstring(     L"þéòåñü"), 5 }, // àí³ã³ëþ~éòåñü
			{ std::wstring(     L"àºòåñü"), 5 }, // à~ºòåñü íàçèâà~ºòåñü
			{ std::wstring(     L"þºòåñü"), 5 }, // àí³ã³ëþ~ºòåñü
			{ std::wstring(      L"üòåñü"), 4 }, // áàãðÿíü~òåñü
			{ std::wstring(        L"èñü"), 2, WordClass::Verb }, // áåðè~ñü
			{ std::wstring(        L"èñü"), 2, WordClass::VerbalAdverb }, // áåð³ãøè~ñü
			{ std::wstring(      L"àëèñü"), 4 }, // íàçèâà~ëèñü
			{ std::wstring(    L"þâàëèñü"), 6 }, // àí³ã³ëþ~âàëèñü
			{ std::wstring(      L"èëèñü"), 4 }, // áðèæè~ëèñü áè~ëèñü
			//{ std::wstring(      L"¿ëèñü"), 4 }, // áëàãîóñòðî¿~ëèñü
			{ std::wstring(     L"î¿ëèñü"), 5 }, // áëàãîóñòðî~¿ëèñü
			{ std::wstring(      L"îëèñü"), 4 }, // áîðî~ëèñü
			{ std::wstring(      L"óëèñü"), 4 }, // áåõíó~ëèñü
			{ std::wstring(    L"óâàëèñü"), 6 }, // àêòóàë³çó~âàëèñü
			{ std::wstring(      L"ÿëèñü"), 5 }, // áî~ÿëèñü
			{ std::wstring(      L"àòèñü"), 4 }, // áðà~òèñü
			{ std::wstring(    L"óâàòèñü"), 6 }, // àêòóàë³çó~âàòèñü
			{ std::wstring(    L"þâàòèñü"), 6 }, // àí³ã³ëþ~âàòèñü
			{ std::wstring(      L"èòèñü"), 4 }, // áðèæè~òèñü áè~òèñü
			//{ std::wstring(      L"¿òèñü"), 4 }, // áëàãîóñòðî¿~òèñü
			{ std::wstring(     L"î¿òèñü"), 5 }, // áëàãîóñòðî~¿òèñü
			{ std::wstring(      L"îòèñü"), 4 }, // áîðî~òèñü
			{ std::wstring(      L"óòèñü"), 4 }, // áåõíó~òèñü
			{ std::wstring(      L"ÿòèñü"), 5 }, // áî~ÿòèñü
			{ std::wstring(      L"à÷èñü"), 4, WordClass::VerbalAdverb }, // áðèæà~÷èñü âàíòàæà~÷èñü
			{ std::wstring(      L"ó÷èñü"), 4, WordClass::VerbalAdverb }, // áåðó~÷èñü
			{ std::wstring(      L"þ÷èñü"), 5, WordClass::VerbalAdverb }, // compound
			//{ std::wstring(     L"àþ÷èñü"), 5, WordClass::VerbalAdverb }, // íàìàãà~þ÷èñü
			//{ std::wstring(     L"óþ÷èñü"), 5, WordClass::VerbalAdverb }, // äèâó~þ÷èñü
			//{ std::wstring(     L"þþ÷èñü"), 5, WordClass::VerbalAdverb }, // àí³ã³ëþ~þ÷èñü
			//{ std::wstring(      L"þ÷èñü"), 5, WordClass::VerbalAdverb }, // áîðþ~÷èñü
			//{ std::wstring(     L"'þ÷èñü"), 5, WordClass::VerbalAdverb }, // á'~þ÷èñü
			{ std::wstring(      L"ÿ÷èñü"), 5, WordClass::VerbalAdverb }, // áî~ÿ÷èñü ãíî~ÿ÷èñü äèâë~ÿ÷èñü áóä~ÿ÷èñü
			{ std::wstring(     L"îÿ÷èñü"), 5, WordClass::VerbalAdverb }, // ãíî~ÿ÷èñü áî~ÿ÷èñü

			{ std::wstring(     L"àâøèñü"), 5, WordClass::VerbalAdverb }, // íàçèâà~âøèñü áðà~âøèñü
			{ std::wstring(     L"îâøèñü"), 5, WordClass::VerbalAdverb }, // áîðî~âøèñü
			{ std::wstring(   L"þâàâøèñü"), 7, WordClass::VerbalAdverb }, // àí³ã³ëþ~âàâøèñü àñîö³þ~âàâøèñü
			{ std::wstring(   L"óâàâøèñü"), 7, WordClass::VerbalAdverb }, // àêòóàë³çó~âàâøèñü
			{ std::wstring(     L"èâøèñü"), 5, WordClass::VerbalAdverb }, // áðèæè~âøèñü áè~âøèñü
			//{ std::wstring(     L"¿âøèñü"), 5, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøèñü
			{ std::wstring(    L"î¿âøèñü"), 6, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøèñü
			{ std::wstring(     L"óâøèñü"), 5, WordClass::VerbalAdverb }, // áåõíó~âøèñü çâåðíó~âøèñü
			{ std::wstring(     L"ÿâøèñü"), 5, WordClass::VerbalAdverb }, // âçÿ~âøèñü
			{ std::wstring(    L"îÿâøèñü"), 6, WordClass::VerbalAdverb }, // áî~ÿâøèñü
			{ std::wstring(       L"àéñü"), 3 }, // çíà~éñü íàçèâà~éñü
			{ std::wstring(       L"èéñü"), 3 }, // á³~éñü áè~éñü
			{ std::wstring(       L"³éñü"), 3 }, // á³~éñü
			{ std::wstring(       L"îéñü"), 3 }, // áëàãîóñòðî~éñü
			{ std::wstring(       L"óéñü"), 3 }, // àêòóàë³çó~éñü
			{ std::wstring(       L"þéñü"), 3 }, // àí³ã³ëþ~éñü
			//{ std::wstring(        L"îñü"), 2 }, // no actual words (all are LOS or MOS) êîãî~ñü ??
			{ std::wstring(      L"àëîñü"), 5 }, // áðà~ëîñü íàçèâà~ëîñü ñòà~ëîñü
			{ std::wstring(    L"þâàëîñü"), 6 }, // àí³ã³ëþ~âàëîñü
			{ std::wstring(      L"èëîñü"), 4 }, // áðèæè~ëîñü áè~ëîñü
			//{ std::wstring(      L"¿ëîñü"), 4 }, // áëàãîóñòðî¿~ëîñü
			{ std::wstring(     L"î¿ëîñü"), 5 }, // áëàãîóñòðî~¿ëîñü
			{ std::wstring(      L"îëîñü"), 4 }, // áîðî~ëîñü
			{ std::wstring(      L"óëîñü"), 4 }, // áåõíó-ëîñü
			{ std::wstring(    L"óâàëîñü"), 6 }, // àêòóàë³çó~âàëîñü
			{ std::wstring(      L"ÿëîñü"), 5 }, // áî~ÿëîñü
			// { std::wstring(       L"ìîñü"), 4 }, // 
			{ std::wstring(      L"åìîñü"), 4 }, // áåðåæå~ìîñü áåðå~ìîñü
			{ std::wstring(    L"èìåìîñü"), 6 }, // áåðåãòè~ìåìîñü (we can't split áåðåã*òèìåìîñü)
			{ std::wstring(  L"àòèìåìîñü"), 8 }, // áðà~òèìåìîñü íàçè~âà~òèìåìîñü
			{ std::wstring(  L"èòèìåìîñü"), 8 }, // áðèæè~òèìåìîñü áè~òèìåìîñü
			//{ std::wstring(  L"¿òèìåìîñü"), 8 }, // ãíî¿~òèìåìîñü
			{ std::wstring(  L"î¿òèìåìîñü"), 9 }, // ãíî~¿òèìåìîñü
			{ std::wstring(  L"îòèìåìîñü"), 8 }, // áîðî~òèìåìîñü
			{ std::wstring(L"óâàòèìåìîñü"), 10 }, // àêòóàë³çó~âàòèìåìîñü
			{ std::wstring(L"þâàòèìåìîñü"), 10 }, // àí³ã³ëþ~âàòèìåìîñü
			{ std::wstring(  L"ÿòèìåìîñü"), 9 }, // áî~ÿòèìåìîñü
			{ std::wstring(      L"ºìîñü"), 5 }, // á'~ºìîñü
			//{ std::wstring(     L"àºìîñü"), 5 }, // ñïîä³âà~ºìîñü
			//{ std::wstring(     L"èºìîñü"), 5 }, // ïîøè~ºìîñü
			//{ std::wstring(     L"³ºìîñü"), 5 }, // íàä³~ºìîñü
			//{ std::wstring(     L"îºìîñü"), 5 }, // ïîáîþ~ºìîñü
			//{ std::wstring(     L"óºìîñü"), 5 }, // êîðèñòó~ºìîñü àêòóàë³çó~ºìîñü
			//{ std::wstring(     L"þºìîñü"), 5 }, // âèñëîâëþ~ºìîñü àí³ã³ëþ~ºìîñü
			//{ std::wstring(     L"ÿºìîñü"), 5 }, // ñïèíÿ~ºìîñü
			//{ std::wstring(     L"'ºìîñü"), 5 }, // â³ä³á'~ºìîñü á'~ºìîñü
			{ std::wstring(      L"èìîñü"), 4 }, // áåç÷åñòè~ìîñü
			//{ std::wstring(      L"¿ìîñü"), 4 }, // áî¿~ìîñü áëàãîóñòðî¿~ìîñü
			{ std::wstring(      L"³ìîñü"), 4 }, // áåðåæ³~ìîñü áåð³~ìîñü äèâ³~ìîñü
			{ std::wstring(      L"¿ìîñü"), 5 }, // compound
			//{ std::wstring(     L"è¿ìîñü"), 5 }, // ÷è~¿ìîñü
			//{ std::wstring(     L"î¿ìîñü"), 5 }, // áî~¿ìîñü áëàãîóñòðî~¿ìîñü
			{ std::wstring(      L"éìîñü"), 5 }, // compound
			//{ std::wstring(     L"àéìîñü"), 5 }, // íàçèâà~éìîñü
			//{ std::wstring(     L"èéìîñü"), 5 }, // áè~éìîñü
			//{ std::wstring(     L"³éìîñü"), 5 }, // á³~éìîñü
			//{ std::wstring(     L"îéìîñü"), 5 }, // áëàãîóñòðî~éìîñü
			//{ std::wstring(     L"óéìîñü"), 5 }, // àêòóàë³çó~éìîñü
			//{ std::wstring(     L"þéìîñü"), 5 }, // àí³ã³ëþ~éìîñü
			{ std::wstring(      L"üìîñü"), 4 }, // áåç÷åñòü~ìîñü
			{ std::wstring(        L"óñü"), 2 }, // áåðó~ñü áåç÷åùó~ñü
			{ std::wstring(      L"èìóñü"), 4 }, // áåðåãòè~ìóñü
			{ std::wstring(    L"àòèìóñü"), 6 }, // íàçèâà~òèìóñü
			{ std::wstring(    L"¿òèìóñü"), 7 }, // compound
			//{ std::wstring(   L"î¿òèìóñü"), 7 }, // ãíî~¿òèìóñü
			{ std::wstring(    L"îòèìóñü"), 6 }, // áîðî~òèìóñü
			{ std::wstring(  L"óâàòèìóñü"), 8 }, // àêòóàë³çó~âàòèìóñü
			{ std::wstring(  L"þâàòèìóñü"), 8 }, // àí³ã³ëþ~âàòèìóñü
			{ std::wstring(    L"èòèìóñü"), 6 }, // áðèæè~òèìóñü áè~òèìóñü
			{ std::wstring(    L"ÿòèìóñü"), 7 }, // áî~ÿòèìóñü

			{ std::wstring(        L"þñü"), 3 }, // äèâë~þñü àðêàí~þñü æóð~þñü
			{ std::wstring(       L"àþñü"), 3 }, // íàçèâà~þñü
			{ std::wstring(       L"³þñü"), 3 }, // ðîçóì³~þñü
			{ std::wstring(       L"èþñü"), 3 }, // ÷è~þñü
			{ std::wstring(       L"îþñü"), 3 }, // áî~þñü(?or zero) áëàãîóñòðî~þñü ERROR: ãíî~þñü (need to keep letter 'o')
			{ std::wstring(       L"óþñü"), 3 }, // àêòóàë³çó~þñü
			{ std::wstring(       L"ºþñü"), 4 }, // ÷è~ºþñü
			{ std::wstring(       L"þþñü"), 3 }, // àí³ã³ëþ~þñü õâèëþ~þñü
			{ std::wstring(       L"ÿþñü"), 3 }, // ïîìèëÿ~þñü
			{ std::wstring(       L"'þñü"), 3 }, // á'~þñü

			{ std::wstring(       L"àòü"), 2 }, // áðà~òü áóðëà÷à~òü
			{ std::wstring(     L"óâàòü"), 4 }, // ³ñíó~âàòü
			{ std::wstring(     L"þâàòü"), 4 }, // äîð³âíþ~âàòü
			{ std::wstring(       L"èòü"), 2 }, // áåç÷åñòè~òü áè~òü
			{ std::wstring(       L"³òü"), 3 }, // áåð~³òü áóðêîò~³òü áàìêí~³òü
			//{ std::wstring(       L"¿òü"), 3 }, // áëàãîóñòðî¿~òü
			{ std::wstring(      L"î¿òü"), 3 }, // áëàãîóñòðî~¿òü
			{ std::wstring(       L"îòü"), 3 }, // áîð~îòü ïîë~îòü êîë~îòü ê³ã~îòü
			{ std::wstring(       L"óòü"), 3 }, // áåð~óòü áàìêí~óòü
			{ std::wstring(     L"èìóòü"), 4 }, // áðåñòè~ìóòü
			{ std::wstring(   L"àòèìóòü"), 6 }, // à~òèìóòü ³ñíóâà~òèìóòü
			{ std::wstring(   L"èòèìóòü"), 6 }, // æè~òèìóòü áè~òèìóòü
			{ std::wstring(   L"³òèìóòü"), 6 }, // áóðêîò³~òèìóòü
			//{ std::wstring(   L"¿òèìóòü"), 6 }, // ãíî¿~òèìóòü
			{ std::wstring(  L"î¿òèìóòü"), 7 }, // ãíî~¿òèìóòü
			{ std::wstring(   L"îòèìóòü"), 6 }, // áîðî~òèìóòü
			{ std::wstring(   L"óòèìóòü"), 6 }, // áëÿêíó~òèìóòü
			{ std::wstring( L"óâàòèìóòü"), 8 }, // àêòóàë³çó~âàòèìóòü
			{ std::wstring( L"þâàòèìóòü"), 8 }, // äîð³âíþ~âàòèìóòü
			{ std::wstring(       L"þòü"), 3 }, // áîð~þòü
			{ std::wstring(      L"àþòü"), 3 }, // ââàæà~þòü âïëèâà~þòü
			{ std::wstring(      L"³þòü"), 3 }, // áóð³~þòü
			{ std::wstring(      L"óþòü"), 3 }, // ³ñíó~þòü
			{ std::wstring(      L"þþòü"), 3 }, // äîð³âíþ~þòü
			{ std::wstring(      L"'þòü"), 3 }, // äîð³âíþ~þòü á'~þòü
			{ std::wstring(       L"ÿòü"), 3 }, // áóðêîò~ÿòü ãíî~ÿòü
			{ std::wstring(      L"îÿòü"), 3 }, // áëàãîóñòðî~ÿòü

			{ std::wstring( L"þ"), 1 }, // àðêàí~þ
			{ std::wstring( L"þ"), 1 , WordClass::Noun}, // áåççì³íí³ñò~þ
			{ std::wstring(L"àþ"), 1 }, // íàçèâà~þ
			{ std::wstring(L"ºþ"), 2, WordClass::Noun }, // ñ³ì'~ºþ
			{ std::wstring(L"³þ"), 1 }, // áóð³~þ
			{ std::wstring(L"îþ"), 1 }, // ãíî~þ
			{ std::wstring(L"îþ"), 2, WordClass::Noun }, // áëàãîóñòð~îþ çì³í~îþ
			{ std::wstring(L"îþ"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îþ
			{ std::wstring(L"óþ"), 1 }, // ³ñíó~þ àêòóàë³çó~þ
			{ std::wstring(L"þþ"), 1 }, // äîð³íþ~þ
			{ std::wstring(L"'þ"), 1, WordClass::Noun }, // ñ³ì'~þ

			{ std::wstring(          L"ÿ"), 1, WordClass::Adjective }, // äîðîæí~ÿ
			{ std::wstring(          L"ÿ"), 1, WordClass::Noun }, // îáñëóãîâóâàíí~ÿ
			{ std::wstring(         L"àÿ"), 2, WordClass::Adjective }, // áåçïîñàäêîâ~àÿ áëèçüê~àÿ adj
			{ std::wstring(         L"ÿÿ"), 2, WordClass::Adjective }, // àâòîäîðîæí~ÿÿ
			{ std::wstring(         L"'ÿ"), 1, WordClass::Noun }, // ñ³ì'~ÿ
			// { std::wstring(         L"ñÿ"), 2 }, // can't detach unvoiced 'Sya'
			//{ std::wstring(        L"àñÿ"), 2 }, // no words
			{ std::wstring(       L"ëàñÿ"), 4 }, // áåðåã~ëàñÿ
			{ std::wstring(      L"àëàñÿ"), 4 }, // íàçèâà~ëàñÿ
			{ std::wstring(      L"îëàñÿ"), 4 }, // áîðî~ëàñÿ
			{ std::wstring(    L"óâàëàñÿ"), 6 }, // àêòóàë³çó~âàëàñÿ
			{ std::wstring(    L"þâàëàñÿ"), 6 }, // àí³ã³ëþ~âàëàñÿ
			{ std::wstring(      L"èëàñÿ"), 4 }, // áðèæè~ëàñÿ áè~ëàñÿ
			//{ std::wstring(      L"¿ëàñÿ"), 4 }, // áëàãîóñòðî¿~ëàñÿ
			{ std::wstring(     L"î¿ëàñÿ"), 5 }, // áëàãîóñòðî~¿ëàñÿ
			{ std::wstring(      L"óëàñÿ"), 4 }, // áåõíó~ëàñÿ
			{ std::wstring(      L"ÿëàñÿ"), 5 }, // áî~ÿëàñÿ
			{ std::wstring(       L"àâñÿ"), 3 }, // íàçèâà~âñÿ áðà~âñÿ
			{ std::wstring(     L"óâàâñÿ"), 5 }, // àêòóàë³çó~âàâñÿ
			{ std::wstring(     L"þâàâñÿ"), 5 }, // àí³ã³ëþ~âàâñÿ
			{ std::wstring(       L"èâñÿ"), 3 }, // áðèæè~âñÿ áè~âñÿ
			//{ std::wstring(       L"¿âñÿ"), 3 }, // áëàãîóñòðî¿~âñÿ
			{ std::wstring(      L"î¿âñÿ"), 4 }, // áëàãîóñòðî~¿âñÿ
			{ std::wstring(       L"îâñÿ"), 3 }, // áîðî~âñÿ
			{ std::wstring(       L"óâñÿ"), 3 }, // áåõíó~âñÿ
			{ std::wstring(       L"ÿâñÿ"), 3 }, // áîÿ~âñÿ
			//{ std::wstring(       L"³ãñÿ"), 3 }, // áåð³ãñ~ÿ (áåð is too common)
			{ std::wstring(      L"åòåñÿ"), 4 }, // áåðå~òåñÿ áåðåæå~òåñÿ
			{ std::wstring(    L"èìåòåñÿ"), 6 }, // áåðåãòè~ìåòåñÿ
			{ std::wstring(  L"àòèìåòåñÿ"), 8 }, // íàçèâà~òèìåòåñÿ
			{ std::wstring(L"óâàòèìåòåñÿ"), 10 }, // àêòóàë³çó~âàòèìåòåñÿ
			{ std::wstring(L"þâàòèìåòåñÿ"), 10 }, // àí³ã³ëþ~âàòèìåòåñÿ
			{ std::wstring(  L"èòèìåòåñÿ"), 8 }, // áðèæè~òèìåòåñÿ áè~òèìåòåñÿ
			//{ std::wstring(  L"¿òèìåòåñÿ"), 8 }, // ãíî¿~òèìåòåñÿ
			{ std::wstring( L"î¿òèìåòåñÿ"), 9 }, // ãíî~¿òèìåòåñÿ
			{ std::wstring(  L"îòèìåòåñÿ"), 8 }, // áîðî~òèìåòåñÿ
			{ std::wstring(  L"ÿòèìåòåñÿ"), 9 }, // áî~ÿòèìåòåñÿ
			{ std::wstring(      L"ºòåñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºòåñÿ"), 5 }, // çàáèðà~ºòåñÿ íàçèâà~ºòåñÿ
			//{ std::wstring(     L"èºòåñÿ"), 5 }, // âøè~ºòåñÿ
			//{ std::wstring(     L"³ºòåñÿ"), 5 }, // ðîçóì³~ºòåñÿ
			//{ std::wstring(     L"óºòåñÿ"), 5 }, // àêòóàë³çó~ºòåñÿ
			//{ std::wstring(     L"þºòåñÿ"), 5 }, // àí³ã³ëþ~ºòåñÿ
			//{ std::wstring(     L"ÿºòåñÿ"), 5 }, // ïîìèëÿ~ºòåñÿ
			//{ std::wstring(     L"'ºòåñÿ"), 5 }, // á'~ºòåñÿ
			{ std::wstring(      L"èòåñÿ"), 4 }, // áðèæè~òåñÿ
			{ std::wstring(      L"³òåñÿ"), 4 }, // áåð³~òåñÿ äèâ³~òåñÿ
			//{ std::wstring(      L"¿òåñÿ"), 4 }, // áî¿~òåñÿ áëàãîóñòðî¿~òåñÿ
			{ std::wstring(     L"î¿òåñÿ"), 5 }, // áî~¿òåñÿ áëàãîóñòðî~¿òåñÿ
			{ std::wstring(      L"éòåñÿ"), 5 }, // compound
			//{ std::wstring(     L"àéòåñÿ"), 5 }, // íàçèâà~éòåñÿ
			//{ std::wstring(     L"èéòåñÿ"), 5 }, // áè~éòåñÿ
			//{ std::wstring(     L"³éòåñÿ"), 5 }, // á³~éòåñÿ
			//{ std::wstring(     L"îéòåñÿ"), 5 }, // áëàãîóñòðî~éòåñÿ
			//{ std::wstring(     L"óéòåñÿ"), 5 }, // àêòóàë³çó~éòåñÿ
			//{ std::wstring(     L"þéòåñÿ"), 5 }, // àí³ã³ëþ~éòåñÿ
			{ std::wstring(      L"üòåñÿ"), 4 }, // àðêàíü~òåñÿ
			{ std::wstring(        L"èñÿ"), 3, WordClass::Verb }, // áåðè~ñÿ äèâè~ñÿ áåðåæ~èñÿ
			{ std::wstring(        L"èñÿ"), 3, WordClass::VerbalAdverb }, // áåð³ãø~èñÿ
			{ std::wstring(      L"àëèñÿ"), 4 }, // íàçèâà~ëèñÿ
			{ std::wstring(    L"óâàëèñÿ"), 6 }, // àêòóàë³çó~âàëèñÿ
			{ std::wstring(    L"þâàëèñÿ"), 6 }, // àí³ã³ëþ~âàëèñÿ
			{ std::wstring(      L"èëèñÿ"), 4 }, // áðèæè~ëèñÿ áè~ëèñÿ
			//{ std::wstring(      L"¿ëèñÿ"), 4 }, // áëàãîóñòðî¿~ëèñÿ
			{ std::wstring(     L"î¿ëèñÿ"), 5 }, // áëàãîóñòðî~¿ëèñÿ
			{ std::wstring(      L"îëèñÿ"), 5 }, // áîðî~ëèñÿ
			{ std::wstring(      L"óëèñÿ"), 5 }, // áåõíó~ëèñÿ
			{ std::wstring(      L"ÿëèñÿ"), 5 }, // áîÿ~ëèñÿ
			{ std::wstring(      L"àòèñÿ"), 4 }, // íàçèâà~òèñÿ
			{ std::wstring(    L"óâàòèñÿ"), 6 }, // àêòóàë³çó~âàòèñÿ
			{ std::wstring(    L"þâàòèñÿ"), 6 }, // àí³ã³ëþ~âàòèñÿ
			{ std::wstring(      L"èòèñÿ"), 4 }, // áðèæè~òèñÿ áè~òèñÿ
			{ std::wstring(      L"îòèñÿ"), 4 }, // áîðî~òèñÿ
			//{ std::wstring(      L"¿òèñÿ"), 4 }, // áëàãîóñòðî¿~òèñÿ
			{ std::wstring(     L"î¿òèñÿ"), 5 }, // áëàãîóñòðî~¿òèñÿ
			{ std::wstring(      L"óòèñÿ"), 4 }, // áåõíó~òèñÿ
			{ std::wstring(      L"ÿòèñÿ"), 4 }, // áî~ÿòèñÿ
			{ std::wstring(     L"àâøèñÿ"), 5, WordClass::VerbalAdverb }, // íàçèâà~âøèñÿ áðà~âøèñÿ
			{ std::wstring(     L"îâøèñÿ"), 5, WordClass::VerbalAdverb }, // áîðî~âøèñÿ
			{ std::wstring(   L"óâàâøèñÿ"), 7, WordClass::VerbalAdverb }, // àêòóàë³çó~âàâøèñÿ
			{ std::wstring(   L"þâàâøèñÿ"), 7, WordClass::VerbalAdverb }, // àí³ã³ëþ~âàâøèñÿ àñîö³þ~âàâøèñÿ
			{ std::wstring(     L"èâøèñÿ"), 5, WordClass::VerbalAdverb }, // áåç÷åñòè~âøèñÿ áè~âøèñÿ
			//{ std::wstring(     L"¿âøèñÿ"), 5, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøèñÿ
			{ std::wstring(    L"î¿âøèñÿ"), 6, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøèñÿ
			{ std::wstring(     L"óâøèñÿ"), 5, WordClass::VerbalAdverb }, // áîâòíó~âøèñÿ çâåðíó~âøèñÿ

			{ std::wstring(        L"éñÿ"), 3, WordClass::Participle }, // compound
			//{ std::wstring(       L"àéñÿ"), 3, WordClass::Participle }, // àéñÿ íàçèâà~éñÿ
			//{ std::wstring(       L"èéñÿ"), 3, WordClass::Participle }, // áåð³ãøè~éñÿ áè~éñÿ
			//{ std::wstring(       L"³éñÿ"), 3, WordClass::Participle }, // á³~éñÿ
			//{ std::wstring(       L"îéñÿ"), 3, WordClass::Participle }, // áëàãîóñòðî~éñÿ
			//{ std::wstring(       L"óéñÿ"), 3, WordClass::Participle }, // àêòóàë³çó~éñÿ
			//{ std::wstring(       L"þéñÿ"), 3, WordClass::Participle }, // àí³ã³ëþ~éñÿ
			{ std::wstring(    L"àâøèéñÿ"), 6, WordClass::Participle }, // áðà~âøèéñÿ
			{ std::wstring(  L"óâàâøèéñÿ"), 8, WordClass::Participle }, // àêóòàë³çó~âàâøèéñÿ
			{ std::wstring(  L"þâàâøèéñÿ"), 8, WordClass::Participle }, // àí³ã³ëþ~âàâøèéñÿ àñîö³þ~âàâøèéñÿ
			{ std::wstring(    L"èâøèéñÿ"), 6, WordClass::Participle }, // áðèæè~âøèéñÿ áè~âøèéñÿ
			//{ std::wstring(    L"¿âøèéñÿ"), 6 }, // áëàãîóñòðî¿~âøèéñÿ
			{ std::wstring(   L"î¿âøèéñÿ"), 7, WordClass::Participle  }, // áëàãîóñòðî~¿âøèéñÿ
			{ std::wstring(    L"îâøèéñÿ"), 6, WordClass::Participle }, // áîðî~âøèéñÿ
			{ std::wstring(    L"óâøèéñÿ"), 6, WordClass::Participle }, // áåõíó~âøèéñÿ
			{ std::wstring(    L"ÿâøèéñÿ"), 7, WordClass::Participle  }, // áî~ÿâøèéñÿ
			{ std::wstring(       L"åìñÿ"), 3 }, // áåðå~ìñÿ áåðåæå~ìñÿ çâåðíå~ìñÿ
			{ std::wstring(     L"èìåìñÿ"), 5 }, // áåðåãòè~ìåìñÿ
			{ std::wstring(       L"ºìñÿ"), 4 }, // compound
			//{ std::wstring(      L"àºìñÿ"), 4 }, // íàçèâà~ºìñÿ
			//{ std::wstring(      L"óºìñÿ"), 4 }, // àêòóàë³çó~ºìñÿ
			//{ std::wstring(      L"þºìñÿ"), 4 }, // àí³ã³ëþ~ºìñÿ
			//{ std::wstring(      L"'ºìñÿ"), 4 }, // á'~ºìñÿ
			{ std::wstring(   L"àòèìåìñÿ"), 7 }, // áðà~òèìåìñÿ
			{ std::wstring(   L"èòèìåìñÿ"), 7 }, // áðèæè~òèìåìñÿ áè~òèìåìñÿ
			//{ std::wstring(   L"¿òèìåìñÿ"), 7 }, // ãíî¿~òèìåìñÿ
			{ std::wstring(  L"î¿òèìåìñÿ"), 8 }, // ãíî~¿òèìåìñÿ
			{ std::wstring(   L"îòèìåìñÿ"), 7 }, // áîðî~òèìåìñÿ
			{ std::wstring( L"óâàòèìåìñÿ"), 9 }, // àêòóàë³çó~âàòèìåìñÿ
			{ std::wstring( L"þâàòèìåìñÿ"), 9 }, // àí³ã³ëþ~âàòèìåìñÿ
			{ std::wstring(   L"ÿòèìåìñÿ"), 8 }, // áî~ÿòèìåìñÿ
			{ std::wstring(       L"èìñÿ"), 3 }, // áðèæè~ìñÿ
			//{ std::wstring(       L"¿ìñÿ"), 3 }, // áëàãîóñòðî¿~ìñÿ
			{ std::wstring(      L"î¿ìñÿ"), 4 }, // áëàãîóñòðî~¿ìñÿ
			//{ std::wstring(        L"îñÿ"), 2 }, // no words á³éìî~ñÿ
			{ std::wstring(       L"ëîñÿ"), 4 }, // áåðåã~ëîñÿ
			{ std::wstring(      L"àëîñÿ"), 4 }, // íàçèâà~ëîñÿ
			{ std::wstring(    L"óâàëîñÿ"), 6 }, // àêòóàë³çó~âàëîñÿ
			{ std::wstring(    L"þâàëîñÿ"), 6 }, // àí³ã³ëþ~âàëîñÿ
			{ std::wstring(      L"åëîñÿ"), 4 }, // äîâå~ëîñÿ
			{ std::wstring(      L"èëîñÿ"), 4 }, // áðèæè~ëîñÿ áè~ëîñÿ
			//{ std::wstring(      L"¿ëîñÿ"), 4 }, // áëàãîóñòðî¿~ëîñÿ
			{ std::wstring(     L"î¿ëîñÿ"), 5 }, // áëàãîóñòðî~¿ëîñÿ
			{ std::wstring(      L"îëîñÿ"), 4 }, // áîðî~ëîñÿ
			{ std::wstring(      L"óëîñÿ"), 4 }, // áåõíó~ëîñÿ
			{ std::wstring(      L"ÿëîñÿ"), 5 }, // áî~ÿëîñÿ
			{ std::wstring(       L"ìîñÿ"), 4 }, // typo:ïîêâàï~ìîñÿ
			{ std::wstring(      L"àìîñÿ"), 4 }, // ïîäà~ìîñÿ
			{ std::wstring(      L"åìîñÿ"), 4 }, // áåðå~ìîñÿ ïîâåðíå~ìîñÿ
			{ std::wstring(    L"èìåìîñÿ"), 6 }, // áåðåãòè~ìåìîñÿ
			{ std::wstring(  L"àòèìåìîñÿ"), 8 }, // íàçèâà~òèìåìîñÿ
			{ std::wstring(L"óâàòèìåìîñÿ"), 10 }, // àêòóàë³çó~âàòèìåìîñÿ
			{ std::wstring(L"þâàòèìåìîñÿ"), 10 }, // àí³ã³ëþ~âàòèìåìîñÿ
			{ std::wstring(  L"èòèìåìîñÿ"), 8 }, // áðèæè~òèìåìîñÿ áè~òèìåìîñÿ
			//{ std::wstring(  L"¿òèìåìîñÿ"), 8 }, // ãíî¿~òèìåìîñÿ
			{ std::wstring( L"î¿òèìåìîñÿ"), 9 }, // ãíî~¿òèìåìîñÿ
			{ std::wstring(  L"îòèìåìîñÿ"), 8 }, // áîðî~òèìåìîñÿ
			{ std::wstring(  L"ÿòèìåìîñÿ"), 8 }, // áîÿ~òèìåìîñÿ
			{ std::wstring(      L"ºìîñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºìîñÿ"), 5 }, // ä³çíà~ºìîñÿ íàçèâà~ºìîñÿ
			//{ std::wstring(     L"óºìîñÿ"), 5 }, // àêòóàë³çó~ºìîñÿ
			//{ std::wstring(     L"þºìîñÿ"), 5 }, // àí³ã³ëþ~ºìîñÿ
			//{ std::wstring(     L"'ºìîñÿ"), 5 }, // á'~ºìîñÿ
			{ std::wstring(      L"èìîñÿ"), 4 }, // áðèæè~ìîñÿ îáìåæè-ìîñÿ
			{ std::wstring(      L"³ìîñÿ"), 4 }, // áåð~³ìîñÿ äèâ³~ìîñÿ
			//{ std::wstring(      L"¿ìîñÿ"), 4 }, // no words
			//{ std::wstring(     L"à¿ìîñÿ"), 4 }, // too little words (íà~¿ìîñÿ)
			{ std::wstring(     L"î¿ìîñÿ"), 5 }, // áî~¿ìîñÿ áëàãîóñòðî~¿ìîñÿ
			{ std::wstring(      L"éìîñÿ"), 5 }, // compound
			//{ std::wstring(     L"àéìîñÿ"), 5 }, // íàçèâà~éìîñÿ âåðòà~éìîñÿ
			//{ std::wstring(     L"èéìîñÿ"), 5 }, // áè~éìîñÿ
			//{ std::wstring(     L"³éìîñÿ"), 5 }, // á³~éìîñÿ
			//{ std::wstring(     L"îéìîñÿ"), 5 }, // áëàãîóñòðî~éìîñÿ
			//{ std::wstring(     L"óéìîñÿ"), 5 }, // àêòóàë³çó~éìîñÿ
			//{ std::wstring(     L"þéìîñÿ"), 5 }, // àí³ã³ëþ~éìîñÿ
			{ std::wstring(      L"üìîñÿ"), 4 }, // áåç÷åñòü~ìîñÿ ñêèíü~ìîñÿ çîñåðåäü~ìîñÿ
			{ std::wstring(        L"óñÿ"), 3 }, // áåð~óñÿ áåç÷åù~óñÿ
			{ std::wstring(      L"èìóñÿ"), 4 }, // áåðåãòè~ìóñÿ
			{ std::wstring(    L"àòèìóñÿ"), 6 }, // áðà~òèìóñÿ
			{ std::wstring(    L"îòèìóñÿ"), 6 }, // áîðî~òèìóñÿ
			//{ std::wstring(    L"¿òèìóñÿ"), 6 }, // ãíî¿~òèìóñÿ
			{ std::wstring(   L"î¿òèìóñÿ"), 7 }, // ãíî~¿òèìóñÿ
			{ std::wstring(  L"óâàòèìóñÿ"), 8 }, // àêòóàë³çó~âàòèìóñÿ
			{ std::wstring(  L"þâàòèìóñÿ"), 8 }, // àí³ã³ëþ~âàòèìóñÿ
			{ std::wstring(    L"èòèìóñÿ"), 6 }, // áðèæè~òèìóñÿ áè~òèìóñÿ
			{ std::wstring(    L"ÿòèìóñÿ"), 6 }, // áî~ÿòèìóñÿ
			{ std::wstring(       L"åøñÿ"), 4 }, // áåð~åøñÿ
			{ std::wstring(     L"èìåøñÿ"), 5 }, // áåðåãòè~ìåøñÿ
			{ std::wstring(   L"àòèìåøñÿ"), 7 }, // íàçèâà~òèìåøñÿ
			{ std::wstring(   L"îòèìåøñÿ"), 7 }, // áîðî~òèìåøñÿ
			{ std::wstring( L"óâàòèìåøñÿ"), 9 }, // àêòóàë³çó~âàòèìåøñÿ
			{ std::wstring( L"þâàòèìåøñÿ"), 9 }, // àí³ã³ëþ~âàòèìåøñÿ
			{ std::wstring(   L"èòèìåøñÿ"), 7 }, // áðèæè~òèìåøñÿ áè~òèìåøñÿ
			//{ std::wstring(   L"¿òèìåøñÿ"), 7 }, // ãíî¿~òèìåøñÿ
			{ std::wstring(  L"î¿òèìåøñÿ"), 8 }, // ãíî~¿òèìåøñÿ
			{ std::wstring(   L"ÿòèìåøñÿ"), 8 }, // áî~ÿòèìåøñÿ
			{ std::wstring(       L"ºøñÿ"), 4 }, // compound
			//{ std::wstring(      L"àºøñÿ"), 4 }, // íàçèâà~ºøñÿ
			//{ std::wstring(      L"óºøñÿ"), 4 }, // àêòóàë³çó~ºøñÿ
			//{ std::wstring(      L"þºøñÿ"), 4 }, // àí³ã³ëþ~ºøñÿ
			//{ std::wstring(      L"'ºøñÿ"), 4 }, // á'~ºøñÿ
			{ std::wstring(       L"èøñÿ"), 4 }, // áðèæ~èøñÿ
			//{ std::wstring(       L"¿øñÿ"), 4 }, // áî~¿øñÿ áëàãîóñòðî~¿øñÿ
			{ std::wstring(      L"î¿øñÿ"), 4 }, // áî~¿øñÿ áëàãîóñòðî~¿øñÿ
			{ std::wstring(        L"üñÿ"), 2 }, // áåç÷åñòü~ñÿ, do not work without SA
			//{ std::wstring(       L"òüñÿ"), 4 }, // Must have vowel (Ut1sa) NOT:áåç÷åñ*òü~ñÿ
			{ std::wstring(      L"àòüñÿ"), 4 }, // íàçèâà~òüñÿ
			{ std::wstring(    L"óâàòüñÿ"), 6 }, // àêòóàë³çó~âàòüñÿ
			{ std::wstring(    L"þâàòüñÿ"), 6 }, // àí³ã³ëþ~âàòüñÿ
			{ std::wstring(      L"åòüñÿ"), 4 }, // áåðå~òüñÿ áåðåæå~òüñÿ
			{ std::wstring(    L"èìåòüñÿ"), 6 }, // áåðåãòè~ìåòüñÿ
			{ std::wstring(  L"àòèìåòüñÿ"), 8 }, // íàçèâà~òèìåòüñÿ
			{ std::wstring(L"þâàòèìåòüñÿ"), 10 }, // àí³ã³ëþ~âàòèìåòüñÿ
			{ std::wstring(L"óâàòèìåòüñÿ"), 10 }, // àêòóàë³çó~âàòèìåòüñÿ
			{ std::wstring(L"èòèìåòüñÿ"), 8 }, // áðèæè~òèìåòüñÿ áè~òèìåòüñÿ
			//{ std::wstring(  L"¿òèìåòüñÿ"), 8 }, // ãíî¿~òèìåòüñÿ
			{ std::wstring( L"î¿òèìåòüñÿ"), 9 }, // ãíî~¿òèìåòüñÿ
			{ std::wstring(  L"îòèìåòüñÿ"), 8 }, // áîðî~òèìåòüñÿ
			{ std::wstring(  L"ÿòèìåòüñÿ"), 9 }, // áî~ÿòèìåòüñÿ

			{ std::wstring(      L"ºòüñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºòüñÿ"), 5 }, // íàçèâà~ºòüñÿ
			//{ std::wstring(     L"óºòüñÿ"), 5 }, // àêòóàë³çó~ºòüñÿ
			//{ std::wstring(     L"þºòüñÿ"), 5 }, // àí³ã³ëþ~ºòüñÿ
			//{ std::wstring(     L"'ºòüñÿ"), 5 }, // á'~ºòüñÿ
			{ std::wstring(      L"èòüñÿ"), 4 }, // áðèæè~òüñÿ áè~òüñÿ
			{ std::wstring(      L"³òüñÿ"), 4 }, // äèâ³~òüñÿ áåð³~òüñÿ áåðåæ³~òüñÿ
			//{ std::wstring(      L"¿òüñÿ"), 5 }, // áëàãîóñòðî~¿òüñÿ
			{ std::wstring(     L"î¿òüñÿ"), 5 }, // áëàãîóñòðî~¿òüñÿ çàñïîêî~¿òüñÿ
			{ std::wstring(      L"îòüñÿ"), 4 }, // áîðî~òüñÿ
			{ std::wstring(      L"óòüñÿ"), 4 }, // áåõíó~òüñÿ áåðó~òüñÿ
			{ std::wstring(    L"èìóòüñÿ"), 6 }, // áåðåãòè~ìóòüñÿ
			{ std::wstring(  L"àòèìóòüñÿ"), 8 }, // íàçèâà~òèìóòüñÿ
			{ std::wstring(  L"îòèìóòüñÿ"), 8 }, // áîðî~òèìóòüñÿ
			{ std::wstring(L"óâàòèìóòüñÿ"), 10 }, // àêòóàë³çó~âàòèìóòüñÿ
			{ std::wstring(L"þâàòèìóòüñÿ"), 10 }, // àí³ã³ëþ~âàòèìóòüñÿ
			{ std::wstring(  L"èòèìóòüñÿ"), 8 }, // áðèæè~òèìóòüñÿ áè~òèìóòüñÿ
			//{ std::wstring(  L"¿òèìóòüñÿ"), 9 }, // ãíî~¿òèìóòüñÿ
			{ std::wstring( L"î¿òèìóòüñÿ"), 9 }, // ãíî~¿òèìóòüñÿ
			{ std::wstring(  L"ÿòèìóòüñÿ"), 9 }, // áî~ÿòèìóòüñÿ
			{ std::wstring(      L"þòüñÿ"), 5 }, // compound áîð~þòüñÿ
			//{ std::wstring(     L"àþòüñÿ"), 5 }, // íàçèâà~þòüñÿ
			//{ std::wstring(     L"þþòüñÿ"), 5 }, // àí³ã³ëþ~þòüñÿ
			//{ std::wstring(     L"'þòüñÿ"), 5 }, // á'~þòüñÿ
			//{ std::wstring(      L"¿òüñÿ"), 4 }, // çàñïîêî¿~òüñÿ
			{ std::wstring(     L"óþòüñÿ"), 5 }, // àêòóàë³çó~þòüñÿ
			{ std::wstring(      L"ÿòüñÿ"), 5}, // áåç÷åñò~ÿòüñÿ äèâë~ÿòüñÿ
			{ std::wstring(     L"îÿòüñÿ"), 5 }, // çàñïîêî~ÿòüñÿ ãíî~ÿòüñÿ áî~ÿòüñÿ
			{ std::wstring(        L"þñÿ"), 3 }, // compound àðêàí~þñÿ äèâë~þñÿ
			//{ std::wstring(       L"àþñÿ"), 3 }, // çíà~þñÿ íàçèâà~þñÿ
			//{ std::wstring(       L"îþñÿ"), 3 }, // áî~þñÿ áëàãîóñòðî~þñÿ ãíî~þñÿ
			//{ std::wstring(       L"óþñÿ"), 3 }, // àêòóàë³çó~þñÿ
			//{ std::wstring(       L"þþñÿ"), 3 }, // àí³ã³ëþ~þñÿ õâèëþ~þñÿ
			//{ std::wstring(       L"'þñÿ"), 3 }, // á'~þñÿ
		};

		static bool sureSuffixesInitialized = false;
		if (!sureSuffixesInitialized)
		{
			sureSuffixesInitialized = true;
			sureSuffixes = std::move(sureSuffixesStatic);;

			for (const SuffixEnd& suffixEnd : sureSuffixes)
			{
				if (suffixEnd.TakeCharsCount > suffixEnd.MatchSuffix.size())
				{
					PG_Assert(false && "actual suffix size must be <= of possible suffix size");
				}
			}
			std::sort(sureSuffixes.begin(), sureSuffixes.end(), [](SuffixEnd& a, SuffixEnd& b)
			{
				if (a.MatchSuffix.size() != b.MatchSuffix.size())
					return a.MatchSuffix.size() > b.MatchSuffix.size();
				return a.MatchSuffix < b.MatchSuffix;
			});
			for (size_t i = 0; i<sureSuffixes.size()-1; ++i)
			{
				const auto& curSuffix = sureSuffixes[i].MatchSuffix;
				if (curSuffix == sureSuffixes[i + 1].MatchSuffix && sureSuffixes[i].WordClass == sureSuffixes[i+1].WordClass)
				{
					PG_Assert(false && "Duplicate suffixs");
				}
			}
		}
	}

	bool isValidPhoneticSplit(wv::slice<wchar_t> word, int splitPos)
	{
		bool correct = splitPos > 0 && splitPos <= word.size();
		if (!correct)
			return false;

		PG_Assert(splitPos > 0);

		wchar_t prefixLastChar = word[splitPos - 1];
		wchar_t suffixFirstChar = word[splitPos];
		int suffixSize = word.size() - splitPos;

		// soft character modifies the previous character, the can't be separated
		if (suffixFirstChar == L'ü')
			return false;

		// WHY?
		// allow suffixes like "jmo"
		//if (suffixFirstChar == L'é' && suffixSize == 1)
		//	return false;

		// apostrophe makes previous consonant stronger, do not separate it from prefix
		if (suffixFirstChar == L'\'' || suffixFirstChar == L'\'')
			return false;

		return true;
	}

	// Tries to split the word into two parts, so that the phonetic transcription is not corrupted.
	// Returns prefix size or -1 if word can't be split.
	int phoneticSplitOfWord(wv::slice<wchar_t> word, boost::optional<WordClass> wordClass, int* pMatchedSuffixInd)
	{
		ensureSureSuffixesInitialized();

		for (size_t suffixInd = 0; suffixInd < sureSuffixes.size(); ++suffixInd)
		{
			const SuffixEnd& suffixEnd = sureSuffixes[suffixInd];
			WordClass suffixClass = suffixEnd.WordClass;

			//WordClass suffixClass = suffixEnd.WordClass;
			//if (suffixClass == WordClass::Participle || suffixClass == WordClass::VerbalAdverb)
			//	suffixClass = WordClass::Verb;

			//WordClass wordClassTmp = wordClass.get();
			//if (wordClassTmp == WordClass::Participle || wordClassTmp == WordClass::VerbalAdverb)
			//	wordClassTmp = WordClass::Verb;

			if (wordClass != nullptr)
			{
				// match word class and suffix (word) class
				WordClass wordClassTmp = wordClass.get();
				if (wordClassTmp != suffixClass)
					continue;
			}

			const std::wstring& suffix = suffixEnd.MatchSuffix;
			if (endsWith<wchar_t>(word, suffix))
			{
				int suffixSize = suffixEnd.TakeCharsCount;
				int prefixSize = (int)word.size() - suffixSize;
				
				// prohibit detaching the soft sign from prefix
				if (word[prefixSize] == L'ü' && prefixSize + 1 < word.size())
					prefixSize++;

				// trim vowels at the end of the prefix
				bool trimEndVowels = false;
				if (trimEndVowels)
				{
					bool isPrefixEndsVowel = true;
					while (prefixSize > 0 && isPrefixEndsVowel)
					{
						wchar_t prefixLastChar = word[prefixSize - 1];
						isPrefixEndsVowel = !PticaGovorun::isUkrainianConsonant(prefixLastChar);
						if (isPrefixEndsVowel)
							prefixSize--;
					}
				}

				// avoid short prefixes, as they will not participate in other words construction frequently
				// áîÿâøèéñÿ -> á
				// need prefixes with size>1 to distinguish (áè~éñÿ, á³~éñÿ)
				if (prefixSize <= 1) continue;

				if (!isValidPhoneticSplit(word, prefixSize))
					continue;

				if (wordClass == WordClass::Participle && suffixEnd.WordClass != WordClass::Participle)
				{
					participleSuffixToWord[suffixEnd.MatchSuffix] = std::wstring(word.data(), word.size());
				}
				if (wordClass == WordClass::VerbalAdverb && suffixEnd.WordClass != WordClass::VerbalAdverb)
				{
					participleSuffixToWord2[suffixEnd.MatchSuffix] = std::wstring(word.data(), word.size());
				}

				if (pMatchedSuffixInd != nullptr)
					*pMatchedSuffixInd = (int)suffixInd;
				
				return prefixSize;
			}
		}

		return -1;
	}

	bool isUnvoicedCharUk(wchar_t ch)
	{
		// êïñòôõøö÷
		// ÊÏÑÒÔÕØÖ×
		return
			ch == L'ê' || ch == L'Ê' ||
			ch == L'ï' || ch == L'Ï' ||
			ch == L'ñ' || ch == L'Ñ' ||
			ch == L'ò' || ch == L'Ò' ||
			ch == L'ô' || ch == L'Ô' ||
			ch == L'õ' || ch == L'Õ' ||
			ch == L'ø' || ch == L'Ø' ||
			ch == L'ö' || ch == L'Ö' ||
			ch == L'÷' || ch == L'×';
	}

	// Returns number of made transformations or zero if the map was not changed.
	int reuseCommonPrefixesOneIteration(std::map<std::wstring, int>& mapPrefixToSize)
	{
		if (mapPrefixToSize.size() <= 1)
			return 0;

		std::vector<std::wstring> prefixes(mapPrefixToSize.size());
		std::transform(std::begin(mapPrefixToSize), std::end(mapPrefixToSize), std::begin(prefixes), [](const std::pair<std::wstring, int>& pair)
		{
			return pair.first;
		});
		std::sort(std::begin(prefixes), std::end(prefixes), [](std::wstring& a, std::wstring& b)
		{
			return a.size() < b.size();
		});

		int changesMade = 0;
		std::vector<uchar> processed(prefixes.size());
		for (size_t i = 0; i < processed.size(); ++i)
		{
			if (processed[i])
				continue;
			processed[i] = true;
			for (size_t j = i; j < processed.size(); ++j)
			{
				if (processed[j])
					continue;
				const std::wstring& s1 = prefixes[i];
				const std::wstring& s2 = prefixes[j];
				assert(s1.size() <= s2.size() && "Strings are ordered in ascending order");

				size_t prefixSize = commonPrefixSize<wchar_t>(s1, s2);
				auto countConsonant = [](wchar_t ch) { return isUkrainianConsonant(ch); };
				size_t conson1 = std::count_if(s1.begin() + prefixSize, s1.end(), countConsonant);
				size_t conson2 = std::count_if(s2.begin() + prefixSize, s2.end(), countConsonant);

				bool canSplit1 = isValidPhoneticSplit(s1, prefixSize);
				bool canSplit2 = isValidPhoneticSplit(s1, prefixSize);

				// can reduce two prefixes only if they differ in ending of all vowels
				bool canReduce = (prefixSize < s1.size() || prefixSize < s2.size()) && conson1 == 0 && conson2 == 0 && canSplit1 && canSplit2;
				if (!canReduce)
					continue;

				if (prefixSize < s1.size() ^ prefixSize < s2.size()) // one is the prefix of another
				{
					// keep shorter prefix, remove longer prefix
					const std::wstring *shorter = nullptr;
					const std::wstring *longer = nullptr;
					size_t longerWordInd;
					if (prefixSize < s1.size())
					{
						shorter = &s1;
						longer = &s2;
						longerWordInd = j;
					}
					else
					{
						shorter = &s2;
						longer = &s1;
						longerWordInd = i;
					}
					int usedCount = mapPrefixToSize[*longer];
					mapPrefixToSize.erase(*longer);

					mapPrefixToSize[*shorter] += usedCount;

					processed[longerWordInd] = true;
				}
				else
				{
					int usedCount1 = mapPrefixToSize[s1];
					int usedCount2 = mapPrefixToSize[s2];
					mapPrefixToSize.erase(s1);
					mapPrefixToSize.erase(s2);

					std::wstring prefix(s1.data(), prefixSize);
					mapPrefixToSize[prefix] += usedCount1 + usedCount2;
					processed[i] = true;
					processed[j] = true;
				}
				changesMade++;
			}
		}
		return changesMade;
	}

	void reuseCommonPrefixes(std::map<std::wstring, int>& mapPrefixToSize)
	{
		while (reuseCommonPrefixesOneIteration(mapPrefixToSize) > 0) {}
	}

	bool isVoiceless(wchar_t ch)
	{
		bool voiceless = ch == L'÷'; // áóðêî÷
		return voiceless;
	}

	UkrainianPhoneticSplitter::UkrainianPhoneticSplitter()
	{
		bool wasAdded = false;
		sentStartWordPart_ = wordUsage_.getOrAddWordPart(L"<s>", WordPartSide::WholeWord, &wasAdded);
		CV_Assert(wasAdded);
		sentEndWordPart_ = wordUsage_.getOrAddWordPart(L"</s>", WordPartSide::WholeWord, &wasAdded);
		CV_Assert(wasAdded);
	}

	void UkrainianPhoneticSplitter::bootstrap(const std::unordered_map<std::wstring, std::unique_ptr<WordDeclensionGroup>>& words, const std::wstring& targetWord, const std::unordered_set<std::wstring>& processedWords)
	{
		for (const auto& pair : words)
		{
			const WordDeclensionGroup& wordGroup = *pair.second;
			bool contains = processedWords.find(wordGroup.Name) != processedWords.end();
			if (false && !contains)
				continue;

			if (!targetWord.empty() && wordGroup.Name != targetWord)
				continue;

			if (!allowPhoneticWordSplit_)
			{
				// put all word declination forms as whole word parts
				for (const WordDeclensionForm& declWord : wordGroup.Forms)
				{
					if (declWord.isNotAvailable()) continue;
					const WordPart* wordPart = wordUsage_.getOrAddWordPart(declWord.Name, WordPartSide::WholeWord);
				}
				continue;
			}

			if (wordGroup.WordClass == WordClass::Irremovable ||
				wordGroup.WordClass == WordClass::Preposition ||
				wordGroup.WordClass == WordClass::Pronoun ||
				wordGroup.WordClass == WordClass::Conjunction ||
				wordGroup.WordClass == WordClass::Interjection ||
				wordGroup.WordClass == WordClass::Particle ||
				wordGroup.WordClass == WordClass::Irremovable)
			{
				// keep the word intact
				continue;
			}
			else if (
				wordGroup.WordClass == WordClass::Adjective ||
				wordGroup.WordClass == WordClass::Adverb ||
				wordGroup.WordClass == WordClass::Noun ||
				wordGroup.WordClass == WordClass::Numeral ||
				wordGroup.WordClass == WordClass::Verb ||
				wordGroup.WordClass == WordClass::VerbalAdverb ||
				wordGroup.WordClass == WordClass::Participle)
			{
				std::vector<std::wstring> unsplitWords;
				std::map<std::wstring, int> mapPrefixSizeToCount;
				for (const WordDeclensionForm& wordForm : wordGroup.Forms)
				{
					const std::wstring& word = wordForm.Name;

					// split comma separated words into words
					size_t newOffset;
					for (size_t offset = 0; offset < word.size(); offset = newOffset + 1) // +1 to skip comma
					{
						if (word[offset] == L'*')
							offset++;
						newOffset = word.find(L",", offset);
						if (newOffset == (size_t)-1)
							newOffset = word.size();

						wv::slice<wchar_t> subWord = wv::make_view(word.data() + offset, newOffset - offset);

						int matchedSuffixInd = -1;
						WordClass curWordClass = wordGroup.WordClass.get();
						if (wordForm.WordClass != nullptr)
							curWordClass = wordForm.WordClass.get();

						int sepInd = phoneticSplitOfWord(subWord, curWordClass, &matchedSuffixInd);
						if (sepInd != -1)
							sureSuffixes[matchedSuffixInd].UsedCount++;

						if (sepInd == -1)
						{
							bool voiceless = isVoiceless(subWord[subWord.size() - 1]);

							wchar_t wordLastChar = subWord[subWord.size() - 1];
							bool ok =
								wordLastChar == L'ü' ||
								wordLastChar == L'æ' || // áðîäÿæ
								voiceless;

							// it is ok to not finding consonant+sa
							if (!ok && endsWith(subWord, (wv::slice<wchar_t>)std::wstring(L"ñÿ")))
							{
								wchar_t prefixLastChar = subWord[subWord.size() - 1 - 2];
								ok = isUkrainianConsonant(prefixLastChar);
							}
							if (!ok)
							{
								std::wstring subWordStr(subWord.data(), subWord.size());
								unsplitWords.push_back(subWordStr);
								//::DebugBreak();
								//::OutputDebugStringW(L"Suffix was not found for word: ");
								//::OutputDebugStringW(subWordStr.data());
								//::OutputDebugStringW(L"\n");
							}
						}

						//if (sepInd != -1)
						//{
						//	wv::slice<wchar_t> prefixWord = wv::make_view(subWord.data(), sepInd);
						//	static std::wstring suffixVa(L"âà");
						//	if (endsWith(prefixWord, wv::make_view(suffixVa)))
						//	{
						//		// skip -va words
						//		//continue;
						//	}
						//}

						// store prefix to usage count
						{
							int sepIndTmp = sepInd;
							if (sepIndTmp == -1)
								sepIndTmp = subWord.size();

							// separation position was not found, use the whole word
							std::wstring prefixStr(subWord.data(), 0, sepIndTmp);
							mapPrefixSizeToCount[prefixStr]++;
						}

						int partsCount;
						std::array<std::wstring, 2> partsStrings;
						std::array<WordPartSide, 2> partsSides;
						if (sepInd == -1)
						{
							// separation position was not found, use the whole word
							partsCount = 1;
							partsStrings[0] = toString(subWord);
							partsSides[0] = WordPartSide::WholeWord;
						}
						else
						{
							partsCount = 2;

							wv::slice<wchar_t> prefix = wv::make_view(subWord.data(), sepInd);
							wv::slice<wchar_t> suffix = wv::make_view(subWord.data() + sepInd, subWord.size() - sepInd);

							partsStrings[0] = toString(prefix);
							partsSides[0] = WordPartSide::LeftPart;
							partsStrings[1] = toString(suffix);
							partsSides[1] = WordPartSide::RightPart;
						}

						//
						ShortArray<int, 2> splitParts;
						splitParts.Array.fill(-1);
						splitParts.ActualSize = partsCount;

						for (int partInd = 0; partInd < partsCount; ++partInd)
						{
							const std::wstring& partStr = partsStrings[partInd];
							WordPartSide partSide = partsSides[partInd];

							const WordPart* wordPart = wordUsage_.getOrAddWordPart(partStr, partSide);

							//WordSeqKey wordIds({ wordPart->id() });
							//WordSeqUsage* wordSeq = wordUsage_.getOrAddWordSequence(wordIds);
							//wordSeq->UsedCount++;

							splitParts.Array[partInd] = wordPart->id();
						}
						wordStrToPartIds_[word] = splitParts;
					}
				}

				size_t diffPrefixCountBefore = mapPrefixSizeToCount.size();
				reuseCommonPrefixes(mapPrefixSizeToCount);

				size_t diffPrefixCount = mapPrefixSizeToCount.size();
				for (const auto& prefixToCountPair : mapPrefixSizeToCount)
				{
					const auto& prefix = prefixToCountPair.first;
					wchar_t ch = prefix[prefix.size() - 1];
					bool voiceless = isVoiceless(ch);
					if (ch == L'ü' || voiceless || ch == L'-')
						diffPrefixCount--;
				}
				//std::wcout << L"word finished diffPrefixCount=" << diffPrefixCount << std::endl;
			}
			else
				::DebugBreak(); // unknown word class
		}
		const auto& m1 = participleSuffixToWord;
		const auto& m2 = participleSuffixToWord2;
		OutputDebugStringW(L"PARTICIPLE\n");
		for (const auto& pair : participleSuffixToWord)
		{
			OutputDebugStringW(pair.first.c_str());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(pair.second.c_str());
			OutputDebugStringW(L"\n");
		}
		OutputDebugStringW(L"VERBALADVERB\n");
		for (const auto& pair : participleSuffixToWord2)
		{
			OutputDebugStringW(pair.first.c_str());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(pair.second.c_str());
			OutputDebugStringW(L"\n");
		}
	}

	const WordsUsageInfo& UkrainianPhoneticSplitter::wordUsage() const
	{
		return wordUsage_;
	}
	WordsUsageInfo& UkrainianPhoneticSplitter::wordUsage()
	{
		return wordUsage_;
	}

	void UkrainianPhoneticSplitter::printSuffixUsageStatistics() const
	{
		auto sureSuffixesCopy = sureSuffixes;
		std::sort(sureSuffixesCopy.begin(), sureSuffixesCopy.end(), [](SuffixEnd& a, SuffixEnd& b)
		{
			return a.UsedCount > b.UsedCount;
		});
		OutputDebugStringW(L"Suffix usage statistics:\n");
		for (const auto& suffixEnd : sureSuffixesCopy)
		{
			OutputDebugStringW(suffixEnd.MatchSuffix.data());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(QString::number(suffixEnd.UsedCount).toStdWString().c_str());

			wchar_t* classStr = L"";
			if (suffixEnd.WordClass == WordClass::Verb)
				classStr = L"v";
			else if (suffixEnd.WordClass == WordClass::Noun)
				classStr = L"n";
			else if (suffixEnd.WordClass == WordClass::Adjective)
				classStr = L"adj";
			else if (suffixEnd.WordClass == WordClass::Adverb)
				classStr = L"adverb";
			OutputDebugStringW(L" ");
			OutputDebugStringW(classStr);
			OutputDebugStringW(L"\n");
		}
	}

	long UkrainianPhoneticSplitter::wordSeqCount(int wordsPerSeq) const
	{
		PG_Assert(wordsPerSeq <= 2);
		if (wordsPerSeq == 1)
			return seqOneWordCounter_;
		return seqTwoWordsCounter_;
	}

	const WordPart* UkrainianPhoneticSplitter::sentStartWordPart() const
	{
		return sentStartWordPart_;
	}

	const WordPart* UkrainianPhoneticSplitter::sentEndWordPart() const
	{
		return sentEndWordPart_;
	}

	void UkrainianPhoneticSplitter::setAllowPhoneticWordSplit(bool value)
	{
		allowPhoneticWordSplit_ = value;
	}

	void UkrainianPhoneticSplitter::gatherWordPartsSequenceUsage(const wchar_t* textFilesDir, long& totalPreSplitWords, int maxFileToProcess, bool outputCorpus)
	{
		QFile corpusFile;
		QTextStream corpusStream;
		if (outputCorpus)
		{
			std::wstringstream corpusFileName;
			corpusFileName << "persianCorpus.";
			appendTimeStampNow(corpusFileName);
			corpusFileName << ".txt";

			corpusFile.setFileName(QString::fromStdWString(corpusFileName.str()));
			if (!corpusFile.open(QIODevice::WriteOnly | QIODevice::Text))
				return;
			corpusStream.setDevice(&corpusFile);
			corpusStream.setCodec("UTF-8");
		}

		QXmlStreamReader xml;
		totalPreSplitWords = 0;

		std::vector<wv::slice<wchar_t>> words;
		words.reserve(64);
		std::vector<const WordPart*> wordParts;
		wordParts.reserve(1024);
		TextParser wordsReader;

		QString textFilesDirQ = QString::fromStdWString(textFilesDir);
		QDirIterator it(textFilesDirQ, QStringList() << "*.fb2", QDir::Files, QDirIterator::Subdirectories);
		int processedFiles = 0;
		while (it.hasNext())
		{
			if (maxFileToProcess != -1 && processedFiles == maxFileToProcess)
				break;

			//if (processedFiles >= 2) break; // process less work

			QString txtPath = it.next();
			if (txtPath.contains("BROKEN", Qt::CaseSensitive))
			{
				qDebug() << "SKIPPED " << txtPath;
				continue;
			}
			qDebug() << txtPath;

			//
			QFile file(txtPath);
			if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			{
				qDebug() << "Can't open file " << txtPath;
				return;
			}

			// parse file
			xml.setDevice(&file);
			while (!xml.atEnd())
			{
				xml.readNext();
				if (xml.isCharacters())
				{
					// BUG: if the lines inside the text are separated using LF only on windows machines
					//      the function below will concatenate the lines. For now, fix LF->CRLF for such files externally
					QStringRef elementText = xml.text();

					wv::slice<wchar_t> textToParse = wv::make_view((wchar_t*)elementText.data(), elementText.size());
					wordsReader.setInputText(textToParse);

					// extract all sentences from paragraph
					while (true)
					{
						words.clear();
						if (!wordsReader.parseSentence(words))
							break;
						if (words.empty())
							continue;

						{
							// augment the sentence with start/end terminators
							wordParts.push_back(sentStartWordPart_);

							selectWordParts(words, wordParts, totalPreSplitWords);

							// augment the sentence with start/end terminators
							wordParts.push_back(sentEndWordPart_);
						}

						// calculate statistic only if enough word parts is accumulated
						size_t calcStatWordPartsCount = 1000000;
						if (wordParts.size() > calcStatWordPartsCount)
						{
							calcNGramStatisticsOnWordPartsBatch(wordParts, outputCorpus, corpusStream);
						}
					}
				}
			}
			
			// flush the word parts buffer
			calcNGramStatisticsOnWordPartsBatch(wordParts, outputCorpus, corpusStream);

			++processedFiles;
		}
	}

	void UkrainianPhoneticSplitter::selectWordParts(const std::vector<wv::slice<wchar_t>>& words, std::vector<const WordPart*>& wordParts, long& preSplitWords)
	{
		for (int i = 0; i < words.size(); ++i)
		{
			const wv::slice<wchar_t>& wordSlice = words[i];
			PG_Assert(!wordSlice.empty());

			// keep ukrainian words only
			//auto filterOutWord = [](wv::slice<wchar_t> word)
			//{
			//	for (size_t charInd = 0; charInd < word.size(); ++charInd)
			//	{
			//		wchar_t ch = word[charInd];
			//		bool isDigit = isDigitChar(ch);
			//		//bool isLatin = isEnglishChar(ch);
			//		bool isSureLatin = isExclusiveEnglishChar(ch);
			//		bool isSureRus = isExclusiveRussianChar(ch);
			//		//if (isDigit || isLatin || isSureRus)
			//		if (isDigit || isSureLatin || isSureRus)
			//			return true;
			//	}
			//	return false;
			//};
			//if (filterOutWord(wordSlice))
			//{
			//	::OutputDebugStringW(toString(wordSlice).c_str());
			//	::OutputDebugStringW(L"\n");
			//	continue;
			//}

			auto wordCharUsage = [](wv::slice<wchar_t> word, int& digitsCount,
				int& engCount, int& exclEngCount,
				int& rusCount, int& exclRusCount,
				int& hyphenCount)
			{
				for (size_t charInd = 0; charInd < word.size(); ++charInd)
				{
					wchar_t ch = word[charInd];
					bool isDigit = isDigitChar(ch);
					bool isEng = isEnglishChar(ch);
					bool isExclEng = isExclusiveEnglishChar(ch);
					bool isRus = isRussianChar(ch);
					bool isExclRus = isExclusiveRussianChar(ch);
					if (isDigit)
						digitsCount++;
					if (isEng)
						engCount++;
					if (isExclEng)
						exclEngCount++;
					if (isRus)
						rusCount++;
					if (isExclRus)
						exclRusCount++;
					if (ch == L'-' || ch == L'\'')
						hyphenCount++;
				}
			};
			int digitsCount = 0;
			int engCount = 0;
			int exclEngCount = 0;
			int rusCount = 0;
			int exclRusCount = 0;
			int hyphenCount = 0;
			wordCharUsage(wordSlice, digitsCount, engCount, exclEngCount, rusCount, exclRusCount, hyphenCount);
			if (digitsCount > 0 || exclEngCount > 0 || exclRusCount > 0)
			{
				if (digitsCount == wordSlice.size() ||  // number
					(exclEngCount > 0 && (engCount + hyphenCount) == wordSlice.size()) || // english word
					(exclRusCount > 0 && (rusCount + hyphenCount) == wordSlice.size())    // russian word
					)
				{
					// do not even print the skipped word
					continue;
				}
				else
				{
					::OutputDebugStringW(toString(wordSlice).c_str());
					::OutputDebugStringW(L"\n");
				}
				wordParts.push_back(wordPartSeparator_); // word parts separator
				continue;
			}

			std::wstring str = toString(wordSlice);

			if (allowPhoneticWordSplit_)
			{
				auto preSplitWordIt = wordStrToPartIds_.find(str);
				if (preSplitWordIt != wordStrToPartIds_.end())
				{
					preSplitWords++;
					ShortArray<int, 2>& preSplit = preSplitWordIt->second;

					for (int splitInd = 0; splitInd < preSplit.ActualSize; ++splitInd)
					{
						int wordPartId = preSplit.Array[splitInd];
						const WordPart* wordPartPtr = wordUsage_.wordPartById(wordPartId);
						wordParts.push_back(wordPartPtr);
					}
				}
				else
				{
					doWordPhoneticSplit(str, wordParts);
				}
			}
			else
			{
				const WordPart* wordPart = wordUsage_.getOrAddWordPart(str, WordPartSide::WholeWord);
				wordParts.push_back(wordPart);
			}
		}
	}

	void UkrainianPhoneticSplitter::calcNGramStatisticsOnWordPartsBatch(std::vector<const WordPart*>& wordParts, bool outputCorpus, QTextStream& corpusStream)
	{
		std::vector<const WordPart*> wordPartsStraight;

		// select sequantial word parts without separator
		size_t wordPartInd = 0;
		auto takeWordPartsTillNull = [this, &wordParts, &wordPartInd](std::vector<const WordPart*>& outWordParts) -> bool
		{
			// returns true if result contains data
			while (wordPartInd < wordParts.size())
			{
				for (; wordPartInd < wordParts.size(); ++wordPartInd)
				{
					const WordPart* wordPartPtr = wordParts[wordPartInd];
					if (wordPartPtr == wordPartSeparator_)
					{
						wordPartInd++; // skip separator
						break;
					}
					outWordParts.push_back(wordPartPtr);
				}
				if (!outWordParts.empty())
					return true;
			}
			return false;
		};
		while (true)
		{
			wordPartsStraight.clear();
			if (!takeWordPartsTillNull(wordPartsStraight))
				break;

			calcLangStatistics(wordPartsStraight);

			if (outputCorpus)
			{
				for (const WordPart* wp : wordPartsStraight)
				{
					printWordPart(wp, corpusStream);
					corpusStream << " ";
				}
				corpusStream << "\n";
			}
		}
		// purge word parts buffer
		wordParts.clear();
	}

	void UkrainianPhoneticSplitter::calcLangStatistics(const std::vector<const WordPart*>& wordParts)
	{
		const WordPart* prevWordPart = nullptr;

		for (const WordPart* wordPart : wordParts)
		{
			if (wordPart->partText() == L"âàëóâàíí")
			{
				PG_Assert(true);
			}
			// unimodel
			WordSeqKey oneWordKey({ wordPart->id() });
			WordSeqUsage* oneWordSeq = wordUsage_.getOrAddWordSequence(oneWordKey);
			oneWordSeq->UsedCount++;
			seqOneWordCounter_++;

			// bimodel
			if (prevWordPart != nullptr)
			{
				WordSeqKey twoWordsKey({ prevWordPart->id(), wordPart->id() });
				WordSeqUsage* twoWordsSeq = wordUsage_.getOrAddWordSequence(twoWordsKey);
				twoWordsSeq->UsedCount++;
				seqTwoWordsCounter_++;
			}

			prevWordPart = wordPart;
		}
	}

	void UkrainianPhoneticSplitter::doWordPhoneticSplit(const wv::slice<wchar_t>& wordSlice, std::vector<const WordPart*>& wordParts)
	{
		//const std::wstring& word
		int matchedSuffixInd = -1;
		int sepInd = phoneticSplitOfWord(wordSlice, nullptr, &matchedSuffixInd);
		if (sepInd != -1)
			sureSuffixes[matchedSuffixInd].UsedCount++;

		int partsCount;
		std::array<std::wstring, 2> partsStrings;
		std::array<WordPartSide, 2> partsSides;
		if (sepInd == -1)
		{
			// separation position was not found, use the whole word
			partsCount = 1;
			partsStrings[0] = toString(wordSlice);
			partsSides[0] = WordPartSide::WholeWord;
		}
		else
		{
			partsCount = 2;

			wv::slice<wchar_t> prefix = wv::make_view(wordSlice.data(), sepInd);
			wv::slice<wchar_t> suffix = wv::make_view(wordSlice.data() + sepInd, wordSlice.size() - sepInd);

			partsStrings[0] = toString(prefix);
			partsSides[0] = WordPartSide::LeftPart;
			partsStrings[1] = toString(suffix);
			partsSides[1] = WordPartSide::RightPart;
		}

		for (int partInd = 0; partInd < partsCount; ++partInd)
		{
			const std::wstring& partStr = partsStrings[partInd];
			WordPartSide partSide = partsSides[partInd];

			const WordPart* wordPart = wordUsage_.getOrAddWordPart(partStr, partSide);
			wordParts.push_back(wordPart);
		}
	}
}