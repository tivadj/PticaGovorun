#include "stdafx.h"
#include "PhoneticService.h"
#include <array>
#include <QFile>
#include <QDir>
#include <QDirIterator>
#include <QDebug>
#include <QXmlStreamReader>
#include <QString>
#include "CoreUtils.h"

namespace PticaGovorun
{
	namespace
	{
		const wchar_t Letter_Hyphen = L'-';
		const wchar_t Letter_Apostrophe = L'\'';
		const wchar_t Letter_A = L'à';
		const wchar_t Letter_B = L'á';
		const wchar_t Letter_H = L'ã';
		const wchar_t Letter_D = L'ä';
		const wchar_t Letter_JE = L'º';
		const wchar_t Letter_ZH = L'æ';
		const wchar_t Letter_Z = L'ç';
		const wchar_t Letter_JI = L'¿';
		const wchar_t Letter_K = L'ê';
		const wchar_t Letter_N = L'í';
		const wchar_t Letter_S = L'ñ';
		const wchar_t Letter_T = L'ò';
		const wchar_t Letter_U = L'ó';
		const wchar_t Letter_TS = L'ö';
		const wchar_t Letter_CH = L'÷';
		const wchar_t Letter_SH = L'ø';
		const wchar_t Letter_SHCH = L'ù';
		const wchar_t Letter_SoftSign = L'ü';
		const wchar_t Letter_JU = L'þ';
		const wchar_t Letter_JA = L'ÿ';
	}

	void Pronunc::setPhones(const std::vector<std::string>& phones)
	{
		for (const std::string& ph : phones)
		{
			pushBackPhone(ph);
		}
	}

	void Pronunc::pushBackPhone(const std::string& phone)
	{
		if (!StrDebug.empty())
			StrDebug.push_back(' ');
		std::copy(std::begin(phone), std::end(phone), std::back_inserter(StrDebug));
		Phones.push_back(phone);
	}

	bool operator == (const Pronunc& a, const Pronunc& b)
	{
		bool eqSize = a.Phones.size() == b.Phones.size();
		if (!eqSize)
			return false;
		for (int i = 0; i < a.Phones.size(); ++i)
		{
			auto p1 = a.Phones[i];
			auto p2 = b.Phones[i];
			bool eqPhones = p1 == p2;
			if (!eqPhones)
				return false;
		}
		return true;
	}

	bool operator < (const Pronunc& a, const Pronunc& b)
	{
		size_t minSize = std::min(a.Phones.size(), b.Phones.size());
		for (int i = 0; i < minSize; ++i)
		{
			auto p1 = a.Phones[i];
			auto p2 = b.Phones[i];
			bool eq = p1 == p2;
			if (!eq)
				return std::less<>()(p1, p2);
		}
		if (     a.Phones.size() < b.Phones.size())
			return true;
		else if (a.Phones.size() > b.Phones.size())
			return false;
		return false;
	}

	std::tuple<bool, const char*> loadPronunciationVocabulary(const std::wstring& vocabFilePathAbs, std::map<std::wstring, std::vector<std::string>>& wordToPhoneList, const QTextCodec& textCodec)
	{
		// file contains text in Windows-1251 encoding
		QFile file(QString::fromStdWString(vocabFilePathAbs));
		if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			return std::make_tuple(false, "Can't open file");

		// 
		std::array<char, 1024> lineBuff;

		// each line has a format:
		// sure\tsh u e\n
		while (true) {
			auto readBytes = file.readLine(lineBuff.data(), lineBuff.size());
			if (readBytes == -1) // EOF
			{
				break;
			}

			// read the first word

			char* pMutStr = lineBuff.data(); // note, strtok modifies the buffer
			char* pMutStrNext = nullptr;

			const char* DictDelim = " \t\n";

			// strtok seems to be quicker than std::regex or QString::split approaches
			pMutStr = strtok_s(pMutStr, DictDelim, &pMutStrNext);
			if (pMutStr == nullptr)
			{
				// the line contains only the whitespace
				continue;
			}

			QString word = textCodec.toUnicode(pMutStr);

			// read the tail of phones
			std::vector<std::string> phones;
			while (true)
			{
				pMutStr = strtok_s(nullptr, DictDelim, &pMutStrNext);
				if (pMutStr == nullptr)
					break;

				auto len = strlen(pMutStr);
				std::string phoneStr(pMutStr, len);
				phones.push_back(std::move(phoneStr));
			}

			wordToPhoneList.insert(std::make_pair<std::wstring, std::vector<std::string>>(word.toStdWString(), std::move(phones)));
		}

		return std::make_tuple(true, nullptr);
	}

	std::tuple<bool, const char*> loadPronunciationVocabulary2(const std::wstring& vocabFilePathAbs, std::map<std::wstring, std::vector<Pronunc>>& wordToPhoneList, const QTextCodec& textCodec)
	{
		// file contains text in Windows-1251 encoding
		QFile file(QString::fromStdWString(vocabFilePathAbs));
		if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			return std::make_tuple(false, "Can't open file");

		// 
		std::array<char, 1024> lineBuff;

		// each line has a format:
		// sure\tsh u e\n
		while (true) {
			auto readBytes = file.readLine(lineBuff.data(), lineBuff.size());
			if (readBytes == -1) // EOF
			{
				break;
			}
			//if (rand() % 50 >= 1) // filter for speed
			//	continue;

			// read the first word

			char* pMutStr = lineBuff.data(); // note, strtok modifies the buffer
			char* pMutStrNext = nullptr;

			const char* DictDelim = " \t\n";

			// strtok seems to be quicker than std::regex or QString::split approaches
			pMutStr = strtok_s(pMutStr, DictDelim, &pMutStrNext);
			if (pMutStr == nullptr)
			{
				// the line contains only the whitespace
				continue;
			}

			QString word = textCodec.toUnicode(pMutStr);

			// read the tail of phones
			std::vector<std::string> phones;
			while (true)
			{
				pMutStr = strtok_s(nullptr, DictDelim, &pMutStrNext);
				if (pMutStr == nullptr)
					break;

				auto len = strlen(pMutStr);
				std::string phoneStr(pMutStr, len);
				phones.push_back(std::move(phoneStr));
			}

			std::wstring wordW = word.toStdWString();
			auto it = wordToPhoneList.find(wordW);
			if (it == std::end(wordToPhoneList))
			{
				std::vector<Pronunc> prons;
				wordToPhoneList.insert({ wordW, prons });
				it = wordToPhoneList.find(wordW);
				assert(it != std::end(wordToPhoneList) && "Element must be in the map");
			}
			Pronunc pron;
			pron.setPhones(phones);
			it->second.push_back(std::move(pron));
		}

		return std::make_tuple(true, nullptr);
	}

	void normalizePronunciationVocabulary(std::map<std::wstring, std::vector<Pronunc>>& wordToPhoneList)
	{
		for (auto& pair : wordToPhoneList)
		{
			std::vector<Pronunc>& prons = pair.second;
			for (auto& pron : prons)
			{
				for (auto& phone : pron.Phones)
				{
					QString phoneStr = QString::fromStdString(phone);
					if (phoneStr[phoneStr.size()-1].isDigit())
					{
						phoneStr = phoneStr.left(phoneStr.size() - 1); // remove last digit
					}
					phoneStr = phoneStr.toUpper();
					phone = phoneStr.toStdString();
				}
			}

			std::sort(std::begin(prons), std::end(prons));
			auto it = std::unique(std::begin(prons), std::end(prons));
			size_t newSize = std::distance(std::begin(prons), it);
			prons.resize(newSize);
		}
	}

	void parsePhoneListStrs(const std::string& phonesStr, std::vector<std::string>& result)
	{
		QStringList list = QString::fromStdString(phonesStr).split(' ');
		for (int i = 0; i < list.size(); ++i)
		{
			QString phoneQ = list[i];
			if (phoneQ.isEmpty()) // a phone can't be an empty string
				continue;
			result.push_back(phoneQ.toStdString());
		}
	}

	bool parsePhoneListStrs(const std::string& phonesStr, std::vector<UkrainianPhoneId>& result)
	{
		QStringList list = QString::fromStdString(phonesStr).split(' ');
		for (int i = 0; i < list.size(); ++i)
		{
			QString phoneQ = list[i];
			if (phoneQ.isEmpty()) // a phone can't be an empty string
				continue;

			bool parseOp = false;
			UkrainianPhoneId phoneId = phoneStrToId(phoneQ.toStdString(), &parseOp);
			if (!parseOp)
				return false;
			result.push_back(phoneId);
		}
		return true;
	}

	std::tuple<bool, const char*>  parsePronuncLines(const std::wstring& prons, std::vector<PronunciationFlavour>& result)
	{
		QString pronsQ = QString::fromStdWString(prons);
		QStringList pronItems = pronsQ.split('\n', QString::SkipEmptyParts);
		for (int pronInd = 0; pronInd < pronItems.size(); ++pronInd)
		{
			QString pronLine = pronItems[pronInd];
			int pronAsWordEndInd = pronLine.indexOf('\t');
			if (pronAsWordEndInd == -1)
				return std::make_tuple(false, "First part of line doesn't contain pronunciation id");

			QString pronAsWord = pronLine.left(pronAsWordEndInd);
			QString phonesStr = pronLine.mid(pronAsWordEndInd+1);

			std::vector<std::string> phones;
			parsePhoneListStrs(phonesStr.toStdString(), phones);

			PronunciationFlavour pron;
			pron.PronAsWord = pronAsWord.toStdWString();
			pron.PhoneStrs = phones;
			result.push_back(pron);
		}
		return std::make_tuple(true, nullptr);
	}

	bool phoneToStr(UkrainianPhoneId phone, std::string& result)
	{
		switch (phone)
		{
		case UkrainianPhoneId::P_A:
			result = "A";
			break;
		case UkrainianPhoneId::P_B:
			result = "B";
			break;
		case UkrainianPhoneId::P_CH:
			result = "CH";
			break;
		case UkrainianPhoneId::P_D:
			result = "D";
			break;
		case UkrainianPhoneId::P_DZ:
			result = "DZ";
			break;
		case UkrainianPhoneId::P_DZH:
			result = "DZH";
			break;
		case UkrainianPhoneId::P_E:
			result = "E";
			break;
		case UkrainianPhoneId::P_F:
			result = "F";
			break;
		case UkrainianPhoneId::P_G:
			result = "G";
			break;
		case UkrainianPhoneId::P_H:
			result = "H";
			break;
		case UkrainianPhoneId::P_I:
			result = "I";
			break;
		case UkrainianPhoneId::P_J:
			result = "J";
			break;
		case UkrainianPhoneId::P_K:
			result = "K";
			break;
		case UkrainianPhoneId::P_KH:
			result = "KH";
			break;
		case UkrainianPhoneId::P_L:
			result = "L";
			break;
		case UkrainianPhoneId::P_M:
			result = "M";
			break;
		case UkrainianPhoneId::P_N:
			result = "N";
			break;
		case UkrainianPhoneId::P_O:
			result = "O";
			break;
		case UkrainianPhoneId::P_P:
			result = "P";
			break;
		case UkrainianPhoneId::P_R:
			result = "R";
			break;
		case UkrainianPhoneId::P_S:
			result = "S";
			break;
		case UkrainianPhoneId::P_SH:
			result = "SH";
			break;
		case UkrainianPhoneId::P_T:
			result = "T";
			break;
		case UkrainianPhoneId::P_TS:
			result = "TS";
			break;
		case UkrainianPhoneId::P_U:
			result = "U";
			break;
		case UkrainianPhoneId::P_V:
			result = "V";
			break;
		case UkrainianPhoneId::P_Y:
			result = "Y";
			break;
		case UkrainianPhoneId::P_Z:
			result = "Z";
			break;
		case UkrainianPhoneId::P_ZH:
			result = "ZH";
			break;
		default:
			return false;
		}
		return true;
	}

	UkrainianPhoneId phoneStrToId(const std::string& phoneStr, bool* parseSuccess)
	{
		if (parseSuccess != nullptr)
			*parseSuccess = true;

		if (phoneStr == "A")
			return UkrainianPhoneId::P_A;
		else if (phoneStr == "B")
			return UkrainianPhoneId::P_B;
		else if (phoneStr == "CH")
			return UkrainianPhoneId::P_CH;
		else if (phoneStr == "D")
			return UkrainianPhoneId::P_D;
		else if (phoneStr == "DZ")
			return UkrainianPhoneId::P_DZ;
		else if (phoneStr == "DZH")
			return UkrainianPhoneId::P_DZH;
		else if (phoneStr == "E")
			return UkrainianPhoneId::P_E;
		else if (phoneStr == "F")
			return UkrainianPhoneId::P_F;
		else if (phoneStr == "G")
			return UkrainianPhoneId::P_G;
		else if (phoneStr == "H")
			return UkrainianPhoneId::P_H;
		else if (phoneStr == "I")
			return UkrainianPhoneId::P_I;
		else if (phoneStr == "J")
			return UkrainianPhoneId::P_J;
		else if (phoneStr == "K")
			return UkrainianPhoneId::P_K;
		else if (phoneStr == "KH")
			return UkrainianPhoneId::P_KH;
		else if (phoneStr == "L")
			return UkrainianPhoneId::P_L;
		else if (phoneStr == "M")
			return UkrainianPhoneId::P_M;
		else if (phoneStr == "N")
			return UkrainianPhoneId::P_N;
		else if (phoneStr == "O")
			return UkrainianPhoneId::P_O;
		else if (phoneStr == "P")
			return UkrainianPhoneId::P_P;
		else if (phoneStr == "R")
			return UkrainianPhoneId::P_R;
		else if (phoneStr == "S")
			return UkrainianPhoneId::P_S;
		else if (phoneStr == "SH")
			return UkrainianPhoneId::P_SH;
		else if (phoneStr == "T")
			return UkrainianPhoneId::P_T;
		else if (phoneStr == "TS")
			return UkrainianPhoneId::P_TS;
		else if (phoneStr == "U")
			return UkrainianPhoneId::P_U;
		else if (phoneStr == "V")
			return UkrainianPhoneId::P_V;
		else if (phoneStr == "Y")
			return UkrainianPhoneId::P_Y;
		else if (phoneStr == "Z")
			return UkrainianPhoneId::P_Z;
		else if (phoneStr == "ZH")
			return UkrainianPhoneId::P_ZH;
		
		if (parseSuccess != nullptr)
			*parseSuccess = false;
		return UkrainianPhoneId::Nil;
	}

	bool pronuncToStr(const std::vector<UkrainianPhoneId>& pron, Pronunc& result)
	{
		std::string str;
		
		result.Phones.clear();
		for (int i = 0; i < pron.size(); ++i)
		{
			if (!phoneToStr(pron[i], str))
				return false; // can't convert some phone to string

			result.pushBackPhone(str);
		}
		return true;
	}

	// Returns true if conversion was successfull
	auto charToPhoneSimple(wchar_t letter, UkrainianPhoneId* phone) -> bool
	{
		struct CharToPhone
		{
			wchar_t Letter;
			UkrainianPhoneId Phone;
		};
		// the nil at right part of the map means, that mapping is more complex than one-one
		//wchar_t ukAlpha[] = L"àáâã´äåºæçè³¿éêëìíîïðñòóôõö÷øùüþÿ";
		static std::array<CharToPhone, 35> ukAlphaArray = {
			CharToPhone{ L'à', UkrainianPhoneId::P_A },
			CharToPhone{ Letter_B, UkrainianPhoneId::Nil },
			CharToPhone{ L'â', UkrainianPhoneId::P_V },
			CharToPhone{ Letter_H, UkrainianPhoneId::Nil },
			CharToPhone{ L'´', UkrainianPhoneId::P_G },
			CharToPhone{ Letter_D, UkrainianPhoneId::Nil },
			CharToPhone{ L'å', UkrainianPhoneId::P_E },
			CharToPhone{ Letter_JE, UkrainianPhoneId::Nil },
			CharToPhone{ Letter_ZH, UkrainianPhoneId::Nil },
			CharToPhone{ Letter_Z, UkrainianPhoneId::Nil },
			CharToPhone{ L'è', UkrainianPhoneId::P_Y },
			CharToPhone{ L'³', UkrainianPhoneId::P_I },
			CharToPhone{ Letter_JI, UkrainianPhoneId::Nil },
			CharToPhone{ L'é', UkrainianPhoneId::P_J },
			CharToPhone{ L'ê', UkrainianPhoneId::P_K },
			CharToPhone{ L'ë', UkrainianPhoneId::P_L },
			CharToPhone{ L'ì', UkrainianPhoneId::P_M },
			CharToPhone{ Letter_N, UkrainianPhoneId::Nil },
			CharToPhone{ L'î', UkrainianPhoneId::P_O },
			CharToPhone{ L'ï', UkrainianPhoneId::P_P },
			CharToPhone{ L'ð', UkrainianPhoneId::P_R },
			CharToPhone{ Letter_S, UkrainianPhoneId::Nil },
			CharToPhone{ Letter_T, UkrainianPhoneId::Nil },
			CharToPhone{ L'ó', UkrainianPhoneId::P_U },
			CharToPhone{ L'ô', UkrainianPhoneId::P_F },
			CharToPhone{ L'õ', UkrainianPhoneId::P_KH },
			CharToPhone{ Letter_TS, UkrainianPhoneId::P_TS },
			CharToPhone{ Letter_CH, UkrainianPhoneId::P_CH },
			CharToPhone{ Letter_SH, UkrainianPhoneId::P_SH },
			CharToPhone{ Letter_SHCH, UkrainianPhoneId::Nil },
			CharToPhone{ Letter_SoftSign, UkrainianPhoneId::Nil },
			CharToPhone{ Letter_JU, UkrainianPhoneId::Nil },
			CharToPhone{ Letter_JA, UkrainianPhoneId::Nil },
			CharToPhone{ Letter_Hyphen, UkrainianPhoneId::Nil },
			CharToPhone{ Letter_Apostrophe, UkrainianPhoneId::Nil },
		};

		static std::map<wchar_t, UkrainianPhoneId> charToPhoneMap;

		if (charToPhoneMap.empty())
		{
			for (size_t i = 0; i < ukAlphaArray.size(); ++i)
			{
				const CharToPhone& c = ukAlphaArray[i];
				//qDebug() << c.Letter << " " << (int)c.Letter;
				charToPhoneMap[c.Letter] = c.Phone;
			}
		}

		auto it = charToPhoneMap.find(letter);
		if (it != std::end(charToPhoneMap))
		{
			*phone = it->second;
			return true;
		}

		return false;
	}

	std::tuple<bool, const char*> spellWord(const std::wstring& word, std::vector<UkrainianPhoneId>& phones)
	{
		for (size_t i = 0; i < word.size(); ++i)
		{
			wchar_t letter = word[i];

			UkrainianPhoneId phone = UkrainianPhoneId::Nil;
			bool convOp = charToPhoneSimple(letter, &phone);
			if (!convOp)
				return std::make_tuple(false, "Unknown letter");

			if (phone != UkrainianPhoneId::Nil)
			{
				phones.push_back(phone);
				continue;
			}
			
			// letter is converted in more complicated way

			bool isFirstLetter = i == 0;
			bool isLastLetter = i + 1 == word.size();

			if (letter == Letter_B || letter == Letter_H || letter == Letter_D || letter == Letter_ZH || letter == Letter_Z)
			{
				if (letter == Letter_D)
				{
					if (isLastLetter)
					{
						phones.push_back(UkrainianPhoneId::P_D);
						continue;
					}
					else
					{
						wchar_t nextLetter = word[i + 1];
						if (nextLetter == Letter_Z)
						{
							phones.push_back(UkrainianPhoneId::P_DZ);
							i += 1; // skip next letter
							continue;
						}
						else if (nextLetter == Letter_ZH)
						{
							phones.push_back(UkrainianPhoneId::P_DZH);
							i += 1; // skip next letter
							continue;
						}
					}
				}
				if (letter == Letter_Z)
				{
					if (i + 1 < word.size()) // size(ZH)=1
					{
						// Z ZH -> ZH ZH
						// çæåð [ZH ZH E R]
						if (word[i + 1] == Letter_ZH)
						{
							// skip first T
							phones.push_back(UkrainianPhoneId::P_ZH);
							phones.push_back(UkrainianPhoneId::P_ZH);
							i += 1;
							continue;
						}
					}
					if (i + 2 < word.size()) // size(D ZH)=2
					{
						// Z D ZH -> ZH DZH
						// ç'¿çäæàþòü [Z J I ZH DZH A J U T]
						if (word[i + 1] == Letter_D && word[i + 2] == Letter_ZH)
						{
							// skip first T
							phones.push_back(UkrainianPhoneId::P_ZH);
							phones.push_back(UkrainianPhoneId::P_DZH);
							i += 2;
							continue;
						}
					}
				}

				// B->P, H->KH, D->T, ZH->SH, Z->S before unvoiced sound
				// B->P íåîáõ³äíî [N E O P KH I D N O]
				// H->KH äîïîìîãòè [D O P O M O KH T Y]
				// D->T øâèäêî [SH V Y T K O]
				// ZH->SH äóæ÷å [D U SH CH E]
				// Z->S áåçïåêè [B E S P E K A]
				bool beforeUnvoiced = false;
				if (!isLastLetter)
				{
					wchar_t nextLetter = word[i + 1];
					if (isUnvoicedCharUk(nextLetter))
						beforeUnvoiced = true;
					else
					{
						// check if the next letter is a soft sign and then the unvoiced consonant
						if (nextLetter == Letter_SoftSign && i + 2 < word.size())
						{
							wchar_t nextNextLetter = word[i + 2];
							if (isUnvoicedCharUk(nextNextLetter))
								beforeUnvoiced = true;
						}
					}
				}
				if (!beforeUnvoiced)
				{
					if (letter == Letter_B)
						phones.push_back(UkrainianPhoneId::P_B);
					else if (letter == Letter_H)
						phones.push_back(UkrainianPhoneId::P_H);
					else if (letter == Letter_D)
						phones.push_back(UkrainianPhoneId::P_D);
					else if (letter == Letter_ZH)
						phones.push_back(UkrainianPhoneId::P_ZH);
					else if (letter == Letter_Z)
						phones.push_back(UkrainianPhoneId::P_Z);
					else PG_Assert(false);
				}
				else
				{
					if (letter == Letter_B)
						phones.push_back(UkrainianPhoneId::P_P);
					else if (letter == Letter_H)
						phones.push_back(UkrainianPhoneId::P_KH);
					else if (letter == Letter_D)
						phones.push_back(UkrainianPhoneId::P_T);
					else if (letter == Letter_ZH)
						phones.push_back(UkrainianPhoneId::P_SH);
					else if (letter == Letter_Z)
						phones.push_back(UkrainianPhoneId::P_S);
					else PG_Assert(false);
				}
				continue;
			}
			else if (letter == Letter_JI)
			{
				// Rule: letter JI always converts as J and I
				phones.push_back(UkrainianPhoneId::P_J);
				phones.push_back(UkrainianPhoneId::P_I);
			}
			else if (letter == Letter_SHCH)
			{
				phones.push_back(UkrainianPhoneId::P_SH);
				phones.push_back(UkrainianPhoneId::P_CH);
			}
			else if (letter == Letter_JE || letter == Letter_JU || letter == Letter_JA)
			{
				bool doublePhone = false;
				if (isFirstLetter)
					doublePhone = true;
				else
				{
					wchar_t prevLetter = word[i - 1];
					bool prevVowel = isUkrainianVowel(prevLetter);
					if (prevVowel)
						doublePhone = true;
				}

				if (doublePhone)
				{
					// First letter:
					// ºâðåé [J E V R E J]
					// þíàê [J U N A K]
					// ÿáëóêî [J A B L U K O]
					// Previous letter is the vowel:
					// âçàºìíî [V Z A J E M N O]
					// íàñòîþ [N A S T O J U]
					// àáèÿê [A B Y J A K]
					phones.push_back(UkrainianPhoneId::P_J);
				}
				
				if (letter == Letter_JE)
				{
					// ñóòòºâî [S U T T E V O]
					phones.push_back(UkrainianPhoneId::P_E);
				}
				else if (letter == Letter_JU)
				{
					// îëåêñþê [O L E K S U K]
					// áóðþ [B U R U]
					phones.push_back(UkrainianPhoneId::P_U);
				}
				else if (letter == Letter_JA)
				{
					// áóðÿ [B U R A]
					// çîðÿíèé [Z O R A N Y J]
					phones.push_back(UkrainianPhoneId::P_A);
				}
				else
					PG_Assert(false, "Current letter=JE or JU or JA");
			}
			else if (letter == Letter_N)
			{
				if (i + 3 < word.size()) // size(T S T)=3
				{
					// N T S T -> N S T
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_S && word[i + 3] == Letter_T)
					{
						// skip first T
						phones.push_back(UkrainianPhoneId::P_N);
						phones.push_back(UkrainianPhoneId::P_S);
						phones.push_back(UkrainianPhoneId::P_T);
						i += 3;
						continue;
					}
				}
				if (i + 4 < word.size()) // size(T S 1 K)=4
				{
					// N T S 1 K -> N S1 K
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_S && word[i + 3] == Letter_SoftSign && word[i + 4] == Letter_K)
					{
						// skip first T
						phones.push_back(UkrainianPhoneId::P_N);
						phones.push_back(UkrainianPhoneId::P_S);
						phones.push_back(UkrainianPhoneId::P_K);
						i += 4;
						continue;
					}
				}
				phones.push_back(UkrainianPhoneId::P_N);
			}
			else if (letter == Letter_S)
			{
				if (i + 1 < word.size()) // size(SH)=1
				{
					// S SH -> SH SH
					// äîí³ñøè [D O N I SH SH Y]
					if (word[i + 1] == Letter_SH)
					{
						phones.push_back(UkrainianPhoneId::P_SH);
						phones.push_back(UkrainianPhoneId::P_SH);
						i += 1;
						continue;
					}
				}
				if (i + 2 < word.size()) // size(T D)=2
				{
					// S T D -> Z D
					// ø³ñòäåñÿò [SH I Z D E S A T]
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_D)
					{
						phones.push_back(UkrainianPhoneId::P_Z);
						phones.push_back(UkrainianPhoneId::P_D);
						i += 2;
						continue;
					}
				}
				// check STS1K group before STS group, because latter is inside the former
				if (i + 4 < word.size()) // size(T S 1 K)=4
				{
					// S T S 1 K -> S1 K
					// íàöèñòñüêî¿ [N A TS Y S1 K O J I]
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_S && word[i + 3] == Letter_SoftSign && word[i + 4] == Letter_K)
					{
						phones.push_back(UkrainianPhoneId::P_S);
						phones.push_back(UkrainianPhoneId::P_K);
						i += 4;
						continue;
					}
				}
				if (i + 2 < word.size()) // size(T S)=2
				{
					// S T S -> S S
					// ø³ñòñîò [SH I S S O T]
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_S)
					{
						phones.push_back(UkrainianPhoneId::P_S);
						phones.push_back(UkrainianPhoneId::P_S);
						i += 2;
						continue;
					}
				}
				if (i + 2 < word.size()) // size(T TS)=2
				{
					// S T TS -> S TS
					// â³äïóñòö³ [V I D P U S TS I]
					if (word[i + 1] == Letter_T && word[i + 2] == Letter_TS)
					{
						phones.push_back(UkrainianPhoneId::P_S);
						phones.push_back(UkrainianPhoneId::P_TS);
						i += 2;
						continue;
					}
				}
				phones.push_back(UkrainianPhoneId::P_S);
			}
			else if (letter == Letter_T)
			{
				if (i + 1 < word.size()) // size(S)=1
				{
					// T S -> TS
					// ï'ÿòñîò [P J A TS O T]
					if (word[i + 1] == Letter_S)
					{
						phones.push_back(UkrainianPhoneId::P_TS);
						i += 1;
						continue;
					}
				}
				if (i + 2 < word.size()) // size(1 S)=2
				{
					// T 1 S -> TS
					// òðèìàòèìåòüñÿ [T R Y M A T Y M E TS A]
					if (word[i + 1] == Letter_SoftSign && word[i + 2] == Letter_S)
					{
						phones.push_back(UkrainianPhoneId::P_TS);
						phones.push_back(UkrainianPhoneId::P_TS); // òö -> TS TS
						i += 2;
						continue;
					}
				}
				if (i + 1 < word.size()) // size(TS)=1
				{
					// T TS -> TS TS
					// êë³òö³ [K L I TS TS I]
					if (word[i + 1] == Letter_TS)
					{
						phones.push_back(UkrainianPhoneId::P_TS);
						phones.push_back(UkrainianPhoneId::P_TS);
						i += 1;
						continue;
					}
				}
				if (i + 1 < word.size()) // size(CH)=1
				{
					// T CH -> CH CH
					// îò÷å [O CH CH E]
					if (word[i + 1] == Letter_CH)
					{
						phones.push_back(UkrainianPhoneId::P_CH);
						phones.push_back(UkrainianPhoneId::P_CH);
						i += 1;
						continue;
					}
				}
				phones.push_back(UkrainianPhoneId::P_T);
			}
			else if (letter == Letter_SoftSign)
			{
				if (!isLastLetter)
				{
					wchar_t nextLetter = word[i + 1];
					if (nextLetter == Letter_JA)
					{
						// êîíüÿêó [K O N J A K]
						phones.push_back(UkrainianPhoneId::P_J);
						phones.push_back(UkrainianPhoneId::P_A);
						i += 1; // skip next letter
					}
					else if (nextLetter == Letter_JE)
					{
						// ìîñüº [M O S J E]
						phones.push_back(UkrainianPhoneId::P_J);
						phones.push_back(UkrainianPhoneId::P_E);
						i += 1; // skip next letter
					}
					else if (nextLetter == Letter_JU)
					{
						// íüþ [N J U]
						phones.push_back(UkrainianPhoneId::P_J);
						phones.push_back(UkrainianPhoneId::P_U);
						i += 1; // skip next letter
					}
					else
					{
						// ignore it
					}
				}
			}
			else if (letter == Letter_Apostrophe)
			{
				if (isLastLetter)
				{
					// apostrophe is the last char when the given word is a truncated part of some complete word
					// ignore it
				}
				else
				{
					wchar_t nextLetter = word[i + 1];
					if (nextLetter == Letter_JA)
					{
						// áóð'ÿí [B U R J A N]
						phones.push_back(UkrainianPhoneId::P_J);
						phones.push_back(UkrainianPhoneId::P_A);
						i += 1; // skip next letter
					}
					else if (nextLetter == Letter_JE)
					{
						// êàð'ºð [K A R J E R]
						phones.push_back(UkrainianPhoneId::P_J);
						phones.push_back(UkrainianPhoneId::P_E);
						i += 1; // skip next letter
					}
					else if (nextLetter == Letter_JU)
					{
						// êîìï'þòåð [K O M P J U T E R]
						phones.push_back(UkrainianPhoneId::P_J);
						phones.push_back(UkrainianPhoneId::P_U);
						i += 1; // skip next letter
					}
					else
					{
						// ignore it
					}
				}
			}
			else if (letter == Letter_Hyphen)
			{
				// ignore, soft sign has no pronunciation
			}
			else
			{
				PG_Assert(false && "Letter must be processed already");
			}
		}
		return std::make_tuple(true, nullptr);
	}

	//

	template <typename T>
	bool endsWith(wv::slice<T> items, wv::slice<T> suffix)
	{
		if (suffix.size() > items.size())
			return false; // suffix will not fit the items?

		size_t itemsStartInd = items.size() - suffix.size();
		for (int i = 0; i < suffix.size(); ++i)
		{
			if (suffix[i] == items[itemsStartInd + i])
				continue;
			return false;
		}
		return true;
	}
	template <typename T>
	bool startsWith(wv::slice<T> items, wv::slice<T> prefix)
	{
		if (prefix.size() > items.size())
			return false; // prefix will not fit the items?

		for (int i = 0; i < prefix.size(); ++i)
		{
			if (prefix[i] == items[i])
				continue;
			return false;
		}
		return true;
	}

	// Finds the length of the common prefix of two words.
	template <typename T>
	size_t commonPrefixSize(wv::slice<T> word, wv::slice<T> other)
	{
		size_t minSize = std::min(word.size(), other.size());

		for (size_t i = 0; i < minSize; ++i)
		{
			if (word[i] != other[i])
				return i;
		}
		return minSize;
	}

	struct SuffixEnd
	{
		std::wstring MatchSuffix;
		int TakeCharsCount;
		WordClass WordClass = WordClass::Verb;
		int UsedCount = 0;

		SuffixEnd(const std::wstring& matchSuffix, int takeCharsCount)
			: MatchSuffix(matchSuffix),
			TakeCharsCount(takeCharsCount) {}
		SuffixEnd(const std::wstring& matchSuffix, int takeCharsCount, PticaGovorun::WordClass wordClass)
			: MatchSuffix(matchSuffix),
			TakeCharsCount(takeCharsCount),
			WordClass(wordClass) {}
	};

	std::vector<SuffixEnd> sureSuffixes;
	std::map<std::wstring, std::wstring> participleSuffixToWord;
	std::map<std::wstring, std::wstring> participleSuffixToWord2;

	void ensureSureSuffixesInitialized()
	{
		// good: íàçèâàòè ³ñíóþòü
		// verb+t1
		// èòè
		static std::vector<SuffixEnd> sureSuffixesStatic = {
			{ std::wstring(    L"à"), 1, WordClass::Noun }, // ðó÷ê~à noun
			{ std::wstring(    L"à"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~à ñò~à
			{ std::wstring(    L"à"), 1, WordClass::Adjective }, // áëèæ÷~à adj
			{ std::wstring(  L"àëà"), 2 }, // ñêàçà~ëà
			{ std::wstring(L"óâàëà"), 4 }, // ³ñíó~âàëà àêòóàë³çó~âàëà
			{ std::wstring(L"þâàëà"), 4 }, // áàçàðþ~âàëà
			{ std::wstring(  L"èëà"), 2 }, // æè~ëà áè~ëà
			{ std::wstring(  L"³ëà"), 2 }, // áóðêîò³~ëà
			//{ std::wstring(  L"¿ëà"), 2 }, // áëàãîóñòðî¿~ëà
			{ std::wstring( L"î¿ëà"), 3 }, // áëàãîóñòðî~¿ëà
			{ std::wstring(  L"îëà"), 2 }, // áîðî~ëà
			{ std::wstring(  L"óëà"), 2 }, // áàìêíó~ëà
			{ std::wstring(  L"üìà"), 2, WordClass::Numeral}, // äåâ'ÿòü~ìà
			{ std::wstring(  L"îìà"), 3, WordClass::Numeral}, // äâ~îìà äåâ'ÿòü~îìà
			{ std::wstring(  L"³øà"), 3, WordClass::Adjective }, // àáñóðäí~³øà

			{ std::wstring(  L"àâ"), 1 }, // áóâà~â íàçèâà~â ìà~â âïëèâà~â
			{ std::wstring(L"óâàâ"), 3 }, // àêòóàë³çó~âàâ ³ñíó~âàâ
			{ std::wstring(L"þâàâ"), 3 }, // áàçàðþ~âàâ
			//{ std::wstring(  L"åâ"), 1 }, // ?? NOT äåðåâ~
			{ std::wstring(  L"èâ"), 1 }, // áåç÷åñòè~â áè~â
			{ std::wstring(  L"³â"), 1 }, // áóðêîò³~â
			{ std::wstring(  L"³â"), 2, WordClass::Noun }, // ôóðãîí~³â noun
			{ std::wstring(  L"¿â"), 2, WordClass::Noun }, // àãðàð³~¿â îäíîñòðî~¿â noun
			//{ std::wstring(  L"¿â"), 1 }, // îäíîñòðî¿~â áëàãîóñòðî¿~â
			{ std::wstring( L"³¿â"), 2 }, // áëàãîóñòðî~¿â
			{ std::wstring( L"î¿â"), 2 }, // áëàãîóñòðî~¿â verb
			{ std::wstring(  L"îâ"), 1 }, // áîðî~â (weird word, =áîðîâñÿ)
			{ std::wstring(  L"îâ"), 2, WordClass::Noun }, // öåðê~îâ
			{ std::wstring(  L"óâ"), 1 }, // áàìêíó~â

			{ std::wstring(        L"å"), 1 }, // áåð~å áàìêí~å
			{ std::wstring(        L"å"), 1, WordClass::Adjective }, // áëèæ÷~å áëèçüê~å
			{ std::wstring(        L"å"), 1, WordClass::Noun }, // ôóðãîí~å
			{ std::wstring(        L"å"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~å
			{ std::wstring(      L"èìå"), 2 }, // áðåñòè~ìå
			{ std::wstring(    L"àòèìå"), 4 }, // íàçèâà~òèìå
			{ std::wstring(    L"ÿòèìå"), 4 }, // ðîçìîâëÿ~òèìå
			{ std::wstring(  L"óâàòèìå"), 6 }, // ³ñíó~âà~òèìå àêòóàë³çó~âàòèìå
			{ std::wstring(  L"þâàòèìå"), 6 }, // áàçàðþ~âà~òèìå
			{ std::wstring(    L"èòèìå"), 4 }, // ðîáè~òèìå áè~òèìå
			{ std::wstring(    L"³òèìå"), 4 }, // áóðêîò³~òèìå
			//{ std::wstring(    L"¿òèìå"), 4 }, // ãíî¿~òèìå
			{ std::wstring(   L"î¿òèìå"), 5 }, // ãíî~¿òèìå
			{ std::wstring(    L"îòèìå"), 4 }, // áîðî~òèìå
			{ std::wstring(    L"óòèìå"), 4 }, // áëÿêíó~òèìå
			{ std::wstring(     L"àéòå"), 3 }, // íàçèâà~éòå âïëèâà~éòå
			{ std::wstring(     L"³éòå"), 3 }, // áóð³~éòå
			{ std::wstring(     L"îéòå"), 3 }, // áëàãîóñòðî~éòå
			{ std::wstring(     L"óéòå"), 3 }, // ó~éòå ³ñíó~éòå
			{ std::wstring(     L"þéòå"), 3 }, // äîð³âíþ~éòå
			//{ std::wstring(       L"òå"), 2 }, // áóðêîòü~òå
			{ std::wstring(      L"åòå"), 2 }, // áåðå~òå áàìêíå~òå
			//{ std::wstring(     L"ìåòå"), 4 }, // â³çü~ìåòå
			{ std::wstring(    L"èìåòå"), 4 }, // ³òè~ìåòå
			{ std::wstring(  L"àòèìåòå"), 6 }, // ³ñíó~âà~òèìåòå ìà~òèìåòå áðà-òèìåòå
			{ std::wstring(  L"èòèìåòå"), 6 }, // áåç÷åñòè~òèìåòå áè~òèìåòå
			{ std::wstring(  L"³òèìåòå"), 6 }, // áóðêîò³~òèìåòå
			//{ std::wstring(  L"¿òèìåòå"), 6 }, // ãíî¿~òèìåòå
			{ std::wstring(  L"î¿òèìåòå"), 7 }, // ãíî~¿òèìåòå
			{ std::wstring(  L"îòèìåòå"), 6 }, // áîðî~òèìåòå
			{ std::wstring(  L"óòèìåòå"), 6 }, // áëÿêíó~òèìåòå
			{ std::wstring(L"óâàòèìåòå"), 8 }, // àêòóàë³çó~âàòèìåòå
			{ std::wstring(L"þâàòèìåòå"), 8 }, // äîð³âíþ~âàòèìåòå
			{ std::wstring(    L"üìåòå"), 4 }, // â³çü~ìåòå
			{ std::wstring(     L"àºòå"), 3 }, // çíà~ºòå
			{ std::wstring(     L"³ºòå"), 3 }, // áóð³~ºòå
			{ std::wstring(     L"óºòå"), 3 }, // ³ñíó~ºòå
			{ std::wstring(     L"þºòå"), 3 }, // äîð³âíþ~ºòå
			{ std::wstring(     L"'ºòå"), 3 }, // á'~ºòå
			{ std::wstring(      L"èòå"), 2 }, // áóðêîòè~òå
			{ std::wstring(      L"³òå"), 2 }, // áåð³~òå áàìêí³~òå
			//{ std::wstring(      L"¿òå"), 2 }, // áëàãîóñòðî¿~òå
			{ std::wstring(     L"î¿òå"), 3 }, // áëàãîóñòðî~¿òå
			{ std::wstring(     L"èéòå"), 3 }, // áè~éòå
			{ std::wstring(      L"üòå"), 2 }, // áóðêîòü~òå
			{ std::wstring(      L"³øå"), 3, WordClass::Adjective }, // àáñóðäí~³øå
			{ std::wstring(      L"³øå"), 3, WordClass::Adverb }, // àçàðòí~³øå
			{ std::wstring( L"º"), 1, WordClass::Adjective }, // àâòîäîðîæí~º
			{ std::wstring(L"àº"), 1 }, // âïëèâà~º
			{ std::wstring(L"åº"), 2, WordClass::Adjective }, // áåçïîñàäêîâ~åº áàãàòåíüê~åº áëèçüê~åº adj
			{ std::wstring(L"³º"), 1 }, // áóð³~º
			{ std::wstring(L"óº"), 1 }, // ³ñíó~º
			{ std::wstring(L"þº"), 1 }, // äîð³âíþ~º
			{ std::wstring(L"'º"), 1, WordClass::Noun }, // ñ³ì'~º

			{ std::wstring(     L"è"), 1, WordClass::Noun }, // ðó÷ê~è áóðêí~è áåðåæ~è ðåêëàì~è noun
			{ std::wstring(     L"è"), 1, WordClass::Numeral }, // ø³ñòäåñÿò~è
			{ std::wstring(   L"àëè"), 2 }, // áóâà~ëè
			{ std::wstring( L"óâàëè"), 4 }, // àêòóàë³çó~âàëè ³ñíó~âàëè
			{ std::wstring( L"þâàëè"), 4 }, // áàçàðþ~âàëè (soft U, not J-U)
			{ std::wstring(   L"èëè"), 2 }, // áè~ëè
			{ std::wstring(   L"³ëè"), 2 }, // áóðêîò³~ëè
			//{ std::wstring(   L"¿ëè"), 2 }, // áëàãîóñòðî¿~ëè
			{ std::wstring(  L"î¿ëè"), 3 }, // áëàãîóñòðî~¿ëè
			{ std::wstring(   L"îëè"), 2 }, // áîðî~ëè
			{ std::wstring(   L"óëè"), 2 }, // áàìêíó~ëè
			{ std::wstring(   L"àìè"), 3, WordClass::Numeral }, // ÷îòèðìàñò~àìè
			{ std::wstring(   L"èìè"), 2 }, // âåëèêè~ìè
			{ std::wstring(   L"èìè"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èìè
			//{ std::wstring( L"îâèìè"), 5 }, // adjective
			{ std::wstring(   L"àìè"), 3, WordClass::Noun }, // ðåêëàì~àìè ðóê~àìè ðó÷ê~àìè ôóðãîí~àìè
			{ std::wstring(   L"ÿìè"), 3, WordClass::Noun }, // àãðàð³~ÿìè îáñëóãîâóâàíí~ÿìè
			//{ std::wstring(  L"îÿìè"), 2 }, // è~ëè noun
			{ std::wstring(  L"'ÿìè"), 3, WordClass::Noun }, // ñ³ì'~ÿìè
			{ std::wstring(   L"àòè"), 2 }, // âïëèâà~òè áðà~òè
			{ std::wstring( L"þâàòè"), 4 }, // áàçàðþ~âàòè (soft U)
			{ std::wstring(   L"èòè"), 2 }, // æè~òè àðêàíè~òè áè~òè
			{ std::wstring(   L"³òè"), 2 }, // áóðêîò³~òè
			//{ std::wstring(   L"¿òè"), 2 }, // áëàãîóñòðî¿~òè
			{ std::wstring(  L"î¿òè"), 3 }, // áëàãîóñòðî~¿òè
			{ std::wstring(   L"îòè"), 2 }, // áîðî~òè
			{ std::wstring(   L"óòè"), 2 }, // áàìêíó~òè
			{ std::wstring( L"óâàòè"), 4 }, // àêòóàë³çó~âàòè
			{ std::wstring(   L"à÷è"), 2, WordClass::VerbalAdverb }, // áóðëà÷à~÷è âàíòàæà~÷è
			{ std::wstring(   L"ó÷è"), 2, WordClass::VerbalAdverb }, // áåðó~÷è áåðåæó~÷è
			{ std::wstring(   L"þ÷è"), 3, WordClass::VerbalAdverb }, // áîð~þ÷è ?
			//{ std::wstring(  L"àþ÷è"), 3, WordClass::VerbalAdverb }, // íåçâàæà~þ÷è áóâà~þ÷è
			//{ std::wstring(  L"³þ÷è"), 3, WordClass::VerbalAdverb }, // áóð³~þ÷è áàéäóæ³~þ÷è
			//{ std::wstring(  L"óþ÷è"), 3, WordClass::VerbalAdverb }, // ó~þ÷è ³ñíó~þ÷è
			//{ std::wstring(  L"þþ÷è"), 3, WordClass::VerbalAdverb }, // äîð³âíþ~þ÷è
			//{ std::wstring(  L"'þ÷è"), 3, WordClass::VerbalAdverb }, // á'~þ÷è
			{ std::wstring(   L"ÿ÷è"), 3, WordClass::VerbalAdverb }, // áóðêîò~ÿ÷è âèõîä~ÿ÷è áóä~ÿ÷è
			{ std::wstring(  L"îÿ÷è"), 3, WordClass::VerbalAdverb }, // ãíî~ÿ÷è
			{ std::wstring(  L"àâøè"), 3, WordClass::VerbalAdverb }, // ìà~âøè çíà~âøè áðà~âøè
			{ std::wstring(  L"³âøè"), 3, WordClass::VerbalAdverb }, // áóðêîò³~âøè áóáîò³~âøè
			//{ std::wstring(  L"¿âøè"), 3, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøè
			{ std::wstring( L"î¿âøè"), 4, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøè
			{ std::wstring(  L"óâøè"), 3, WordClass::VerbalAdverb }, // áàìêíó~âøè áó~âøè
			{ std::wstring(  L"èâøè"), 3, WordClass::VerbalAdverb }, // áåç÷åñòè~âøè áè~âøè
			{ std::wstring(  L"îâøè"), 3, WordClass::VerbalAdverb }, // áîðî~âøè
			{ std::wstring(L"þâàâøè"), 5, WordClass::VerbalAdverb }, // ³äîð³âíþ~âàâøè àñîö³þ~âàâøè
			{ std::wstring(L"óâàâøè"), 5, WordClass::VerbalAdverb }, // ³ñíó~âàâøè àêòóàë³çó~âàâøè áó~âàâøè

			{ std::wstring(   L"³"), 1, WordClass::Noun }, // òàê~³ óêðà¿í~³
			{ std::wstring(   L"³"), 1, WordClass::Adjective }, // áëèæ÷~³ áëèçüê~³
			{ std::wstring(   L"³"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³
			{ std::wstring(L"îºâ³"), 3, WordClass::Noun }, // îäíîñòðî~ºâ³ noun
			{ std::wstring( L"åâ³"), 3, WordClass::Noun }, // êíÿç~åâ³
			{ std::wstring( L"ºâ³"), 3, WordClass::Noun }, // àãðàð³~ºâ³
			{ std::wstring( L"îâ³"), 3, WordClass::Noun }, // ôóðãîí~îâ³ noun
			{ std::wstring( L"³ø³"), 3, WordClass::Adjective }, // àáñóðäí~³ø³ adj

			{ std::wstring( L"¿"), 1, WordClass::Adjective }, // á³ëîøè~¿
			{ std::wstring( L"¿"), 1, WordClass::Noun }, // îäíîñòðî~¿
			{ std::wstring(L"å¿"), 1, WordClass::Noun }, // ìóçå~¿
			{ std::wstring(L"º¿"), 2, WordClass::Pronoun }, // ö³~º¿
			{ std::wstring(L"è¿"), 1, WordClass::Noun }, // êîëîìè~¿
			{ std::wstring(L"³¿"), 2, WordClass::Adjective }, // áàãàòåíüê~³¿ áåçïîñàäêîâ~³¿ adj
			{ std::wstring(L"³¿"), 1, WordClass::Noun }, // ïîëîíiçàöi~¿ òåëåïîðòàö³~¿ ë³í³~¿
			{ std::wstring(L"î¿"), 2, WordClass::Adjective }, // çàìîæí~î¿
			{ std::wstring(L"î¿"), 1, WordClass::Noun }, // îäíîñòðî~¿
			{ std::wstring(L"î¿"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~î¿
			{ std::wstring(L"ó¿"), 1, WordClass::Noun }, // áóðæó~¿
			{ std::wstring(L"þ¿"), 1 }, // áðþ~¿
			{ std::wstring(L"ÿ¿"), 1, WordClass::Noun }, // õàçÿ~¿

			{ std::wstring(      L"àé"), 1 }, // íàçèâà~é âïëèâà~é
			{ std::wstring(      L"åé"), 2, WordClass::Noun }, // ñ³ì~åé
			{ std::wstring(      L"èé"), 2, WordClass::Adjective }, // òåïë~èé áàãàòåíüê~èé adj 
			{ std::wstring(      L"èé"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èé
			{ std::wstring(      L"³é"), 2, WordClass::Adjective }, // óêðà¿íñüê~³é îñòàíí~³é àâòîäîðîæí~³é adj
			{ std::wstring(      L"³é"), 1, WordClass::Noun }, // îäíîñòð³~é îðãàí³çàö³~é noun
			{ std::wstring(      L"³é"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³é
			{ std::wstring(      L"³é"), 2, WordClass::Pronoun }, // ¿õí~³é
			{ std::wstring(      L"¿é"), 2, WordClass::Adjective }, // áåçêðà~¿é
			{ std::wstring(      L"îé"), 1 }, // áëàãîóñòðî~é
			{ std::wstring(      L"óé"), 1 }, // ³ñíó~é
			{ std::wstring(      L"þé"), 1 }, // äîð³âíþ~é
			{ std::wstring(    L"³ëèé"), 3, WordClass::Participle }, // áóð³~ëèé áàéäóæ³~ëèé ÈÉ
			{ std::wstring(    L"àíèé"), 3, WordClass::Participle }, // à~íèé áðà~íèé ÈÉ
			{ std::wstring(  L"îâàíèé"), 5, WordClass::Participle }, // àêòóàë³çî~âàíèé àí³ã³ëüî~âàíèé àñîö³éî~âàíèé
			{ std::wstring(  L"óâàíèé"), 5, WordClass::Participle }, // àðåøòîâó~âàíèé
			{ std::wstring(  L"þâàíèé"), 5, WordClass::Participle }, // ï³äîçðþ~âàíèé
			{ std::wstring(    L"åíèé"), 3, WordClass::Participle }, // áåç÷åùå~íèé áåðåæå~íèé âàíòàæå~íèé ÈÉ
			{ std::wstring(    L"ºíèé"), 4, WordClass::Adjective }, // áëàãîóñòðî~ºíèé ãíî~ºíèé çàñïîêî~ºíèé ÈÉ
			{ std::wstring(   L"îºíèé"), 4, WordClass::Adjective }, // áëàãîóñòðî~ºíèé ãíî~ºíèé çàñïîêî~ºíèé
			{ std::wstring(    L"èòèé"), 3, WordClass::Participle }, // áè~òèé
			{ std::wstring(    L"îòèé"), 3, WordClass::Participle }, // áîðî~òèé
			{ std::wstring(    L"óòèé"), 3, WordClass::Participle }, // áîâòíó~òèé
			{ std::wstring(    L"à÷èé"), 3, WordClass::Participle }, // áóðëà÷à~÷èé âàíòàæà~÷èé
			{ std::wstring(    L"ó÷èé"), 3, WordClass::Participle}, // áåðó~÷èé áàìêíó~÷èé áåðåæó~÷èé áóäó~÷èé
			{ std::wstring(    L"þ÷èé"), 4, WordClass::Participle }, // compound áîð~þ÷èé
			//{ std::wstring(   L"àþ÷èé"), 4, WordClass::Participle }, // âïëèâà~þ÷èé
			//{ std::wstring(   L"³þ÷èé"), 4, WordClass::Participle }, // áóð³~þ÷èé áàéäóæ³~þ÷èé
			//{ std::wstring(   L"óþ÷èé"), 4 , WordClass::Participle}, // ³ñíó~þ÷èé
			//{ std::wstring(   L"þþ÷èé"), 4, WordClass::Participle }, // äîð³âíþ~þ÷èé
			//{ std::wstring(   L"'þ÷èé"), 4, WordClass::Participle }, // á'~þ÷èé
			{ std::wstring(    L"ÿ÷èé"), 4, WordClass::Participle }, // áóðêîò~ÿ÷èé áóä~ÿ÷èé
			{ std::wstring(   L"îÿ÷èé"), 4, WordClass::Participle }, // ãíî~ÿ÷èé
			{ std::wstring(     L"øèé"), 3, WordClass::Adjective }, // áàãàò~øèé
			{ std::wstring(   L"àâøèé"), 4, WordClass::Participle }, // áðà~âøèé
			{ std::wstring( L"óâàâøèé"), 6, WordClass::Participle }, // ³ñíó~âàâøèé àêòóàë³çó~âàâøèé áó~âàâøèé
			{ std::wstring( L"þâàâøèé"), 6, WordClass::Participle }, // áàçàðþ~âàâøèé àñîö³þ~âàâøèé
			{ std::wstring(   L"èâøèé"), 4, WordClass::Participle }, // áåç÷åñòè~âøèé áè~âøèé
			{ std::wstring(   L"³âøèé"), 4, WordClass::Participle }, // áóðêîò³~âøèé áóáîò³~âøèé
			//{ std::wstring(   L"¿âøèé"), 4 }, // áëàãîóñòðî¿~âøèé
			{ std::wstring(  L"î¿âøèé"), 5, WordClass::Participle }, // áëàãîóñòðî~¿âøèé
			{ std::wstring(   L"îâøèé"), 4, WordClass::Participle }, // áîðî~âøèé
			{ std::wstring(   L"óâøèé"), 4, WordClass::Participle }, // áàìêíó~âøèé áó~âøèé
			{ std::wstring(    L"³øèé"), 4, WordClass::Adjective }, // àáñóðäí~³øèé

			{ std::wstring(      L"àì"), 2, WordClass::Noun }, // ôóðãîí~àì
			{ std::wstring(      L"àì"), 2, WordClass::Numeral }, // ÷îòèðüîìñò~àì
			{ std::wstring(      L"åì"), 1 }, // áåð~åì áàìêí~åì
			{ std::wstring(      L"åì"), 2, WordClass::Noun }, // ñàáîòàæ~åì ERROR: áóðîçåì~ àíàõòåì~(àíàõòåìà)
			{ std::wstring(    L"èìåì"), 3 }, // áðåñòè~ìåì
			{ std::wstring(  L"àòèìåì"), 5 }, // áðà~òèìåì
			{ std::wstring(  L"îòèìåì"), 5 }, // áîðî~òèìåì
			{ std::wstring(L"óâàòèìåì"), 7 }, // ³ñíó~âà~òèìåì àêòóàë³çó~âàòèìåì
			{ std::wstring(L"þâàòèìåì"), 7 }, // áàçàðþ~âà~òèìåì
			{ std::wstring(  L"èòèìåì"), 5 }, // ðîáè~òèìåì áè~òèìåì
			{ std::wstring(  L"³òèìåì"), 5 }, // òåðï³~òèìåì ?
			//{ std::wstring( L"¿òèìåì"), 5 }, // ãíî¿~òèìåì
			{ std::wstring( L"î¿òèìåì"), 6 }, // ãíî~¿òèìåì
			{ std::wstring(  L"óòèìåì"), 5 }, // áëÿêíó~òèìåì
			{ std::wstring(  L"ÿòèìåì"), 5 }, // ðîçìîâë~ÿòèìåì
			{ std::wstring(      L"ºì"), 2, WordClass::Noun }, // composite
			{ std::wstring(      L"ºì"), 2 }, // composite
			//{ std::wstring(     L"àºì"), 2 }, // çíà~ºì
			//{ std::wstring(     L"åºì"), 2 }, // ïðîìåòå~ºì noun
			//{ std::wstring(     L"³ºì"), 2 }, // êðèòåð³~ºì noun
			//{ std::wstring(     L"îºì"), 2 }, // îäíîñòðî~ºì
			//{ std::wstring(     L"óºì"), 2 }, // ÷ó~ºì
			//{ std::wstring(     L"þºì"), 2 }, // áàçàðþ~ºì
			//{ std::wstring(     L"'ºì"), 2 }, // á'~ºì
			{ std::wstring(      L"èì"), 1 }, // áóðêîòè~ì
			{ std::wstring(      L"èì"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èì
			{ std::wstring(      L"³ì"), 1 }, // áàìêí³~ì áåð³~ì áåðåæ³~ì
			{ std::wstring(      L"³ì"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³ì
			//{ std::wstring(      L"¿ì"), 1 }, // áëàãîóñòðî¿~ì
			{ std::wstring(     L"î¿ì"), 2 }, // áëàãîóñòðî~¿ì
			{ std::wstring(      L"îì"), 2, WordClass::Noun }, // ôóðãîí~îì
			{ std::wstring(      L"îì"), 2, WordClass::Numeral }, // äâ~îì îäèíàäöÿòü~îì
			{ std::wstring(      L"ÿì"), 2, WordClass::Noun }, // compound ëþä~ÿì îáñëóãîâóâàíí~ÿì
			//{ std::wstring(     L"îÿì"), 2, WordClass::Noun }, // îäíîñòðî~ÿì
			//{ std::wstring(     L"'ÿì"), 2, WordClass::Noun }, // ñ³ì'~ÿì

			{ std::wstring(        L"î"), 1 }, // ðó÷ê~î
			{ std::wstring(        L"î"), 1, WordClass::Adverb }, // àçàðòí~î adverb
			{ std::wstring(        L"î"), 1, WordClass::Numeral }, // ñò~î
			{ std::wstring(      L"îãî"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îãî
			{ std::wstring(     L"üîãî"), 3, WordClass::Pronoun }, // ¿õíü~îãî
			{ std::wstring(      L"àëî"), 2 }, // áðàêóâà~ëî
			{ std::wstring(    L"óâàëî"), 4 }, // ³ñíó~âàëî àêòóàë³çó~âàëî
			{ std::wstring(    L"þâàëî"), 4 }, // áàçàðþ~âàëî (soft U)
			{ std::wstring(      L"èëî"), 2 }, // æè~ëî áè~ëî
			{ std::wstring(      L"³ëî"), 2 }, // áóðêîò³~ëî
			//{ std::wstring(      L"¿ëî"), 2 }, // áëàãîóñòðî¿~ëî
			{ std::wstring(     L"î¿ëî"), 3 }, // áëàãîóñòðî~¿ëî
			{ std::wstring(      L"îëî"), 2 }, // áîðî~ëî
			{ std::wstring(      L"óëî"), 2 }, // áàìêíó~ëî
			//{ std::wstring(       L"ìî"), 2 }, // áóðêîòü~ìî áåç÷åñòü~ìî
			{ std::wstring(      L"åìî"), 2 }, // áåðå~ìî áàìêíå~ìî
			{ std::wstring(      L"èìî"), 2 }, // áóðêîòè~ìî
			{ std::wstring(  L"àòèìåìî"), 6 }, // ³ñíó~âà~òèìåìî ìà~òèìåìî
			{ std::wstring(  L"èòèìåìî"), 6 }, // æè~òèìåìî áè~òèìåìî
			{ std::wstring(  L"³òèìåìî"), 6 }, // áóðêîò³~òèìåìî
			//{ std::wstring(  L"¿òèìåìî"), 6 }, // ãíî¿~òèìåìî
			{ std::wstring( L"î¿òèìåìî"), 7 }, // ãíî~¿òèìåìî
			{ std::wstring(  L"îòèìåìî"), 6 }, // áîðî~òèìåìî
			{ std::wstring(  L"óòèìåìî"), 6 }, // áëÿêíó~òèìåìî
			{ std::wstring(L"óâàòèìåìî"), 8 }, // àêòóàë³çó~âàòèìåìî
			{ std::wstring(L"þâàòèìåìî"), 8 }, // äîð³âíþ~âàòèìåìî
			{ std::wstring(     L"àºìî"), 3 }, // çíà~ºìî
			{ std::wstring(     L"³ºìî"), 3 }, // áóð³~ºìî
			{ std::wstring(     L"óºìî"), 3 }, // ³ñíó~ºìî
			{ std::wstring(     L"þºìî"), 3 }, // äîð³âíþ~ºìî
			{ std::wstring(     L"'ºìî"), 3 }, // á'~ºìî
			{ std::wstring(      L"³ìî"), 2 }, // áåð³~ìî áàìêí³~ìî áåðåæ³~ìî
			//{ std::wstring(      L"¿ìî"), 2 }, // áëàãîóñòðî¿~ìî
			{ std::wstring(     L"î¿ìî"), 3 }, // áëàãîóñòðî~¿ìî
			//{ std::wstring(      L"éìî"), 3 }, // NOT êëåé*éìî
			{ std::wstring(     L"àéìî"), 3 }, // íàçèâà~éìî ðóøà~éìî
			//{ std::wstring(     L"åéìî"), 3 }, // no words
			{ std::wstring(     L"èéìî"), 3 }, // áóð³~éìî áè~éìî
			{ std::wstring(     L"³éìî"), 3 }, // áóð³~éìî
			{ std::wstring(     L"îéìî"), 3 }, // áëàãîóñòðî~éìî
			{ std::wstring(     L"óéìî"), 3 }, // ³ñíó~éìî àêòóàë³çó~éìî
			{ std::wstring(     L"þéìî"), 3 }, // äîð³âíþ~éìî
			{ std::wstring(     L"ÿéìî"), 3 }, // ïîð³âíÿ~éìî
			{ std::wstring(      L"üìî"), 2 }, // áóðêîòü~ìî áåç÷åñòü~ìî
			{ std::wstring(      L"åðî"), 3, WordClass::Numeral }, // äåâ'ÿò~åðî
			
			{ std::wstring(      L"ó"), 1, WordClass::Noun }, // noun, ðó÷ê~ó áåð~ó áóðêî÷~ó áåç÷åù~ó áåðåæ~ó
			{ std::wstring(      L"ó"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~ó
			//{ std::wstring(     L"ìó"), 2 }, // not usable (ôîð*ì~ó)
			//{ std::wstring(    L"àìó"), 2 }, // not usable (ñà*ì~ó)
			{ std::wstring(    L"ºìó"), 2, WordClass::Pronoun }, // ñâîº~ìó
			{ std::wstring(    L"èìó"), 2 }, // áåðåã*òè~ìó
			//{ std::wstring(   L"òèìó"), 4 }, // áåðåã*òèìó; ã*òèìó is too rare to use
			{ std::wstring(  L"àòèìó"), 4 }, // áðà~òèìó
			{ std::wstring(  L"èòèìó"), 4 }, // áåç÷åñòè~òèìó áè~òèìó
			{ std::wstring(  L"³òèìó"), 4 }, // áóðêîò³~òèìó
			//{ std::wstring(  L"¿òèìó"), 4 }, // ãíî¿~òèìó
			{ std::wstring( L"î¿òèìó"), 5 }, // ãíî~¿òèìó
			{ std::wstring(  L"îòèìó"), 4 }, // áîðî~òèìó
			{ std::wstring(  L"ñòèìó"), 4 }, // áðåñ~òèìó
			{ std::wstring(  L"óòèìó"), 4 }, // áëÿêíó~òèìó
			{ std::wstring(L"óâàòèìó"), 6 }, // ³ñíó~âàòèìó àêòóàë³çó~âàòèìó
			{ std::wstring(L"þâàòèìó"), 6 }, // áàçàðþ~âàòèìó
			{ std::wstring(    L"îìó"), 3, WordClass::Adjective }, // áþäæåòí~îìó adj
			{ std::wstring(    L"îìó"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îìó
			//{ std::wstring(    L"óìó"), 2 }, // not usable (ðîçó*ì~ó)

			{ std::wstring(  L"àõ"), 2, WordClass::Noun }, // ðó÷ê~àõ ôóðãîí~àõ
			{ std::wstring(  L"àõ"), 2, WordClass::Numeral }, // ÷îòèðüîõñò~àõ
			{ std::wstring(  L"èõ"), 2, WordClass::Adjective }, // áþäæåòí~èõ
			{ std::wstring(  L"èõ"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èõ
			{ std::wstring(  L"îõ"), 2, WordClass::Numeral }, // äåâ'ÿòü~îõ äâ~îõ
			{ std::wstring(  L"ÿõ"), 2, WordClass::Noun }, // compound
			//{ std::wstring( L"îÿõ"), 2, WordClass::Noun }, // îäíîñòðî~ÿõ
			//{ std::wstring(  L"ÿõ"), 2, WordClass::Noun }, // îáñëóãîâóâàíí~ÿõ
			//{ std::wstring( L"'ÿõ"), 2, WordClass::Noun }, // ñ³ì'~ÿõ

			{ std::wstring(      L"åø"), 2 }, // áåð~åø áàìêí~åø
			{ std::wstring(    L"èìåø"), 3 }, // áðåñòè~ìåø
			{ std::wstring(  L"àòèìåø"), 5 }, // áðà~òèìåø íàçèâà~òèìåø
			{ std::wstring(  L"èòèìåø"), 5 }, // áåç÷åñòè~òèìåø áè~òèìåø
			{ std::wstring(  L"³òèìåø"), 5 }, // áóðêîò³~òèìåø
			//{ std::wstring(  L"¿òèìåø"), 5 }, // ãíî¿~òèìåø
			{ std::wstring( L"î¿òèìåø"), 6 }, // ãíî~¿òèìåø
			{ std::wstring(  L"îòèìåø"), 5 }, // áîðî~òèìåø
			{ std::wstring(  L"óòèìåø"), 5 }, // áëÿêíó~òèìåø
			//{ std::wstring(L"èâàòèìåø"), 7 }, // no words with such suffix
			{ std::wstring(L"óâàòèìåø"), 7 }, // àêòóàë³çó~âàòèìåø ³ñíó~âàòèìåø
			{ std::wstring(L"þâàòèìåø"), 7 }, // áàçàðþ~âàòèìåø (soft U)
			{ std::wstring(     L"àºø"), 2 }, // à~ºø ìà~ºø
			{ std::wstring(     L"³ºø"), 2 }, // áóð³~ºø
			{ std::wstring(     L"óºø"), 2 }, // ³ñíó~ºø
			{ std::wstring(     L"þºø"), 2 }, // äîð³âíþ~ºø
			{ std::wstring(     L"'ºø"), 2 }, // á'~ºø
			{ std::wstring(      L"èø"), 1 }, // áóðêîò~èø
			{ std::wstring(      L"³ø"), 2, WordClass::Adverb }, // àçàðòí~³ø
			//{ std::wstring(      L"¿ø"), 1 }, // áëàãîóñòðî¿~ø
			{ std::wstring(     L"î¿ø"), 2 }, // áëàãîóñòðî~¿ø

			{ std::wstring(      L"àëàñü"), 4 }, // íàçèâà~ëàñü
			{ std::wstring(    L"óâàëàñü"), 6 }, // àêòóàë³çó~âàëàñü
			{ std::wstring(    L"þâàëàñü"), 6 }, // àí³ã³ëþ~âàëàñü
			{ std::wstring(      L"èëàñü"), 4 }, // áðèæè~ëàñü áè~ëàñü
			//{ std::wstring(      L"¿ëàñü"), 4 }, // áëàãîóñòðî¿~ëàñü
			{ std::wstring(     L"î¿ëàñü"), 5 }, // áëàãîóñòðî~¿ëàñü
			{ std::wstring(      L"îëàñü"), 4 }, // áîðî~ëàñü
			{ std::wstring(      L"óëàñü"), 4 }, // áåõíó~ëºìîñÿàñü
			{ std::wstring(     L"îÿëàñü"), 5 }, // áî~ÿëàñü
			{ std::wstring(       L"àâñü"), 3 }, // íàçèâà~âñü
			{ std::wstring(     L"óâàâñü"), 5 }, // àêòóàë³çó~âàâñü
			{ std::wstring(     L"þâàâñü"), 5 }, // àí³ã³ëþ~âàâñü
			{ std::wstring(       L"èâñü"), 3 }, // áåç÷åñòè~âñü áè~âñü
			//{ std::wstring(       L"¿âñü"), 3 }, // áëàãîóñòðî¿~âñü
			{ std::wstring(      L"î¿âñü"), 4 }, // áëàãîóñòðî~¿âñü
			{ std::wstring(       L"îâñü"), 3 }, // áîðî~âñü
			{ std::wstring(       L"óâñü"), 3 }, // áåõíó~âñü
			{ std::wstring(       L"ÿâñü"), 4 }, // áî~ÿâñü
			// { std::wstring(        L"åñü"), 2 }, // no words
			{ std::wstring(   L"òèìåòåñü"), 8 }, // áåðåã~òèìåòåñü
			{ std::wstring(  L"àòèìåòåñü"), 8 }, // íàçèâà~òèìåòåñü
			//{ std::wstring(  L"¿òèìåòåñü"), 7 }, // ãíî¿~òèìåòåñü
			{ std::wstring( L"î¿òèìåòåñü"), 9 }, // ãíî~¿òèìåòåñü
			{ std::wstring(  L"îòèìåòåñü"), 8 }, // áîðî~òèìåòåñü
			{ std::wstring(L"óâàòèìåòåñü"), 10 }, // àêòóàë³çó~âàòèìåòåñü
			{ std::wstring(L"þâàòèìåòåñü"), 10 }, // àí³ã³ëþ~âàòèìåòåñü
			{ std::wstring(  L"èòèìåòåñü"), 8 }, // áðèæè~òèìåòåñü áè~òèìåòåñü
			{ std::wstring(  L"ÿòèìåòåñü"), 9 }, // áî~ÿòèìåòåñü
			{ std::wstring(      L"åòåñü"), 4 }, // áåðå~òåñü
			{ std::wstring(      L"ºòåñü"), 5 }, // á'~ºòåñü
			{ std::wstring(     L"óºòåñü"), 5 }, // àêòóàë³çó~ºòåñü
			{ std::wstring(      L"èòåñü"), 4 }, // áåç÷åñòè~òåñü
			{ std::wstring(      L"³òåñü"), 4 }, // áåð³~òåñü áðèæ³~òåñü äèâ³~òåñü
			//{ std::wstring(      L"¿òåñü"), 4 }, // áëàãîóñòðî¿~òåñü
			{ std::wstring(     L"î¿òåñü"), 5 }, // áëàãîóñòðî~¿òåñü áî~¿òåñü
			{ std::wstring(     L"àéòåñü"), 5 }, // íàçèâà~éòåñü
			{ std::wstring(     L"èéòåñü"), 5 }, // áè~éòåñü
			{ std::wstring(     L"³éòåñü"), 5 }, // á³~éòåñü
			{ std::wstring(     L"îéòåñü"), 5 }, // áëàãîóñòðî~éòåñü
			{ std::wstring(     L"óéòåñü"), 5 }, // àêòóàë³çó~éòåñü
			{ std::wstring(     L"þéòåñü"), 5 }, // àí³ã³ëþ~éòåñü
			{ std::wstring(     L"àºòåñü"), 5 }, // à~ºòåñü íàçèâà~ºòåñü
			{ std::wstring(     L"þºòåñü"), 5 }, // àí³ã³ëþ~ºòåñü
			{ std::wstring(      L"üòåñü"), 4 }, // áàãðÿíü~òåñü
			{ std::wstring(        L"èñü"), 2, WordClass::Verb }, // áåðè~ñü
			{ std::wstring(        L"èñü"), 2, WordClass::VerbalAdverb }, // áåð³ãøè~ñü
			{ std::wstring(      L"àëèñü"), 4 }, // íàçèâà~ëèñü
			{ std::wstring(    L"þâàëèñü"), 6 }, // àí³ã³ëþ~âàëèñü
			{ std::wstring(      L"èëèñü"), 4 }, // áðèæè~ëèñü áè~ëèñü
			//{ std::wstring(      L"¿ëèñü"), 4 }, // áëàãîóñòðî¿~ëèñü
			{ std::wstring(     L"î¿ëèñü"), 5 }, // áëàãîóñòðî~¿ëèñü
			{ std::wstring(      L"îëèñü"), 4 }, // áîðî~ëèñü
			{ std::wstring(      L"óëèñü"), 4 }, // áåõíó~ëèñü
			{ std::wstring(    L"óâàëèñü"), 6 }, // àêòóàë³çó~âàëèñü
			{ std::wstring(      L"ÿëèñü"), 5 }, // áî~ÿëèñü
			{ std::wstring(      L"àòèñü"), 4 }, // áðà~òèñü
			{ std::wstring(    L"óâàòèñü"), 6 }, // àêòóàë³çó~âàòèñü
			{ std::wstring(    L"þâàòèñü"), 6 }, // àí³ã³ëþ~âàòèñü
			{ std::wstring(      L"èòèñü"), 4 }, // áðèæè~òèñü áè~òèñü
			//{ std::wstring(      L"¿òèñü"), 4 }, // áëàãîóñòðî¿~òèñü
			{ std::wstring(     L"î¿òèñü"), 5 }, // áëàãîóñòðî~¿òèñü
			{ std::wstring(      L"îòèñü"), 4 }, // áîðî~òèñü
			{ std::wstring(      L"óòèñü"), 4 }, // áåõíó~òèñü
			{ std::wstring(      L"ÿòèñü"), 5 }, // áî~ÿòèñü
			{ std::wstring(      L"à÷èñü"), 4, WordClass::VerbalAdverb }, // áðèæà~÷èñü âàíòàæà~÷èñü
			{ std::wstring(      L"ó÷èñü"), 4, WordClass::VerbalAdverb }, // áåðó~÷èñü
			{ std::wstring(      L"þ÷èñü"), 5, WordClass::VerbalAdverb }, // compound
			//{ std::wstring(     L"àþ÷èñü"), 5, WordClass::VerbalAdverb }, // íàìàãà~þ÷èñü
			//{ std::wstring(     L"óþ÷èñü"), 5, WordClass::VerbalAdverb }, // äèâó~þ÷èñü
			//{ std::wstring(     L"þþ÷èñü"), 5, WordClass::VerbalAdverb }, // àí³ã³ëþ~þ÷èñü
			//{ std::wstring(      L"þ÷èñü"), 5, WordClass::VerbalAdverb }, // áîðþ~÷èñü
			//{ std::wstring(     L"'þ÷èñü"), 5, WordClass::VerbalAdverb }, // á'~þ÷èñü
			{ std::wstring(      L"ÿ÷èñü"), 5, WordClass::VerbalAdverb }, // áî~ÿ÷èñü ãíî~ÿ÷èñü äèâë~ÿ÷èñü áóä~ÿ÷èñü
			{ std::wstring(     L"îÿ÷èñü"), 5, WordClass::VerbalAdverb }, // ãíî~ÿ÷èñü áî~ÿ÷èñü

			{ std::wstring(     L"àâøèñü"), 5, WordClass::VerbalAdverb }, // íàçèâà~âøèñü áðà~âøèñü
			{ std::wstring(     L"îâøèñü"), 5, WordClass::VerbalAdverb }, // áîðî~âøèñü
			{ std::wstring(   L"þâàâøèñü"), 7, WordClass::VerbalAdverb }, // àí³ã³ëþ~âàâøèñü àñîö³þ~âàâøèñü
			{ std::wstring(   L"óâàâøèñü"), 7, WordClass::VerbalAdverb }, // àêòóàë³çó~âàâøèñü
			{ std::wstring(     L"èâøèñü"), 5, WordClass::VerbalAdverb }, // áðèæè~âøèñü áè~âøèñü
			//{ std::wstring(     L"¿âøèñü"), 5, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøèñü
			{ std::wstring(    L"î¿âøèñü"), 6, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøèñü
			{ std::wstring(     L"óâøèñü"), 5, WordClass::VerbalAdverb }, // áåõíó~âøèñü çâåðíó~âøèñü
			{ std::wstring(     L"ÿâøèñü"), 5, WordClass::VerbalAdverb }, // âçÿ~âøèñü
			{ std::wstring(    L"îÿâøèñü"), 6, WordClass::VerbalAdverb }, // áî~ÿâøèñü
			{ std::wstring(       L"àéñü"), 3 }, // çíà~éñü íàçèâà~éñü
			{ std::wstring(       L"èéñü"), 3 }, // á³~éñü áè~éñü
			{ std::wstring(       L"³éñü"), 3 }, // á³~éñü
			{ std::wstring(       L"îéñü"), 3 }, // áëàãîóñòðî~éñü
			{ std::wstring(       L"óéñü"), 3 }, // àêòóàë³çó~éñü
			{ std::wstring(       L"þéñü"), 3 }, // àí³ã³ëþ~éñü
			//{ std::wstring(        L"îñü"), 2 }, // no actual words (all are LOS or MOS) êîãî~ñü ??
			{ std::wstring(      L"àëîñü"), 5 }, // áðà~ëîñü íàçèâà~ëîñü ñòà~ëîñü
			{ std::wstring(    L"þâàëîñü"), 6 }, // àí³ã³ëþ~âàëîñü
			{ std::wstring(      L"èëîñü"), 4 }, // áðèæè~ëîñü áè~ëîñü
			//{ std::wstring(      L"¿ëîñü"), 4 }, // áëàãîóñòðî¿~ëîñü
			{ std::wstring(     L"î¿ëîñü"), 5 }, // áëàãîóñòðî~¿ëîñü
			{ std::wstring(      L"îëîñü"), 4 }, // áîðî~ëîñü
			{ std::wstring(      L"óëîñü"), 4 }, // áåõíó-ëîñü
			{ std::wstring(    L"óâàëîñü"), 6 }, // àêòóàë³çó~âàëîñü
			{ std::wstring(      L"ÿëîñü"), 5 }, // áî~ÿëîñü
			// { std::wstring(       L"ìîñü"), 4 }, // 
			{ std::wstring(      L"åìîñü"), 4 }, // áåðåæå~ìîñü áåðå~ìîñü
			{ std::wstring(    L"èìåìîñü"), 6 }, // áåðåãòè~ìåìîñü (we can't split áåðåã*òèìåìîñü)
			{ std::wstring(  L"àòèìåìîñü"), 8 }, // áðà~òèìåìîñü íàçè~âà~òèìåìîñü
			{ std::wstring(  L"èòèìåìîñü"), 8 }, // áðèæè~òèìåìîñü áè~òèìåìîñü
			//{ std::wstring(  L"¿òèìåìîñü"), 8 }, // ãíî¿~òèìåìîñü
			{ std::wstring(  L"î¿òèìåìîñü"), 9 }, // ãíî~¿òèìåìîñü
			{ std::wstring(  L"îòèìåìîñü"), 8 }, // áîðî~òèìåìîñü
			{ std::wstring(L"óâàòèìåìîñü"), 10 }, // àêòóàë³çó~âàòèìåìîñü
			{ std::wstring(L"þâàòèìåìîñü"), 10 }, // àí³ã³ëþ~âàòèìåìîñü
			{ std::wstring(  L"ÿòèìåìîñü"), 9 }, // áî~ÿòèìåìîñü
			{ std::wstring(      L"ºìîñü"), 5 }, // á'~ºìîñü
			//{ std::wstring(     L"àºìîñü"), 5 }, // ñïîä³âà~ºìîñü
			//{ std::wstring(     L"èºìîñü"), 5 }, // ïîøè~ºìîñü
			//{ std::wstring(     L"³ºìîñü"), 5 }, // íàä³~ºìîñü
			//{ std::wstring(     L"îºìîñü"), 5 }, // ïîáîþ~ºìîñü
			//{ std::wstring(     L"óºìîñü"), 5 }, // êîðèñòó~ºìîñü àêòóàë³çó~ºìîñü
			//{ std::wstring(     L"þºìîñü"), 5 }, // âèñëîâëþ~ºìîñü àí³ã³ëþ~ºìîñü
			//{ std::wstring(     L"ÿºìîñü"), 5 }, // ñïèíÿ~ºìîñü
			//{ std::wstring(     L"'ºìîñü"), 5 }, // â³ä³á'~ºìîñü á'~ºìîñü
			{ std::wstring(      L"èìîñü"), 4 }, // áåç÷åñòè~ìîñü
			//{ std::wstring(      L"¿ìîñü"), 4 }, // áî¿~ìîñü áëàãîóñòðî¿~ìîñü
			{ std::wstring(      L"³ìîñü"), 4 }, // áåðåæ³~ìîñü áåð³~ìîñü äèâ³~ìîñü
			{ std::wstring(      L"¿ìîñü"), 5 }, // compound
			//{ std::wstring(     L"è¿ìîñü"), 5 }, // ÷è~¿ìîñü
			//{ std::wstring(     L"î¿ìîñü"), 5 }, // áî~¿ìîñü áëàãîóñòðî~¿ìîñü
			{ std::wstring(      L"éìîñü"), 5 }, // compound
			//{ std::wstring(     L"àéìîñü"), 5 }, // íàçèâà~éìîñü
			//{ std::wstring(     L"èéìîñü"), 5 }, // áè~éìîñü
			//{ std::wstring(     L"³éìîñü"), 5 }, // á³~éìîñü
			//{ std::wstring(     L"îéìîñü"), 5 }, // áëàãîóñòðî~éìîñü
			//{ std::wstring(     L"óéìîñü"), 5 }, // àêòóàë³çó~éìîñü
			//{ std::wstring(     L"þéìîñü"), 5 }, // àí³ã³ëþ~éìîñü
			{ std::wstring(      L"üìîñü"), 4 }, // áåç÷åñòü~ìîñü
			{ std::wstring(        L"óñü"), 2 }, // áåðó~ñü áåç÷åùó~ñü
			{ std::wstring(      L"èìóñü"), 4 }, // áåðåãòè~ìóñü
			{ std::wstring(    L"àòèìóñü"), 6 }, // íàçèâà~òèìóñü
			{ std::wstring(    L"¿òèìóñü"), 7 }, // compound
			//{ std::wstring(   L"î¿òèìóñü"), 7 }, // ãíî~¿òèìóñü
			{ std::wstring(    L"îòèìóñü"), 6 }, // áîðî~òèìóñü
			{ std::wstring(  L"óâàòèìóñü"), 8 }, // àêòóàë³çó~âàòèìóñü
			{ std::wstring(  L"þâàòèìóñü"), 8 }, // àí³ã³ëþ~âàòèìóñü
			{ std::wstring(    L"èòèìóñü"), 6 }, // áðèæè~òèìóñü áè~òèìóñü
			{ std::wstring(    L"ÿòèìóñü"), 7 }, // áî~ÿòèìóñü

			{ std::wstring(        L"þñü"), 3 }, // äèâë~þñü àðêàí~þñü æóð~þñü
			{ std::wstring(       L"àþñü"), 3 }, // íàçèâà~þñü
			{ std::wstring(       L"³þñü"), 3 }, // ðîçóì³~þñü
			{ std::wstring(       L"èþñü"), 3 }, // ÷è~þñü
			{ std::wstring(       L"îþñü"), 3 }, // áî~þñü(?or zero) áëàãîóñòðî~þñü ERROR: ãíî~þñü (need to keep letter 'o')
			{ std::wstring(       L"óþñü"), 3 }, // àêòóàë³çó~þñü
			{ std::wstring(       L"ºþñü"), 4 }, // ÷è~ºþñü
			{ std::wstring(       L"þþñü"), 3 }, // àí³ã³ëþ~þñü õâèëþ~þñü
			{ std::wstring(       L"ÿþñü"), 3 }, // ïîìèëÿ~þñü
			{ std::wstring(       L"'þñü"), 3 }, // á'~þñü

			{ std::wstring(       L"àòü"), 2 }, // áðà~òü áóðëà÷à~òü
			{ std::wstring(     L"óâàòü"), 4 }, // ³ñíó~âàòü
			{ std::wstring(     L"þâàòü"), 4 }, // äîð³âíþ~âàòü
			{ std::wstring(       L"èòü"), 2 }, // áåç÷åñòè~òü áè~òü
			{ std::wstring(       L"³òü"), 3 }, // áåð~³òü áóðêîò~³òü áàìêí~³òü
			//{ std::wstring(       L"¿òü"), 3 }, // áëàãîóñòðî¿~òü
			{ std::wstring(      L"î¿òü"), 3 }, // áëàãîóñòðî~¿òü
			{ std::wstring(       L"îòü"), 3 }, // áîð~îòü ïîë~îòü êîë~îòü ê³ã~îòü
			{ std::wstring(       L"óòü"), 3 }, // áåð~óòü áàìêí~óòü
			{ std::wstring(     L"èìóòü"), 4 }, // áðåñòè~ìóòü
			{ std::wstring(   L"àòèìóòü"), 6 }, // à~òèìóòü ³ñíóâà~òèìóòü
			{ std::wstring(   L"èòèìóòü"), 6 }, // æè~òèìóòü áè~òèìóòü
			{ std::wstring(   L"³òèìóòü"), 6 }, // áóðêîò³~òèìóòü
			//{ std::wstring(   L"¿òèìóòü"), 6 }, // ãíî¿~òèìóòü
			{ std::wstring(  L"î¿òèìóòü"), 7 }, // ãíî~¿òèìóòü
			{ std::wstring(   L"îòèìóòü"), 6 }, // áîðî~òèìóòü
			{ std::wstring(   L"óòèìóòü"), 6 }, // áëÿêíó~òèìóòü
			{ std::wstring( L"óâàòèìóòü"), 8 }, // àêòóàë³çó~âàòèìóòü
			{ std::wstring( L"þâàòèìóòü"), 8 }, // äîð³âíþ~âàòèìóòü
			{ std::wstring(       L"þòü"), 3 }, // áîð~þòü
			{ std::wstring(      L"àþòü"), 3 }, // ââàæà~þòü âïëèâà~þòü
			{ std::wstring(      L"³þòü"), 3 }, // áóð³~þòü
			{ std::wstring(      L"óþòü"), 3 }, // ³ñíó~þòü
			{ std::wstring(      L"þþòü"), 3 }, // äîð³âíþ~þòü
			{ std::wstring(      L"'þòü"), 3 }, // äîð³âíþ~þòü á'~þòü
			{ std::wstring(       L"ÿòü"), 3 }, // áóðêîò~ÿòü ãíî~ÿòü
			{ std::wstring(      L"îÿòü"), 3 }, // áëàãîóñòðî~ÿòü

			{ std::wstring( L"þ"), 1 }, // àðêàí~þ
			{ std::wstring( L"þ"), 1 , WordClass::Noun}, // áåççì³íí³ñò~þ
			{ std::wstring(L"àþ"), 1 }, // íàçèâà~þ
			{ std::wstring(L"ºþ"), 2, WordClass::Noun }, // ñ³ì'~ºþ
			{ std::wstring(L"³þ"), 1 }, // áóð³~þ
			{ std::wstring(L"îþ"), 1 }, // ãíî~þ
			{ std::wstring(L"îþ"), 2, WordClass::Noun }, // áëàãîóñòð~îþ çì³í~îþ
			{ std::wstring(L"îþ"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îþ
			{ std::wstring(L"óþ"), 1 }, // ³ñíó~þ àêòóàë³çó~þ
			{ std::wstring(L"þþ"), 1 }, // äîð³íþ~þ
			{ std::wstring(L"'þ"), 1, WordClass::Noun }, // ñ³ì'~þ

			{ std::wstring(          L"ÿ"), 1, WordClass::Adjective }, // äîðîæí~ÿ
			{ std::wstring(          L"ÿ"), 1, WordClass::Noun }, // îáñëóãîâóâàíí~ÿ
			{ std::wstring(         L"àÿ"), 2, WordClass::Adjective }, // áåçïîñàäêîâ~àÿ áëèçüê~àÿ adj
			{ std::wstring(         L"ÿÿ"), 2, WordClass::Adjective }, // àâòîäîðîæí~ÿÿ
			{ std::wstring(         L"'ÿ"), 1, WordClass::Noun }, // ñ³ì'~ÿ
			// { std::wstring(         L"ñÿ"), 2 }, // can't detach unvoiced 'Sya'
			//{ std::wstring(        L"àñÿ"), 2 }, // no words
			{ std::wstring(       L"ëàñÿ"), 4 }, // áåðåã~ëàñÿ
			{ std::wstring(      L"àëàñÿ"), 4 }, // íàçèâà~ëàñÿ
			{ std::wstring(      L"îëàñÿ"), 4 }, // áîðî~ëàñÿ
			{ std::wstring(    L"óâàëàñÿ"), 6 }, // àêòóàë³çó~âàëàñÿ
			{ std::wstring(    L"þâàëàñÿ"), 6 }, // àí³ã³ëþ~âàëàñÿ
			{ std::wstring(      L"èëàñÿ"), 4 }, // áðèæè~ëàñÿ áè~ëàñÿ
			//{ std::wstring(      L"¿ëàñÿ"), 4 }, // áëàãîóñòðî¿~ëàñÿ
			{ std::wstring(     L"î¿ëàñÿ"), 5 }, // áëàãîóñòðî~¿ëàñÿ
			{ std::wstring(      L"óëàñÿ"), 4 }, // áåõíó~ëàñÿ
			{ std::wstring(      L"ÿëàñÿ"), 5 }, // áî~ÿëàñÿ
			{ std::wstring(       L"àâñÿ"), 3 }, // íàçèâà~âñÿ áðà~âñÿ
			{ std::wstring(     L"óâàâñÿ"), 5 }, // àêòóàë³çó~âàâñÿ
			{ std::wstring(     L"þâàâñÿ"), 5 }, // àí³ã³ëþ~âàâñÿ
			{ std::wstring(       L"èâñÿ"), 3 }, // áðèæè~âñÿ áè~âñÿ
			//{ std::wstring(       L"¿âñÿ"), 3 }, // áëàãîóñòðî¿~âñÿ
			{ std::wstring(      L"î¿âñÿ"), 4 }, // áëàãîóñòðî~¿âñÿ
			{ std::wstring(       L"îâñÿ"), 3 }, // áîðî~âñÿ
			{ std::wstring(       L"óâñÿ"), 3 }, // áåõíó~âñÿ
			{ std::wstring(       L"ÿâñÿ"), 3 }, // áîÿ~âñÿ
			//{ std::wstring(       L"³ãñÿ"), 3 }, // áåð³ãñ~ÿ (áåð is too common)
			{ std::wstring(      L"åòåñÿ"), 4 }, // áåðå~òåñÿ áåðåæå~òåñÿ
			{ std::wstring(    L"èìåòåñÿ"), 6 }, // áåðåãòè~ìåòåñÿ
			{ std::wstring(  L"àòèìåòåñÿ"), 8 }, // íàçèâà~òèìåòåñÿ
			{ std::wstring(L"óâàòèìåòåñÿ"), 10 }, // àêòóàë³çó~âàòèìåòåñÿ
			{ std::wstring(L"þâàòèìåòåñÿ"), 10 }, // àí³ã³ëþ~âàòèìåòåñÿ
			{ std::wstring(  L"èòèìåòåñÿ"), 8 }, // áðèæè~òèìåòåñÿ áè~òèìåòåñÿ
			//{ std::wstring(  L"¿òèìåòåñÿ"), 8 }, // ãíî¿~òèìåòåñÿ
			{ std::wstring( L"î¿òèìåòåñÿ"), 9 }, // ãíî~¿òèìåòåñÿ
			{ std::wstring(  L"îòèìåòåñÿ"), 8 }, // áîðî~òèìåòåñÿ
			{ std::wstring(  L"ÿòèìåòåñÿ"), 9 }, // áî~ÿòèìåòåñÿ
			{ std::wstring(      L"ºòåñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºòåñÿ"), 5 }, // çàáèðà~ºòåñÿ íàçèâà~ºòåñÿ
			//{ std::wstring(     L"èºòåñÿ"), 5 }, // âøè~ºòåñÿ
			//{ std::wstring(     L"³ºòåñÿ"), 5 }, // ðîçóì³~ºòåñÿ
			//{ std::wstring(     L"óºòåñÿ"), 5 }, // àêòóàë³çó~ºòåñÿ
			//{ std::wstring(     L"þºòåñÿ"), 5 }, // àí³ã³ëþ~ºòåñÿ
			//{ std::wstring(     L"ÿºòåñÿ"), 5 }, // ïîìèëÿ~ºòåñÿ
			//{ std::wstring(     L"'ºòåñÿ"), 5 }, // á'~ºòåñÿ
			{ std::wstring(      L"èòåñÿ"), 4 }, // áðèæè~òåñÿ
			{ std::wstring(      L"³òåñÿ"), 4 }, // áåð³~òåñÿ äèâ³~òåñÿ
			//{ std::wstring(      L"¿òåñÿ"), 4 }, // áî¿~òåñÿ áëàãîóñòðî¿~òåñÿ
			{ std::wstring(     L"î¿òåñÿ"), 5 }, // áî~¿òåñÿ áëàãîóñòðî~¿òåñÿ
			{ std::wstring(      L"éòåñÿ"), 5 }, // compound
			//{ std::wstring(     L"àéòåñÿ"), 5 }, // íàçèâà~éòåñÿ
			//{ std::wstring(     L"èéòåñÿ"), 5 }, // áè~éòåñÿ
			//{ std::wstring(     L"³éòåñÿ"), 5 }, // á³~éòåñÿ
			//{ std::wstring(     L"îéòåñÿ"), 5 }, // áëàãîóñòðî~éòåñÿ
			//{ std::wstring(     L"óéòåñÿ"), 5 }, // àêòóàë³çó~éòåñÿ
			//{ std::wstring(     L"þéòåñÿ"), 5 }, // àí³ã³ëþ~éòåñÿ
			{ std::wstring(      L"üòåñÿ"), 4 }, // àðêàíü~òåñÿ
			{ std::wstring(        L"èñÿ"), 3, WordClass::Verb }, // áåðè~ñÿ äèâè~ñÿ áåðåæ~èñÿ
			{ std::wstring(        L"èñÿ"), 3, WordClass::VerbalAdverb }, // áåð³ãø~èñÿ
			{ std::wstring(      L"àëèñÿ"), 4 }, // íàçèâà~ëèñÿ
			{ std::wstring(    L"óâàëèñÿ"), 6 }, // àêòóàë³çó~âàëèñÿ
			{ std::wstring(    L"þâàëèñÿ"), 6 }, // àí³ã³ëþ~âàëèñÿ
			{ std::wstring(      L"èëèñÿ"), 4 }, // áðèæè~ëèñÿ áè~ëèñÿ
			//{ std::wstring(      L"¿ëèñÿ"), 4 }, // áëàãîóñòðî¿~ëèñÿ
			{ std::wstring(     L"î¿ëèñÿ"), 5 }, // áëàãîóñòðî~¿ëèñÿ
			{ std::wstring(      L"îëèñÿ"), 5 }, // áîðî~ëèñÿ
			{ std::wstring(      L"óëèñÿ"), 5 }, // áåõíó~ëèñÿ
			{ std::wstring(      L"ÿëèñÿ"), 5 }, // áîÿ~ëèñÿ
			{ std::wstring(      L"àòèñÿ"), 4 }, // íàçèâà~òèñÿ
			{ std::wstring(    L"óâàòèñÿ"), 6 }, // àêòóàë³çó~âàòèñÿ
			{ std::wstring(    L"þâàòèñÿ"), 6 }, // àí³ã³ëþ~âàòèñÿ
			{ std::wstring(      L"èòèñÿ"), 4 }, // áðèæè~òèñÿ áè~òèñÿ
			{ std::wstring(      L"îòèñÿ"), 4 }, // áîðî~òèñÿ
			//{ std::wstring(      L"¿òèñÿ"), 4 }, // áëàãîóñòðî¿~òèñÿ
			{ std::wstring(     L"î¿òèñÿ"), 5 }, // áëàãîóñòðî~¿òèñÿ
			{ std::wstring(      L"óòèñÿ"), 4 }, // áåõíó~òèñÿ
			{ std::wstring(      L"ÿòèñÿ"), 4 }, // áî~ÿòèñÿ
			{ std::wstring(     L"àâøèñÿ"), 5, WordClass::VerbalAdverb }, // íàçèâà~âøèñÿ áðà~âøèñÿ
			{ std::wstring(     L"îâøèñÿ"), 5, WordClass::VerbalAdverb }, // áîðî~âøèñÿ
			{ std::wstring(   L"óâàâøèñÿ"), 7, WordClass::VerbalAdverb }, // àêòóàë³çó~âàâøèñÿ
			{ std::wstring(   L"þâàâøèñÿ"), 7, WordClass::VerbalAdverb }, // àí³ã³ëþ~âàâøèñÿ àñîö³þ~âàâøèñÿ
			{ std::wstring(     L"èâøèñÿ"), 5, WordClass::VerbalAdverb }, // áåç÷åñòè~âøèñÿ áè~âøèñÿ
			//{ std::wstring(     L"¿âøèñÿ"), 5, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøèñÿ
			{ std::wstring(    L"î¿âøèñÿ"), 6, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøèñÿ
			{ std::wstring(     L"óâøèñÿ"), 5, WordClass::VerbalAdverb }, // áîâòíó~âøèñÿ çâåðíó~âøèñÿ

			{ std::wstring(        L"éñÿ"), 3, WordClass::Participle }, // compound
			//{ std::wstring(       L"àéñÿ"), 3, WordClass::Participle }, // àéñÿ íàçèâà~éñÿ
			//{ std::wstring(       L"èéñÿ"), 3, WordClass::Participle }, // áåð³ãøè~éñÿ áè~éñÿ
			//{ std::wstring(       L"³éñÿ"), 3, WordClass::Participle }, // á³~éñÿ
			//{ std::wstring(       L"îéñÿ"), 3, WordClass::Participle }, // áëàãîóñòðî~éñÿ
			//{ std::wstring(       L"óéñÿ"), 3, WordClass::Participle }, // àêòóàë³çó~éñÿ
			//{ std::wstring(       L"þéñÿ"), 3, WordClass::Participle }, // àí³ã³ëþ~éñÿ
			{ std::wstring(    L"àâøèéñÿ"), 6, WordClass::Participle }, // áðà~âøèéñÿ
			{ std::wstring(  L"óâàâøèéñÿ"), 8, WordClass::Participle }, // àêóòàë³çó~âàâøèéñÿ
			{ std::wstring(  L"þâàâøèéñÿ"), 8, WordClass::Participle }, // àí³ã³ëþ~âàâøèéñÿ àñîö³þ~âàâøèéñÿ
			{ std::wstring(    L"èâøèéñÿ"), 6, WordClass::Participle }, // áðèæè~âøèéñÿ áè~âøèéñÿ
			//{ std::wstring(    L"¿âøèéñÿ"), 6 }, // áëàãîóñòðî¿~âøèéñÿ
			{ std::wstring(   L"î¿âøèéñÿ"), 7, WordClass::Participle  }, // áëàãîóñòðî~¿âøèéñÿ
			{ std::wstring(    L"îâøèéñÿ"), 6, WordClass::Participle }, // áîðî~âøèéñÿ
			{ std::wstring(    L"óâøèéñÿ"), 6, WordClass::Participle }, // áåõíó~âøèéñÿ
			{ std::wstring(    L"ÿâøèéñÿ"), 7, WordClass::Participle  }, // áî~ÿâøèéñÿ
			{ std::wstring(       L"åìñÿ"), 3 }, // áåðå~ìñÿ áåðåæå~ìñÿ çâåðíå~ìñÿ
			{ std::wstring(     L"èìåìñÿ"), 5 }, // áåðåãòè~ìåìñÿ
			{ std::wstring(       L"ºìñÿ"), 4 }, // compound
			//{ std::wstring(      L"àºìñÿ"), 4 }, // íàçèâà~ºìñÿ
			//{ std::wstring(      L"óºìñÿ"), 4 }, // àêòóàë³çó~ºìñÿ
			//{ std::wstring(      L"þºìñÿ"), 4 }, // àí³ã³ëþ~ºìñÿ
			//{ std::wstring(      L"'ºìñÿ"), 4 }, // á'~ºìñÿ
			{ std::wstring(   L"àòèìåìñÿ"), 7 }, // áðà~òèìåìñÿ
			{ std::wstring(   L"èòèìåìñÿ"), 7 }, // áðèæè~òèìåìñÿ áè~òèìåìñÿ
			//{ std::wstring(   L"¿òèìåìñÿ"), 7 }, // ãíî¿~òèìåìñÿ
			{ std::wstring(  L"î¿òèìåìñÿ"), 8 }, // ãíî~¿òèìåìñÿ
			{ std::wstring(   L"îòèìåìñÿ"), 7 }, // áîðî~òèìåìñÿ
			{ std::wstring( L"óâàòèìåìñÿ"), 9 }, // àêòóàë³çó~âàòèìåìñÿ
			{ std::wstring( L"þâàòèìåìñÿ"), 9 }, // àí³ã³ëþ~âàòèìåìñÿ
			{ std::wstring(   L"ÿòèìåìñÿ"), 8 }, // áî~ÿòèìåìñÿ
			{ std::wstring(       L"èìñÿ"), 3 }, // áðèæè~ìñÿ
			//{ std::wstring(       L"¿ìñÿ"), 3 }, // áëàãîóñòðî¿~ìñÿ
			{ std::wstring(      L"î¿ìñÿ"), 4 }, // áëàãîóñòðî~¿ìñÿ
			//{ std::wstring(        L"îñÿ"), 2 }, // no words á³éìî~ñÿ
			{ std::wstring(       L"ëîñÿ"), 4 }, // áåðåã~ëîñÿ
			{ std::wstring(      L"àëîñÿ"), 4 }, // íàçèâà~ëîñÿ
			{ std::wstring(    L"óâàëîñÿ"), 6 }, // àêòóàë³çó~âàëîñÿ
			{ std::wstring(    L"þâàëîñÿ"), 6 }, // àí³ã³ëþ~âàëîñÿ
			{ std::wstring(      L"åëîñÿ"), 4 }, // äîâå~ëîñÿ
			{ std::wstring(      L"èëîñÿ"), 4 }, // áðèæè~ëîñÿ áè~ëîñÿ
			//{ std::wstring(      L"¿ëîñÿ"), 4 }, // áëàãîóñòðî¿~ëîñÿ
			{ std::wstring(     L"î¿ëîñÿ"), 5 }, // áëàãîóñòðî~¿ëîñÿ
			{ std::wstring(      L"îëîñÿ"), 4 }, // áîðî~ëîñÿ
			{ std::wstring(      L"óëîñÿ"), 4 }, // áåõíó~ëîñÿ
			{ std::wstring(      L"ÿëîñÿ"), 5 }, // áî~ÿëîñÿ
			{ std::wstring(       L"ìîñÿ"), 4 }, // typo:ïîêâàï~ìîñÿ
			{ std::wstring(      L"àìîñÿ"), 4 }, // ïîäà~ìîñÿ
			{ std::wstring(      L"åìîñÿ"), 4 }, // áåðå~ìîñÿ ïîâåðíå~ìîñÿ
			{ std::wstring(    L"èìåìîñÿ"), 6 }, // áåðåãòè~ìåìîñÿ
			{ std::wstring(  L"àòèìåìîñÿ"), 8 }, // íàçèâà~òèìåìîñÿ
			{ std::wstring(L"óâàòèìåìîñÿ"), 10 }, // àêòóàë³çó~âàòèìåìîñÿ
			{ std::wstring(L"þâàòèìåìîñÿ"), 10 }, // àí³ã³ëþ~âàòèìåìîñÿ
			{ std::wstring(  L"èòèìåìîñÿ"), 8 }, // áðèæè~òèìåìîñÿ áè~òèìåìîñÿ
			//{ std::wstring(  L"¿òèìåìîñÿ"), 8 }, // ãíî¿~òèìåìîñÿ
			{ std::wstring( L"î¿òèìåìîñÿ"), 9 }, // ãíî~¿òèìåìîñÿ
			{ std::wstring(  L"îòèìåìîñÿ"), 8 }, // áîðî~òèìåìîñÿ
			{ std::wstring(  L"ÿòèìåìîñÿ"), 8 }, // áîÿ~òèìåìîñÿ
			{ std::wstring(      L"ºìîñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºìîñÿ"), 5 }, // ä³çíà~ºìîñÿ íàçèâà~ºìîñÿ
			//{ std::wstring(     L"óºìîñÿ"), 5 }, // àêòóàë³çó~ºìîñÿ
			//{ std::wstring(     L"þºìîñÿ"), 5 }, // àí³ã³ëþ~ºìîñÿ
			//{ std::wstring(     L"'ºìîñÿ"), 5 }, // á'~ºìîñÿ
			{ std::wstring(      L"èìîñÿ"), 4 }, // áðèæè~ìîñÿ îáìåæè-ìîñÿ
			{ std::wstring(      L"³ìîñÿ"), 4 }, // áåð~³ìîñÿ äèâ³~ìîñÿ
			//{ std::wstring(      L"¿ìîñÿ"), 4 }, // no words
			//{ std::wstring(     L"à¿ìîñÿ"), 4 }, // too little words (íà~¿ìîñÿ)
			{ std::wstring(     L"î¿ìîñÿ"), 5 }, // áî~¿ìîñÿ áëàãîóñòðî~¿ìîñÿ
			{ std::wstring(      L"éìîñÿ"), 5 }, // compound
			//{ std::wstring(     L"àéìîñÿ"), 5 }, // íàçèâà~éìîñÿ âåðòà~éìîñÿ
			//{ std::wstring(     L"èéìîñÿ"), 5 }, // áè~éìîñÿ
			//{ std::wstring(     L"³éìîñÿ"), 5 }, // á³~éìîñÿ
			//{ std::wstring(     L"îéìîñÿ"), 5 }, // áëàãîóñòðî~éìîñÿ
			//{ std::wstring(     L"óéìîñÿ"), 5 }, // àêòóàë³çó~éìîñÿ
			//{ std::wstring(     L"þéìîñÿ"), 5 }, // àí³ã³ëþ~éìîñÿ
			{ std::wstring(      L"üìîñÿ"), 4 }, // áåç÷åñòü~ìîñÿ ñêèíü~ìîñÿ çîñåðåäü~ìîñÿ
			{ std::wstring(        L"óñÿ"), 3 }, // áåð~óñÿ áåç÷åù~óñÿ
			{ std::wstring(      L"èìóñÿ"), 4 }, // áåðåãòè~ìóñÿ
			{ std::wstring(    L"àòèìóñÿ"), 6 }, // áðà~òèìóñÿ
			{ std::wstring(    L"îòèìóñÿ"), 6 }, // áîðî~òèìóñÿ
			//{ std::wstring(    L"¿òèìóñÿ"), 6 }, // ãíî¿~òèìóñÿ
			{ std::wstring(   L"î¿òèìóñÿ"), 7 }, // ãíî~¿òèìóñÿ
			{ std::wstring(  L"óâàòèìóñÿ"), 8 }, // àêòóàë³çó~âàòèìóñÿ
			{ std::wstring(  L"þâàòèìóñÿ"), 8 }, // àí³ã³ëþ~âàòèìóñÿ
			{ std::wstring(    L"èòèìóñÿ"), 6 }, // áðèæè~òèìóñÿ áè~òèìóñÿ
			{ std::wstring(    L"ÿòèìóñÿ"), 6 }, // áî~ÿòèìóñÿ
			{ std::wstring(       L"åøñÿ"), 4 }, // áåð~åøñÿ
			{ std::wstring(     L"èìåøñÿ"), 5 }, // áåðåãòè~ìåøñÿ
			{ std::wstring(   L"àòèìåøñÿ"), 7 }, // íàçèâà~òèìåøñÿ
			{ std::wstring(   L"îòèìåøñÿ"), 7 }, // áîðî~òèìåøñÿ
			{ std::wstring( L"óâàòèìåøñÿ"), 9 }, // àêòóàë³çó~âàòèìåøñÿ
			{ std::wstring( L"þâàòèìåøñÿ"), 9 }, // àí³ã³ëþ~âàòèìåøñÿ
			{ std::wstring(   L"èòèìåøñÿ"), 7 }, // áðèæè~òèìåøñÿ áè~òèìåøñÿ
			//{ std::wstring(   L"¿òèìåøñÿ"), 7 }, // ãíî¿~òèìåøñÿ
			{ std::wstring(  L"î¿òèìåøñÿ"), 8 }, // ãíî~¿òèìåøñÿ
			{ std::wstring(   L"ÿòèìåøñÿ"), 8 }, // áî~ÿòèìåøñÿ
			{ std::wstring(       L"ºøñÿ"), 4 }, // compound
			//{ std::wstring(      L"àºøñÿ"), 4 }, // íàçèâà~ºøñÿ
			//{ std::wstring(      L"óºøñÿ"), 4 }, // àêòóàë³çó~ºøñÿ
			//{ std::wstring(      L"þºøñÿ"), 4 }, // àí³ã³ëþ~ºøñÿ
			//{ std::wstring(      L"'ºøñÿ"), 4 }, // á'~ºøñÿ
			{ std::wstring(       L"èøñÿ"), 4 }, // áðèæ~èøñÿ
			//{ std::wstring(       L"¿øñÿ"), 4 }, // áî~¿øñÿ áëàãîóñòðî~¿øñÿ
			{ std::wstring(      L"î¿øñÿ"), 4 }, // áî~¿øñÿ áëàãîóñòðî~¿øñÿ
			{ std::wstring(        L"üñÿ"), 2 }, // áåç÷åñòü~ñÿ, do not work without SA
			//{ std::wstring(       L"òüñÿ"), 4 }, // Must have vowel (Ut1sa) NOT:áåç÷åñ*òü~ñÿ
			{ std::wstring(      L"àòüñÿ"), 4 }, // íàçèâà~òüñÿ
			{ std::wstring(    L"óâàòüñÿ"), 6 }, // àêòóàë³çó~âàòüñÿ
			{ std::wstring(    L"þâàòüñÿ"), 6 }, // àí³ã³ëþ~âàòüñÿ
			{ std::wstring(      L"åòüñÿ"), 4 }, // áåðå~òüñÿ áåðåæå~òüñÿ
			{ std::wstring(    L"èìåòüñÿ"), 6 }, // áåðåãòè~ìåòüñÿ
			{ std::wstring(  L"àòèìåòüñÿ"), 8 }, // íàçèâà~òèìåòüñÿ
			{ std::wstring(L"þâàòèìåòüñÿ"), 10 }, // àí³ã³ëþ~âàòèìåòüñÿ
			{ std::wstring(L"óâàòèìåòüñÿ"), 10 }, // àêòóàë³çó~âàòèìåòüñÿ
			{ std::wstring(L"èòèìåòüñÿ"), 8 }, // áðèæè~òèìåòüñÿ áè~òèìåòüñÿ
			//{ std::wstring(  L"¿òèìåòüñÿ"), 8 }, // ãíî¿~òèìåòüñÿ
			{ std::wstring( L"î¿òèìåòüñÿ"), 9 }, // ãíî~¿òèìåòüñÿ
			{ std::wstring(  L"îòèìåòüñÿ"), 8 }, // áîðî~òèìåòüñÿ
			{ std::wstring(  L"ÿòèìåòüñÿ"), 9 }, // áî~ÿòèìåòüñÿ

			{ std::wstring(      L"ºòüñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºòüñÿ"), 5 }, // íàçèâà~ºòüñÿ
			//{ std::wstring(     L"óºòüñÿ"), 5 }, // àêòóàë³çó~ºòüñÿ
			//{ std::wstring(     L"þºòüñÿ"), 5 }, // àí³ã³ëþ~ºòüñÿ
			//{ std::wstring(     L"'ºòüñÿ"), 5 }, // á'~ºòüñÿ
			{ std::wstring(      L"èòüñÿ"), 4 }, // áðèæè~òüñÿ áè~òüñÿ
			{ std::wstring(      L"³òüñÿ"), 4 }, // äèâ³~òüñÿ áåð³~òüñÿ áåðåæ³~òüñÿ
			//{ std::wstring(      L"¿òüñÿ"), 5 }, // áëàãîóñòðî~¿òüñÿ
			{ std::wstring(     L"î¿òüñÿ"), 5 }, // áëàãîóñòðî~¿òüñÿ çàñïîêî~¿òüñÿ
			{ std::wstring(      L"îòüñÿ"), 4 }, // áîðî~òüñÿ
			{ std::wstring(      L"óòüñÿ"), 4 }, // áåõíó~òüñÿ áåðó~òüñÿ
			{ std::wstring(    L"èìóòüñÿ"), 6 }, // áåðåãòè~ìóòüñÿ
			{ std::wstring(  L"àòèìóòüñÿ"), 8 }, // íàçèâà~òèìóòüñÿ
			{ std::wstring(  L"îòèìóòüñÿ"), 8 }, // áîðî~òèìóòüñÿ
			{ std::wstring(L"óâàòèìóòüñÿ"), 10 }, // àêòóàë³çó~âàòèìóòüñÿ
			{ std::wstring(L"þâàòèìóòüñÿ"), 10 }, // àí³ã³ëþ~âàòèìóòüñÿ
			{ std::wstring(  L"èòèìóòüñÿ"), 8 }, // áðèæè~òèìóòüñÿ áè~òèìóòüñÿ
			//{ std::wstring(  L"¿òèìóòüñÿ"), 9 }, // ãíî~¿òèìóòüñÿ
			{ std::wstring( L"î¿òèìóòüñÿ"), 9 }, // ãíî~¿òèìóòüñÿ
			{ std::wstring(  L"ÿòèìóòüñÿ"), 9 }, // áî~ÿòèìóòüñÿ
			{ std::wstring(      L"þòüñÿ"), 5 }, // compound áîð~þòüñÿ
			//{ std::wstring(     L"àþòüñÿ"), 5 }, // íàçèâà~þòüñÿ
			//{ std::wstring(     L"þþòüñÿ"), 5 }, // àí³ã³ëþ~þòüñÿ
			//{ std::wstring(     L"'þòüñÿ"), 5 }, // á'~þòüñÿ
			//{ std::wstring(      L"¿òüñÿ"), 4 }, // çàñïîêî¿~òüñÿ
			{ std::wstring(     L"óþòüñÿ"), 5 }, // àêòóàë³çó~þòüñÿ
			{ std::wstring(      L"ÿòüñÿ"), 5}, // áåç÷åñò~ÿòüñÿ äèâë~ÿòüñÿ
			{ std::wstring(     L"îÿòüñÿ"), 5 }, // çàñïîêî~ÿòüñÿ ãíî~ÿòüñÿ áî~ÿòüñÿ
			{ std::wstring(        L"þñÿ"), 3 }, // compound àðêàí~þñÿ äèâë~þñÿ
			//{ std::wstring(       L"àþñÿ"), 3 }, // çíà~þñÿ íàçèâà~þñÿ
			//{ std::wstring(       L"îþñÿ"), 3 }, // áî~þñÿ áëàãîóñòðî~þñÿ ãíî~þñÿ
			//{ std::wstring(       L"óþñÿ"), 3 }, // àêòóàë³çó~þñÿ
			//{ std::wstring(       L"þþñÿ"), 3 }, // àí³ã³ëþ~þñÿ õâèëþ~þñÿ
			//{ std::wstring(       L"'þñÿ"), 3 }, // á'~þñÿ
		};

		static bool sureSuffixesInitialized = false;
		if (!sureSuffixesInitialized)
		{
			sureSuffixesInitialized = true;
			sureSuffixes = std::move(sureSuffixesStatic);;

			for (const SuffixEnd& suffixEnd : sureSuffixes)
			{
				if (suffixEnd.TakeCharsCount > suffixEnd.MatchSuffix.size())
				{
					PG_Assert(false && "actual suffix size must be <= of possible suffix size");
				}
			}
			std::sort(sureSuffixes.begin(), sureSuffixes.end(), [](SuffixEnd& a, SuffixEnd& b)
			{
				if (a.MatchSuffix.size() != b.MatchSuffix.size())
					return a.MatchSuffix.size() > b.MatchSuffix.size();
				return a.MatchSuffix < b.MatchSuffix;
			});
			for (size_t i = 0; i<sureSuffixes.size()-1; ++i)
			{
				const auto& curSuffix = sureSuffixes[i].MatchSuffix;
				if (curSuffix == sureSuffixes[i + 1].MatchSuffix && sureSuffixes[i].WordClass == sureSuffixes[i+1].WordClass)
				{
					PG_Assert(false && "Duplicate suffixs");
				}
			}
		}
	}

	bool isValidPhoneticSplit(wv::slice<wchar_t> word, int splitPos)
	{
		bool correct = splitPos > 0 && splitPos <= word.size();
		if (!correct)
			return false;

		PG_Assert(splitPos > 0);

		wchar_t prefixLastChar = word[splitPos - 1];
		wchar_t suffixFirstChar = word[splitPos];
		int suffixSize = word.size() - splitPos;

		// soft character modifies the previous character, the can't be separated
		if (suffixFirstChar == L'ü')
			return false;

		// WHY?
		// allow suffixes like "jmo"
		//if (suffixFirstChar == L'é' && suffixSize == 1)
		//	return false;

		// apostrophe makes previous consonant stronger, do not separate it from prefix
		if (suffixFirstChar == L'\'' || suffixFirstChar == L'\'')
			return false;

		return true;
	}

	// Tries to split the word into two parts, so that the phonetic transcription is not corrupted.
	// Returns prefix size or -1 if word can't be split.
	int phoneticSplitOfWord(wv::slice<wchar_t> word, boost::optional<WordClass> wordClass, int* pMatchedSuffixInd)
	{
		ensureSureSuffixesInitialized();

		for (size_t suffixInd = 0; suffixInd < sureSuffixes.size(); ++suffixInd)
		{
			const SuffixEnd& suffixEnd = sureSuffixes[suffixInd];
			WordClass suffixClass = suffixEnd.WordClass;

			//WordClass suffixClass = suffixEnd.WordClass;
			//if (suffixClass == WordClass::Participle || suffixClass == WordClass::VerbalAdverb)
			//	suffixClass = WordClass::Verb;

			//WordClass wordClassTmp = wordClass.get();
			//if (wordClassTmp == WordClass::Participle || wordClassTmp == WordClass::VerbalAdverb)
			//	wordClassTmp = WordClass::Verb;

			if (wordClass != nullptr)
			{
				// match word class and suffix (word) class
				WordClass wordClassTmp = wordClass.get();
				if (wordClassTmp != suffixClass)
					continue;
			}

			const std::wstring& suffix = suffixEnd.MatchSuffix;
			if (endsWith<wchar_t>(word, suffix))
			{
				int suffixSize = suffixEnd.TakeCharsCount;
				int prefixSize = (int)word.size() - suffixSize;
				
				// prohibit detaching the soft sign from prefix
				if (word[prefixSize] == L'ü' && prefixSize + 1 < word.size())
					prefixSize++;

				// trim vowels at the end of the prefix
				bool trimEndVowels = false;
				if (trimEndVowels)
				{
					bool isPrefixEndsVowel = true;
					while (prefixSize > 0 && isPrefixEndsVowel)
					{
						wchar_t prefixLastChar = word[prefixSize - 1];
						isPrefixEndsVowel = !PticaGovorun::isUkrainianConsonant(prefixLastChar);
						if (isPrefixEndsVowel)
							prefixSize--;
					}
				}

				// avoid short prefixes, as they will not participate in other words construction frequently
				// áîÿâøèéñÿ -> á
				// need prefixes with size>1 to distinguish (áè~éñÿ, á³~éñÿ)
				if (prefixSize <= 1) continue;

				if (!isValidPhoneticSplit(word, prefixSize))
					continue;

				if (wordClass == WordClass::Participle && suffixEnd.WordClass != WordClass::Participle)
				{
					participleSuffixToWord[suffixEnd.MatchSuffix] = std::wstring(word.data(), word.size());
				}
				if (wordClass == WordClass::VerbalAdverb && suffixEnd.WordClass != WordClass::VerbalAdverb)
				{
					participleSuffixToWord2[suffixEnd.MatchSuffix] = std::wstring(word.data(), word.size());
				}

				if (pMatchedSuffixInd != nullptr)
					*pMatchedSuffixInd = (int)suffixInd;
				
				return prefixSize;
			}
		}

		return -1;
	}

	bool isUnvoicedCharUk(wchar_t ch)
	{
		// êïñòôõøö÷
		// ÊÏÑÒÔÕØÖ×
		return
			ch == L'ê' || ch == L'Ê' ||
			ch == L'ï' || ch == L'Ï' ||
			ch == L'ñ' || ch == L'Ñ' ||
			ch == L'ò' || ch == L'Ò' ||
			ch == L'ô' || ch == L'Ô' ||
			ch == L'õ' || ch == L'Õ' ||
			ch == L'ø' || ch == L'Ø' ||
			ch == L'ö' || ch == L'Ö' ||
			ch == L'÷' || ch == L'×';
	}

	// Returns number of made transformations or zero if the map was not changed.
	int reuseCommonPrefixesOneIteration(std::map<std::wstring, int>& mapPrefixToSize)
	{
		if (mapPrefixToSize.size() <= 1)
			return 0;

		std::vector<std::wstring> prefixes(mapPrefixToSize.size());
		std::transform(std::begin(mapPrefixToSize), std::end(mapPrefixToSize), std::begin(prefixes), [](const std::pair<std::wstring, int>& pair)
		{
			return pair.first;
		});
		std::sort(std::begin(prefixes), std::end(prefixes), [](std::wstring& a, std::wstring& b)
		{
			return a.size() < b.size();
		});

		int changesMade = 0;
		std::vector<uchar> processed(prefixes.size());
		for (size_t i = 0; i < processed.size(); ++i)
		{
			if (processed[i])
				continue;
			processed[i] = true;
			for (size_t j = i; j < processed.size(); ++j)
			{
				if (processed[j])
					continue;
				const std::wstring& s1 = prefixes[i];
				const std::wstring& s2 = prefixes[j];
				assert(s1.size() <= s2.size() && "Strings are ordered in ascending order");

				size_t prefixSize = commonPrefixSize<wchar_t>(s1, s2);
				auto countConsonant = [](wchar_t ch) { return isUkrainianConsonant(ch); };
				size_t conson1 = std::count_if(s1.begin() + prefixSize, s1.end(), countConsonant);
				size_t conson2 = std::count_if(s2.begin() + prefixSize, s2.end(), countConsonant);

				bool canSplit1 = isValidPhoneticSplit(s1, prefixSize);
				bool canSplit2 = isValidPhoneticSplit(s1, prefixSize);

				// can reduce two prefixes only if they differ in ending of all vowels
				bool canReduce = (prefixSize < s1.size() || prefixSize < s2.size()) && conson1 == 0 && conson2 == 0 && canSplit1 && canSplit2;
				if (!canReduce)
					continue;

				if (prefixSize < s1.size() ^ prefixSize < s2.size()) // one is the prefix of another
				{
					// keep shorter prefix, remove longer prefix
					const std::wstring *shorter = nullptr;
					const std::wstring *longer = nullptr;
					size_t longerWordInd;
					if (prefixSize < s1.size())
					{
						shorter = &s1;
						longer = &s2;
						longerWordInd = j;
					}
					else
					{
						shorter = &s2;
						longer = &s1;
						longerWordInd = i;
					}
					int usedCount = mapPrefixToSize[*longer];
					mapPrefixToSize.erase(*longer);

					mapPrefixToSize[*shorter] += usedCount;

					processed[longerWordInd] = true;
				}
				else
				{
					int usedCount1 = mapPrefixToSize[s1];
					int usedCount2 = mapPrefixToSize[s2];
					mapPrefixToSize.erase(s1);
					mapPrefixToSize.erase(s2);

					std::wstring prefix(s1.data(), prefixSize);
					mapPrefixToSize[prefix] += usedCount1 + usedCount2;
					processed[i] = true;
					processed[j] = true;
				}
				changesMade++;
			}
		}
		return changesMade;
	}

	void reuseCommonPrefixes(std::map<std::wstring, int>& mapPrefixToSize)
	{
		while (reuseCommonPrefixesOneIteration(mapPrefixToSize) > 0) {}
	}

	bool isVoiceless(wchar_t ch)
	{
		bool voiceless = ch == L'÷'; // áóðêî÷
		return voiceless;
	}

	UkrainianPhoneticSplitter::UkrainianPhoneticSplitter()
	{
		bool wasAdded = false;
		sentStartWordPart_ = wordUsage_.getOrAddWordPart(L"<s>", WordPartSide::WholeWord, &wasAdded);
		CV_Assert(wasAdded);
		sentEndWordPart_ = wordUsage_.getOrAddWordPart(L"</s>", WordPartSide::WholeWord, &wasAdded);
		CV_Assert(wasAdded);
	}

	void UkrainianPhoneticSplitter::bootstrap(const std::unordered_map<std::wstring, std::unique_ptr<WordDeclensionGroup>>& words, const std::wstring& targetWord, const std::unordered_set<std::wstring>& processedWords, int& totalWordsCount)
	{
		totalWordsCount = 0;
		for (const auto& pair : words)
		{
			const WordDeclensionGroup& wordGroup = *pair.second;
			bool contains = processedWords.find(wordGroup.Name) != processedWords.end();
			if (false && !contains)
				continue;

			if (!targetWord.empty() && wordGroup.Name != targetWord)
				continue;

			if (allowPhoneticWordSplit_)
			{
				for (const WordDeclensionForm& declWord : wordGroup.Forms)
				{
					const WordPart* wordPart = wordUsage_.getOrAddWordPart(declWord.Name, WordPartSide::WholeWord);
				}
				continue;
			}

			if (wordGroup.WordClass == WordClass::Irremovable ||
				wordGroup.WordClass == WordClass::Preposition ||
				wordGroup.WordClass == WordClass::Pronoun ||
				wordGroup.WordClass == WordClass::Conjunction ||
				wordGroup.WordClass == WordClass::Interjection ||
				wordGroup.WordClass == WordClass::Particle ||
				wordGroup.WordClass == WordClass::Irremovable)
			{
				// keep the word intact
				continue;
			}
			else if (
				wordGroup.WordClass == WordClass::Adjective ||
				wordGroup.WordClass == WordClass::Adverb ||
				wordGroup.WordClass == WordClass::Noun ||
				wordGroup.WordClass == WordClass::Numeral ||
				wordGroup.WordClass == WordClass::Verb ||
				wordGroup.WordClass == WordClass::VerbalAdverb ||
				wordGroup.WordClass == WordClass::Participle)
			{
				std::vector<std::wstring> unsplitWords;
				std::map<std::wstring, int> mapPrefixSizeToCount;
				for (const WordDeclensionForm& wordForm : wordGroup.Forms)
				{
					const std::wstring& word = wordForm.Name;

					// split comma separated words into words
					size_t newOffset;
					for (size_t offset = 0; offset < word.size(); offset = newOffset + 1) // +1 to skip comma
					{
						if (word[offset] == L'*')
							offset++;
						newOffset = word.find(L",", offset);
						if (newOffset == (size_t)-1)
							newOffset = word.size();

						wv::slice<wchar_t> subWord = wv::make_view(word.data() + offset, newOffset - offset);
						totalWordsCount++;

						int matchedSuffixInd = -1;
						WordClass curWordClass = wordGroup.WordClass.get();
						if (wordForm.WordClass != nullptr)
							curWordClass = wordForm.WordClass.get();

						int sepInd = phoneticSplitOfWord(subWord, curWordClass, &matchedSuffixInd);
						if (sepInd != -1)
							sureSuffixes[matchedSuffixInd].UsedCount++;

						if (sepInd == -1)
						{
							bool voiceless = isVoiceless(subWord[subWord.size() - 1]);

							wchar_t wordLastChar = subWord[subWord.size() - 1];
							bool ok =
								wordLastChar == L'ü' ||
								wordLastChar == L'æ' || // áðîäÿæ
								voiceless;

							// it is ok to not finding consonant+sa
							if (!ok && endsWith(subWord, (wv::slice<wchar_t>)std::wstring(L"ñÿ")))
							{
								wchar_t prefixLastChar = subWord[subWord.size() - 1 - 2];
								ok = isUkrainianConsonant(prefixLastChar);
							}
							if (!ok)
							{
								std::wstring subWordStr(subWord.data(), subWord.size());
								unsplitWords.push_back(subWordStr);
								//::DebugBreak();
								//::OutputDebugStringW(L"Suffix was not found for word: ");
								//::OutputDebugStringW(subWordStr.data());
								//::OutputDebugStringW(L"\n");
							}
						}

						//if (sepInd != -1)
						//{
						//	wv::slice<wchar_t> prefixWord = wv::make_view(subWord.data(), sepInd);
						//	static std::wstring suffixVa(L"âà");
						//	if (endsWith(prefixWord, wv::make_view(suffixVa)))
						//	{
						//		// skip -va words
						//		//continue;
						//	}
						//}

						// store prefix to usage count
						{
							int sepIndTmp = sepInd;
							if (sepIndTmp == -1)
								sepIndTmp = subWord.size();

							// separation position was not found, use the whole word
							std::wstring prefixStr(subWord.data(), 0, sepIndTmp);
							mapPrefixSizeToCount[prefixStr]++;
						}

						int partsCount;
						std::array<std::wstring, 2> partsStrings;
						std::array<WordPartSide, 2> partsSides;
						if (sepInd == -1)
						{
							// separation position was not found, use the whole word
							partsCount = 1;
							partsStrings[0] = toString(subWord);
							partsSides[0] = WordPartSide::WholeWord;
						}
						else
						{
							partsCount = 2;

							wv::slice<wchar_t> prefix = wv::make_view(subWord.data(), sepInd);
							wv::slice<wchar_t> suffix = wv::make_view(subWord.data() + sepInd, subWord.size() - sepInd);

							partsStrings[0] = toString(prefix);
							partsSides[0] = WordPartSide::LeftPart;
							partsStrings[1] = toString(suffix);
							partsSides[1] = WordPartSide::RightPart;
						}

						//
						ShortArray<int, 2> splitParts;
						splitParts.Array.fill(-1);
						splitParts.ActualSize = partsCount;

						for (int partInd = 0; partInd < partsCount; ++partInd)
						{
							const std::wstring& partStr = partsStrings[partInd];
							WordPartSide partSide = partsSides[partInd];

							const WordPart* wordPart = wordUsage_.getOrAddWordPart(partStr, partSide);

							//WordSeqKey wordIds({ wordPart->id() });
							//WordSeqUsage* wordSeq = wordUsage_.getOrAddWordSequence(wordIds);
							//wordSeq->UsedCount++;

							splitParts.Array[partInd] = wordPart->id();
						}
						wordStrToPartIds_[word] = splitParts;
					}
				}

				size_t diffPrefixCountBefore = mapPrefixSizeToCount.size();
				reuseCommonPrefixes(mapPrefixSizeToCount);

				size_t diffPrefixCount = mapPrefixSizeToCount.size();
				for (const auto& prefixToCountPair : mapPrefixSizeToCount)
				{
					const auto& prefix = prefixToCountPair.first;
					wchar_t ch = prefix[prefix.size() - 1];
					bool voiceless = isVoiceless(ch);
					if (ch == L'ü' || voiceless || ch == L'-')
						diffPrefixCount--;
				}
				//std::wcout << L"word finished diffPrefixCount=" << diffPrefixCount << std::endl;
			}
			else
				::DebugBreak(); // unknown word class
		}
		const auto& m1 = participleSuffixToWord;
		const auto& m2 = participleSuffixToWord2;
		OutputDebugStringW(L"PARTICIPLE\n");
		for (const auto& pair : participleSuffixToWord)
		{
			OutputDebugStringW(pair.first.c_str());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(pair.second.c_str());
			OutputDebugStringW(L"\n");
		}
		OutputDebugStringW(L"VERBALADVERB\n");
		for (const auto& pair : participleSuffixToWord2)
		{
			OutputDebugStringW(pair.first.c_str());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(pair.second.c_str());
			OutputDebugStringW(L"\n");
		}
	}

	const WordsUsageInfo& UkrainianPhoneticSplitter::wordUsage() const
	{
		return wordUsage_;
	}
	WordsUsageInfo& UkrainianPhoneticSplitter::wordUsage()
	{
		return wordUsage_;
	}

	void UkrainianPhoneticSplitter::printSuffixUsageStatistics() const
	{
		auto sureSuffixesCopy = sureSuffixes;
		std::sort(sureSuffixesCopy.begin(), sureSuffixesCopy.end(), [](SuffixEnd& a, SuffixEnd& b)
		{
			return a.UsedCount > b.UsedCount;
		});
		OutputDebugStringW(L"Suffix usage statistics:\n");
		for (const auto& suffixEnd : sureSuffixesCopy)
		{
			OutputDebugStringW(suffixEnd.MatchSuffix.data());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(QString::number(suffixEnd.UsedCount).toStdWString().c_str());

			wchar_t* classStr = L"";
			if (suffixEnd.WordClass == WordClass::Verb)
				classStr = L"v";
			else if (suffixEnd.WordClass == WordClass::Noun)
				classStr = L"n";
			else if (suffixEnd.WordClass == WordClass::Adjective)
				classStr = L"adj";
			else if (suffixEnd.WordClass == WordClass::Adverb)
				classStr = L"adverb";
			OutputDebugStringW(L" ");
			OutputDebugStringW(classStr);
			OutputDebugStringW(L"\n");
		}
	}

	long UkrainianPhoneticSplitter::wordSeqCount(int wordsPerSeq) const
	{
		PG_Assert(wordsPerSeq <= 2);
		if (wordsPerSeq == 1)
			return seqOneWordCounter_;
		return seqTwoWordsCounter_;
	}

	const WordPart* UkrainianPhoneticSplitter::sentStartWordPart() const
	{
		return sentStartWordPart_;
	}

	const WordPart* UkrainianPhoneticSplitter::sentEndWordPart() const
	{
		return sentEndWordPart_;
	}

	void UkrainianPhoneticSplitter::setAllowPhoneticWordSplit(bool value)
	{
		allowPhoneticWordSplit_ = value;
	}

	void UkrainianPhoneticSplitter::buildLangModel(const wchar_t* textFilesDir, long& totalPreSplitWords, int maxFileToProcess, bool outputCorpus)
	{
		QFile corpusFile;
		QTextStream corpusStream;
		if (outputCorpus)
		{
			std::wstringstream corpusFileName;
			corpusFileName << "persianCorpus.";
			appendTimeStampNow(corpusFileName);
			corpusFileName << ".txt";

			corpusFile.setFileName(QString::fromStdWString(corpusFileName.str()));
			if (!corpusFile.open(QIODevice::WriteOnly | QIODevice::Text))
				return;
			corpusStream.setDevice(&corpusFile);
			corpusStream.setCodec("UTF-8");
		}

		QXmlStreamReader xml;
		totalPreSplitWords = 0;

		std::vector<wv::slice<wchar_t>> words;
		words.reserve(64);
		std::vector<const WordPart*> wordParts;
		wordParts.reserve(1024);
		TextParser wordsReader;

		QString textFilesDirQ = QString::fromStdWString(textFilesDir);
		QDirIterator it(textFilesDirQ, QStringList() << "*.fb2", QDir::Files, QDirIterator::Subdirectories);
		int processedFiles = 0;
		while (it.hasNext())
		{
			if (maxFileToProcess != -1 && processedFiles == maxFileToProcess)
				break;

			//if (processedFiles >= 2) break; // process less work

			QString txtPath = it.next();
			if (txtPath.contains("BROKEN", Qt::CaseSensitive))
			{
				qDebug() << "SKIPPED " << txtPath;
				continue;
			}
			qDebug() << txtPath;

			//
			QFile file(txtPath);
			if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			{
				qDebug() << "Can't open file " << txtPath;
				return;
			}

			// parse file
			xml.setDevice(&file);
			while (!xml.atEnd())
			{
				xml.readNext();
				if (xml.isCharacters())
				{
					// BUG: if the lines inside the text are separated using LF only on windows machines
					//      the function below will concatenate the lines. For now, fix LF->CRLF for such files externally
					QStringRef elementText = xml.text();

					wv::slice<wchar_t> textToParse = wv::make_view((wchar_t*)elementText.data(), elementText.size());
					wordsReader.setInputText(textToParse);

					// extract all sentences from paragraph
					while (true)
					{
						words.clear();
						if (!wordsReader.parseSentence(words))
							break;
						if (words.empty())
							continue;

						{
							// augment the sentence with start/end terminators
							wordParts.push_back(sentStartWordPart_);

							selectWordParts(words, wordParts, totalPreSplitWords);

							// augment the sentence with start/end terminators
							wordParts.push_back(sentEndWordPart_);
						}

						// calculate statistic only if enough word parts is accumulated
						size_t calcStatWordPartsCount = 1000000;
						if (wordParts.size() > calcStatWordPartsCount)
						{
							calcNGramStatisticsOnWordPartsBatch(wordParts, outputCorpus, corpusStream);
						}
					}
				}
			}
			
			// flush the word parts buffer
			calcNGramStatisticsOnWordPartsBatch(wordParts, outputCorpus, corpusStream);

			++processedFiles;
		}
	}

	void UkrainianPhoneticSplitter::selectWordParts(const std::vector<wv::slice<wchar_t>>& words, std::vector<const WordPart*>& wordParts, long& preSplitWords)
	{
		for (int i = 0; i < words.size(); ++i)
		{
			const wv::slice<wchar_t>& wordSlice = words[i];
			PG_Assert(!wordSlice.empty());

			// keep ukrainian words only
			//auto filterOutWord = [](wv::slice<wchar_t> word)
			//{
			//	for (size_t charInd = 0; charInd < word.size(); ++charInd)
			//	{
			//		wchar_t ch = word[charInd];
			//		bool isDigit = isDigitChar(ch);
			//		//bool isLatin = isEnglishChar(ch);
			//		bool isSureLatin = isExclusiveEnglishChar(ch);
			//		bool isSureRus = isExclusiveRussianChar(ch);
			//		//if (isDigit || isLatin || isSureRus)
			//		if (isDigit || isSureLatin || isSureRus)
			//			return true;
			//	}
			//	return false;
			//};
			//if (filterOutWord(wordSlice))
			//{
			//	::OutputDebugStringW(toString(wordSlice).c_str());
			//	::OutputDebugStringW(L"\n");
			//	continue;
			//}

			auto wordCharUsage = [](wv::slice<wchar_t> word, int& digitsCount,
				int& engCount, int& exclEngCount,
				int& rusCount, int& exclRusCount,
				int& hyphenCount)
			{
				for (size_t charInd = 0; charInd < word.size(); ++charInd)
				{
					wchar_t ch = word[charInd];
					bool isDigit = isDigitChar(ch);
					bool isEng = isEnglishChar(ch);
					bool isExclEng = isExclusiveEnglishChar(ch);
					bool isRus = isRussianChar(ch);
					bool isExclRus = isExclusiveRussianChar(ch);
					if (isDigit)
						digitsCount++;
					if (isEng)
						engCount++;
					if (isExclEng)
						exclEngCount++;
					if (isRus)
						rusCount++;
					if (isExclRus)
						exclRusCount++;
					if (ch == L'-' || ch == L'\'')
						hyphenCount++;
				}
			};
			int digitsCount = 0;
			int engCount = 0;
			int exclEngCount = 0;
			int rusCount = 0;
			int exclRusCount = 0;
			int hyphenCount = 0;
			wordCharUsage(wordSlice, digitsCount, engCount, exclEngCount, rusCount, exclRusCount, hyphenCount);
			if (digitsCount > 0 || exclEngCount > 0 || exclRusCount > 0)
			{
				if (digitsCount == wordSlice.size() ||  // number
					(exclEngCount > 0 && (engCount + hyphenCount) == wordSlice.size()) || // english word
					(exclRusCount > 0 && (rusCount + hyphenCount) == wordSlice.size())    // russian word
					)
				{
					// do not even print the skipped word
					continue;
				}
				else
				{
					::OutputDebugStringW(toString(wordSlice).c_str());
					::OutputDebugStringW(L"\n");
				}
				wordParts.push_back(wordPartSeparator_); // word parts separator
				continue;
			}

			std::wstring str = toString(wordSlice);

			if (allowPhoneticWordSplit_)
			{
				auto preSplitWordIt = wordStrToPartIds_.find(str);
				if (preSplitWordIt != wordStrToPartIds_.end())
				{
					preSplitWords++;
					ShortArray<int, 2>& preSplit = preSplitWordIt->second;

					for (int splitInd = 0; splitInd < preSplit.ActualSize; ++splitInd)
					{
						int wordPartId = preSplit.Array[splitInd];
						const WordPart* wordPartPtr = wordUsage_.wordPartById(wordPartId);
						wordParts.push_back(wordPartPtr);
					}
				}
				else
				{
					doWordPhoneticSplit(str, wordParts);
				}
			}
			else
			{
				const WordPart* wordPart = wordUsage_.getOrAddWordPart(str, WordPartSide::WholeWord);
				wordParts.push_back(wordPart);
			}
		}
	}

	void UkrainianPhoneticSplitter::calcNGramStatisticsOnWordPartsBatch(std::vector<const WordPart*>& wordParts, bool outputCorpus, QTextStream& corpusStream)
	{
		std::vector<const WordPart*> wordPartsStraight;

		// select sequantial word parts without separator
		size_t wordPartInd = 0;
		auto takeWordPartsTillNull = [this, &wordParts, &wordPartInd](std::vector<const WordPart*>& outWordParts) -> bool
		{
			// returns true if result contains data
			while (wordPartInd < wordParts.size())
			{
				for (; wordPartInd < wordParts.size(); ++wordPartInd)
				{
					const WordPart* wordPartPtr = wordParts[wordPartInd];
					if (wordPartPtr == wordPartSeparator_)
					{
						wordPartInd++; // skip separator
						break;
					}
					outWordParts.push_back(wordPartPtr);
				}
				if (!outWordParts.empty())
					return true;
			}
			return false;
		};
		while (true)
		{
			wordPartsStraight.clear();
			if (!takeWordPartsTillNull(wordPartsStraight))
				break;

			calcLangStatistics(wordPartsStraight);

			if (outputCorpus)
			{
				for (const WordPart* wp : wordPartsStraight)
				{
					printWordPart(wp, corpusStream);
					corpusStream << " ";
				}
				corpusStream << "\n";
			}
		}
		// purge word parts buffer
		wordParts.clear();
	}

	void UkrainianPhoneticSplitter::calcLangStatistics(const std::vector<const WordPart*>& wordParts)
	{
		const WordPart* prevWordPart = nullptr;

		for (const WordPart* wordPart : wordParts)
		{
			if (wordPart->partText() == L"âàëóâàíí")
			{
				PG_Assert(true);
			}
			// unimodel
			WordSeqKey oneWordKey({ wordPart->id() });
			WordSeqUsage* oneWordSeq = wordUsage_.getOrAddWordSequence(oneWordKey);
			oneWordSeq->UsedCount++;
			seqOneWordCounter_++;

			// bimodel
			if (prevWordPart != nullptr)
			{
				WordSeqKey twoWordsKey({ prevWordPart->id(), wordPart->id() });
				WordSeqUsage* twoWordsSeq = wordUsage_.getOrAddWordSequence(twoWordsKey);
				twoWordsSeq->UsedCount++;
				seqTwoWordsCounter_++;
			}

			prevWordPart = wordPart;
		}
	}

	void UkrainianPhoneticSplitter::doWordPhoneticSplit(const wv::slice<wchar_t>& wordSlice, std::vector<const WordPart*>& wordParts)
	{
		//const std::wstring& word
		int matchedSuffixInd = -1;
		int sepInd = phoneticSplitOfWord(wordSlice, nullptr, &matchedSuffixInd);
		if (sepInd != -1)
			sureSuffixes[matchedSuffixInd].UsedCount++;

		int partsCount;
		std::array<std::wstring, 2> partsStrings;
		std::array<WordPartSide, 2> partsSides;
		if (sepInd == -1)
		{
			// separation position was not found, use the whole word
			partsCount = 1;
			partsStrings[0] = toString(wordSlice);
			partsSides[0] = WordPartSide::WholeWord;
		}
		else
		{
			partsCount = 2;

			wv::slice<wchar_t> prefix = wv::make_view(wordSlice.data(), sepInd);
			wv::slice<wchar_t> suffix = wv::make_view(wordSlice.data() + sepInd, wordSlice.size() - sepInd);

			partsStrings[0] = toString(prefix);
			partsSides[0] = WordPartSide::LeftPart;
			partsStrings[1] = toString(suffix);
			partsSides[1] = WordPartSide::RightPart;
		}

		for (int partInd = 0; partInd < partsCount; ++partInd)
		{
			const std::wstring& partStr = partsStrings[partInd];
			WordPartSide partSide = partsSides[partInd];

			const WordPart* wordPart = wordUsage_.getOrAddWordPart(partStr, partSide);
			wordParts.push_back(wordPart);
		}
	}
}