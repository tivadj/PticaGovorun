#include "stdafx.h"
#include "PhoneticService.h"
#include <array>
#include <QDirIterator>
#include <QXmlStreamReader>
#include <QString>
#include "CoreUtils.h"
#include <utility>
#include "assertImpl.h"

namespace PticaGovorun
{
	void toString(SoftHardConsonant value, std::string& result)
	{
		switch (value)
		{
		case SoftHardConsonant::Hard:
			result = "Hard";
			break;
		case SoftHardConsonant::Palatal:
			result = "Palatal";
			break;
		case SoftHardConsonant::Soft:
			result = "Soft";
			break;
		default:
			PG_Assert(false);
		}
	}

	namespace
	{
		const wchar_t Letter_Space = L' ';
		const wchar_t Letter_Hyphen = L'-';
		const wchar_t Letter_Apostrophe = L'\'';
		const wchar_t Letter_A = L'à';
		const wchar_t Letter_B = L'á';
		const wchar_t Letter_H = L'ã';
		const wchar_t Letter_D = L'ä';
		const wchar_t Letter_E = L'å';
		const wchar_t Letter_JE = L'º';
		const wchar_t Letter_ZH = L'æ';
		const wchar_t Letter_Z = L'ç';
		const wchar_t Letter_I = L'³';
		const wchar_t Letter_JI = L'¿';
		const wchar_t Letter_K = L'ê';
		const wchar_t Letter_N = L'í';
		const wchar_t Letter_S = L'ñ';
		const wchar_t Letter_T = L'ò';
		const wchar_t Letter_U = L'ó';
		const wchar_t Letter_TS = L'ö';
		const wchar_t Letter_CH = L'÷';
		const wchar_t Letter_SH = L'ø';
		const wchar_t Letter_SHCH = L'ù';
		const wchar_t Letter_SoftSign = L'ü';
		const wchar_t Letter_JU = L'þ';
		const wchar_t Letter_JA = L'ÿ';
	}

	void Pronunc::setPhones(const std::vector<std::string>& phones)
	{
		for (const std::string& ph : phones)
		{
			pushBackPhone(ph);
		}
	}

	void Pronunc::pushBackPhone(const std::string& phone)
	{
		if (!StrDebug.empty())
			StrDebug.push_back(' ');
		std::copy(std::begin(phone), std::end(phone), std::back_inserter(StrDebug));
		Phones.push_back(phone);
	}

	bool operator == (const Pronunc& a, const Pronunc& b)
	{
		bool eqSize = a.Phones.size() == b.Phones.size();
		if (!eqSize)
			return false;
		for (int i = 0; i < a.Phones.size(); ++i)
		{
			auto p1 = a.Phones[i];
			auto p2 = b.Phones[i];
			bool eqPhones = p1 == p2;
			if (!eqPhones)
				return false;
		}
		return true;
	}

	bool operator < (const Pronunc& a, const Pronunc& b)
	{
		size_t minSize = std::min(a.Phones.size(), b.Phones.size());
		for (int i = 0; i < minSize; ++i)
		{
			auto p1 = a.Phones[i];
			auto p2 = b.Phones[i];
			bool eq = p1 == p2;
			if (!eq)
				return std::less<>()(p1, p2);
		}
		if (a.Phones.size() < b.Phones.size())
			return true;
		else if (a.Phones.size() > b.Phones.size())
			return false;
		return false;
	}

	PhoneId PhoneRegistry::extendPhoneId(int validPhoneId) const
	{
		PhoneId result;
		result.Id = validPhoneId;
#if PG_DEBUG
		static std::string phoneStr;
		bool toStrOp = phoneToStr(*this, validPhoneId, phoneStr);
		PG_Assert2(toStrOp, "Invalid PhoneId:int");
		result.fillStr(phoneStr);
#endif
		return result;
	}

	PhoneRegistry::BasicPhoneIdT PhoneRegistry::extendBasicPhoneId(int basicPhoneId) const
	{
		BasicPhoneIdT result;
		result.Id = basicPhoneId;
#ifdef PG_DEBUG
		int basicPhoneStrInd = basicPhoneId - 1;

		PG_Assert(basicPhoneStrInd >= 0 && basicPhoneStrInd < basicPhones_.size());
		const BasicPhone& basicPhone = basicPhones_[basicPhoneStrInd];

		result.fillStr(basicPhone.Name);
#endif
		return result;
	}

	PhoneRegistry::BasicPhoneIdT PhoneRegistry::getOrCreateBasicPhone(const std::string& basicPhoneStr, CharGroup charGroup)
	{
		auto it = basicPhonesStrToId_.find(basicPhoneStr);
		if (it != basicPhonesStrToId_.end())
			return extendBasicPhoneId(it->second);

		int newId = basicPhones_.size() + 1;

		BasicPhone basicPhone;
		basicPhone.Id = newId;
		basicPhone.Name = basicPhoneStr;
		basicPhone.DerivedFromChar = charGroup;
		basicPhones_.push_back(basicPhone);
		basicPhonesStrToId_[basicPhoneStr] = newId;
		return extendBasicPhoneId(newId);
	}

	PhoneRegistry::BasicPhoneIdT PhoneRegistry::basicPhoneId(const std::string& basicPhoneStr, bool* success) const
	{
		*success = false;

		auto it = basicPhonesStrToId_.find(basicPhoneStr);
		if (it != basicPhonesStrToId_.end())
		{
			*success = true;
			return extendBasicPhoneId(it->second);
		}
		return PhoneRegistry::BasicPhoneIdT();
	}

	const BasicPhone* PhoneRegistry::basicPhone(BasicPhoneIdT basicPhoneId) const
	{
		int basicPhoneInd = basicPhoneId.Id - 1;
		if (basicPhoneInd < 0 || basicPhoneInd >= basicPhones_.size())
			return nullptr;
		return &basicPhones_[basicPhoneInd];
	}

	PhoneId PhoneRegistry::newVowelPhone(const std::string& basicPhoneStr, bool isStressed)
	{
		int phoneId = nextPhoneId_++;

		Phone phone;
		phone.Id = phoneId;
		phone.BasicPhoneId = getOrCreateBasicPhone(basicPhoneStr, CharGroup::Vowel);
		phone.IsStressed = isStressed;
		phoneReg_.push_back(phone);
		return extendPhoneId(phoneId);
	}

	PhoneId PhoneRegistry::newConsonantPhone(const std::string& basicPhoneStr, boost::optional<SoftHardConsonant> softHard)
	{
		int phoneId = nextPhoneId_++;

		Phone phone;
		phone.Id = phoneId;
		phone.BasicPhoneId = getOrCreateBasicPhone(basicPhoneStr, CharGroup::Consonant);
		phone.SoftHard = softHard;
		phoneReg_.push_back(phone);
		return extendPhoneId(phoneId);
	}

	void PhoneRegistry::findPhonesByBasicPhoneStr(const std::string& basicPhoneStr, std::vector<PhoneId>& phoneIds) const
	{
		auto basicPhoneIt = basicPhonesStrToId_.find(basicPhoneStr);
		if (basicPhoneIt == basicPhonesStrToId_.end())
			return;
		int basicPhoneId = basicPhoneIt->second;

		for (size_t phoneInd = 0; phoneInd < phoneReg_.size(); ++phoneInd)
		{
			const Phone& ph = phoneReg_[phoneInd];
			if (ph.BasicPhoneId.Id == basicPhoneId)
			{
				PhoneId pid = extendPhoneId(phoneInd + 1);
				phoneIds.push_back(pid);
			}
		}
	}

	int PhoneRegistry::phonesCount() const
	{
		assumeSequentialPhoneIdsWithoutGaps();
		return nextPhoneId_ - 1;
	}

	const Phone* PhoneRegistry::phoneById(int phoneId) const
	{
		int phoneInd = phoneId - 1;
		if (phoneInd < 0 || phoneInd >= phoneReg_.size())
			return nullptr;
		return &phoneReg_[phoneInd];
	}

	const Phone* PhoneRegistry::phoneById(PhoneId phoneId) const
	{
		return phoneById(phoneId.Id);
	}

	boost::optional<PhoneId> PhoneRegistry::phoneIdSingle(const std::string& basicPhoneStr, boost::optional<SoftHardConsonant> softHard, boost::optional<bool> isStressed) const
	{
		bool suc = false;
		auto basicPhId = basicPhoneId(basicPhoneStr, &suc);
		if (!suc)
			return boost::none;
		return phoneIdSingle(basicPhId, softHard, isStressed);
	}

	boost::optional<PhoneId> PhoneRegistry::phoneIdSingle(PhoneRegistry::BasicPhoneIdT basicPhoneStrId, boost::optional<SoftHardConsonant> softHardRequested, boost::optional<bool> isStressed) const
	{
		boost::optional<PhoneId> t = boost::none;
		const BasicPhone* basicPh = basicPhone(basicPhoneStrId);
		if (basicPh == nullptr)
			return boost::none;
		static std::vector<PhoneId> candidates;
		candidates.clear();
		findPhonesByBasicPhoneStr(basicPh->Name, candidates);

		if (candidates.empty())
			return boost::none;
		if (candidates.size() == 1)
			return candidates.front();

		boost::optional<SoftHardConsonant> softHardFixed = softHardRequested;
		if (softHardRequested != boost::none)
		{
			if (allowSoftHardConsonant())
			{
				if (softHardRequested == SoftHardConsonant::Palatal)
				{
					     if (palatalSupport() == PalatalSupport::AsHard)
						softHardFixed = SoftHardConsonant::Hard; // B2 -> B, L2 -> L
					else if (palatalSupport() == PalatalSupport::AsSoft)
						softHardFixed = SoftHardConsonant::Soft; // B2 -> B1, L2 -> L1
					else if (palatalSupport() == PalatalSupport::AsPalatal)
						softHardFixed = SoftHardConsonant::Palatal; // B2 -> B2, L2 -> L2
				}
				else if (softHardRequested == SoftHardConsonant::Soft)
				{
					if (usuallyHardBasicPhone(*this, basicPhoneStrId))
					{
						if (palatalSupport() == PalatalSupport::AsHard)
						{
							softHardFixed = SoftHardConsonant::Hard; // B1 -> B
						}
						else if (palatalSupport() == PalatalSupport::AsSoft)
						{
							softHardFixed = SoftHardConsonant::Soft; // B1 -> B1
						}
						else if (palatalSupport() == PalatalSupport::AsPalatal)
						{
							softHardFixed = SoftHardConsonant::Palatal; // B1 -> B2
						}
					}
				}
			}
		}

		std::vector<PhoneId> excactCandidates;
		std::remove_copy_if(candidates.begin(), candidates.end(), std::back_inserter(excactCandidates), [this, softHardFixed, isStressed](PhoneId phoneId)
		{
			const Phone* phone = phoneById(phoneId);
			if (softHardFixed != boost::none && softHardFixed != phone->SoftHard)
				return true;
			if (isStressed != boost::none && isStressed != phone->IsStressed)
				return true;
			return false;
		});

		if (excactCandidates.size() == 1)
			return excactCandidates.front();

		// exact candidates size:
		// = 0 then we may fallback to basic phone candidates; but there is no way to choose the best one
		// > 1 then again the best one can't be chosen
		return boost::none;
	}

	bool PhoneRegistry::allowSoftHardConsonant() const
	{
		return allowSoftConsonant_;
	}

	bool PhoneRegistry::allowVowelStress() const
	{
		return allowVowelStress_;
	}

	PalatalSupport PhoneRegistry::palatalSupport() const
	{
		return palatalSupport_;
	}

	void PhoneRegistry::setPalatalSupport(PalatalSupport value)
	{
		palatalSupport_ = value;
	}

	boost::optional<SoftHardConsonant> PhoneRegistry::defaultSoftHardConsonant() const
	{
		if (allowSoftHardConsonant())
			return SoftHardConsonant::Hard;
		return boost::none;
	}

	boost::optional<bool> PhoneRegistry::defaultIsVowelStressed() const
	{
		if (allowVowelStress())
			return false;
		return boost::none;
	}

	void initPhoneRegistryUk(PhoneRegistry& phoneReg, bool allowSoftConsonant, bool allowVowelStress)
	{
		phoneReg.allowSoftConsonant_ = allowSoftConsonant;
		phoneReg.allowVowelStress_ = allowVowelStress;
		bool allowPalatalizedConsonant = false;
		SoftHardConsonant palatalProxy = SoftHardConsonant::Hard;
		if (phoneReg.palatalSupport() == PalatalSupport::AsPalatal)
		{
			allowPalatalizedConsonant = true;
			palatalProxy = SoftHardConsonant::Palatal;
		}
		else if (phoneReg.palatalSupport() == PalatalSupport::AsHard)
		{
			allowPalatalizedConsonant = false;
		}
		else if (phoneReg.palatalSupport() == PalatalSupport::AsSoft)
		{
			allowPalatalizedConsonant = true;
			palatalProxy = SoftHardConsonant::Soft;
		}

		// TODO: silence is not a vowel
		phoneReg.newVowelPhone("SIL", false); // SIL
		//phoneReg.newVowelPhone("SWL", false); // silence with noise
		phoneReg.newVowelPhone("INH", false); // inhale
		//phoneReg.newConsonantPhone("CLK", SoftHardConsonant::Hard); // click sound (such as pressed key)
		phoneReg.newVowelPhone("EEE", false); // filler; gives a speaker the time to think about her answer
		phoneReg.newVowelPhone("YYY", false); // filler; gives a speaker the time to think about her answer

		phoneReg.newVowelPhone("A", false); // A
		if (allowVowelStress)
			phoneReg.newVowelPhone("A", true); // A1
		phoneReg.newConsonantPhone("B", SoftHardConsonant::Hard); // B, hard (äð³á), palatalized (áþðî)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("B", palatalProxy); // B''
		phoneReg.newConsonantPhone("V", SoftHardConsonant::Hard); // V, hard (âåðô), palatalized (öâÿõ)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("V", palatalProxy); // V''
		phoneReg.newConsonantPhone("G", SoftHardConsonant::Hard); // G, hard (gudzyk, ´åäç), palatalized
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("G", palatalProxy); // G''
		phoneReg.newConsonantPhone("H", SoftHardConsonant::Hard); // H, hard (gluhi, ãåí³é), palatalized (ã³ðêî)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("H", palatalProxy); // H''
		phoneReg.newConsonantPhone("D", SoftHardConsonant::Hard); // D
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("D", SoftHardConsonant::Soft); // D1
		phoneReg.newConsonantPhone("DZ", SoftHardConsonant::Hard); // DZ
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("DZ", SoftHardConsonant::Soft); // DZ1
		phoneReg.newConsonantPhone("DZH", SoftHardConsonant::Hard); // DZH hard (äæåì), palatalized
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("DZH", palatalProxy); // DZH''
		phoneReg.newVowelPhone("E", false); // E
		if (allowVowelStress)
			phoneReg.newVowelPhone("E", true); // E1
		phoneReg.newConsonantPhone("ZH", SoftHardConsonant::Hard); // ZH, hard (ìåæà), palatalized (íîæ³)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("ZH", palatalProxy); // ZH''
		phoneReg.newConsonantPhone("Z", SoftHardConsonant::Hard); // Z
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("Z", SoftHardConsonant::Soft); // Z1
		phoneReg.newVowelPhone("Y", false); // Y
		if (allowVowelStress)
			phoneReg.newVowelPhone("Y", true); // Y1
		phoneReg.newVowelPhone("I", false); // I
		if (allowVowelStress)
			phoneReg.newVowelPhone("I", true); // I1
		phoneReg.newConsonantPhone("J", SoftHardConsonant::Hard); // J, hard only (é)
		phoneReg.newConsonantPhone("K", SoftHardConsonant::Hard); // K, hard (êèëèì), palatalized (ê³íåöü)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("K", palatalProxy); // K''
		phoneReg.newConsonantPhone("L", SoftHardConsonant::Hard); // L
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("L", SoftHardConsonant::Soft); // L1
		phoneReg.newConsonantPhone("M", SoftHardConsonant::Hard); // M, hard (ñ³ì), palatalized (ì³é)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("M", palatalProxy); // M''
		phoneReg.newConsonantPhone("N", SoftHardConsonant::Hard); // N
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("N", SoftHardConsonant::Soft); // N1
		phoneReg.newVowelPhone("O", false); // O
		if (allowVowelStress)
			phoneReg.newVowelPhone("O", true); // O1
		phoneReg.newConsonantPhone("P", SoftHardConsonant::Hard); // P, hard (ï'ÿòü), palatalized (ï³ë)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("P", palatalProxy); // P''
		phoneReg.newConsonantPhone("R", SoftHardConsonant::Hard); // R
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("R", SoftHardConsonant::Soft); // R1
		phoneReg.newConsonantPhone("S", SoftHardConsonant::Hard); // S
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("S", SoftHardConsonant::Soft); // S1
		phoneReg.newConsonantPhone("T", SoftHardConsonant::Hard); // T
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("T", SoftHardConsonant::Soft); // T1
		phoneReg.newVowelPhone("U", false); // U
		if (allowVowelStress)
			phoneReg.newVowelPhone("U", true); // U1
		phoneReg.newConsonantPhone("F", SoftHardConsonant::Hard); // F, hard (âåðô), palatalized (ô³ãóðà)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("F", palatalProxy); // F''
		phoneReg.newConsonantPhone("KH", SoftHardConsonant::Hard); // KH, hard (õ'þ), palatalized (õ³áà)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("KH", palatalProxy); // KH''
		phoneReg.newConsonantPhone("TS", SoftHardConsonant::Hard); // TS
		if (allowSoftConsonant)
			phoneReg.newConsonantPhone("TS", SoftHardConsonant::Soft); // TS1
		phoneReg.newConsonantPhone("CH", SoftHardConsonant::Hard); // CH, hard (÷àñ), palatalized (î÷³)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("CH", palatalProxy); // CH''
		phoneReg.newConsonantPhone("SH", SoftHardConsonant::Hard); // SH, hard (ëîøà, ø'º) , palatalized (òîâàðèø³)
		if (allowPalatalizedConsonant)
			phoneReg.newConsonantPhone("SH", palatalProxy); // SH''
	}

	bool usuallyHardBasicPhone(const PhoneRegistry& phoneReg, Phone::BasicPhoneIdT basicPhoneId)
	{
		bool suc = true;
		bool foundMatch = false; // whether got the match
		auto usuallyHardPhone = [&suc, &foundMatch, &phoneReg](Phone::BasicPhoneIdT expectBasicPhoneId, const std::string& queryBasicPhoneStr) -> void
		{
			if (!suc || foundMatch)
				return;
			Phone::BasicPhoneIdT basicId = phoneReg.basicPhoneId(queryBasicPhoneStr, &suc);
			if (suc && expectBasicPhoneId == basicId)
				foundMatch = true;
		};
		usuallyHardPhone(basicPhoneId, "B");
		usuallyHardPhone(basicPhoneId, "P");
		usuallyHardPhone(basicPhoneId, "V");
		usuallyHardPhone(basicPhoneId, "M");
		usuallyHardPhone(basicPhoneId, "F");
		usuallyHardPhone(basicPhoneId, "H");
		usuallyHardPhone(basicPhoneId, "K");
		usuallyHardPhone(basicPhoneId, "KH");
		usuallyHardPhone(basicPhoneId, "G");
		usuallyHardPhone(basicPhoneId, "CH");
		usuallyHardPhone(basicPhoneId, "DZH");
		usuallyHardPhone(basicPhoneId, "SH");
		usuallyHardPhone(basicPhoneId, "ZH");
		PG_DbgAssert(suc);
		return foundMatch;
	}

	bool easilySoftBasicPhone(const PhoneRegistry& phoneReg, Phone::BasicPhoneIdT basicPhoneId)
	{
		bool suc = true;
		bool foundMatch = false; // whether got the match
		auto usuallyHardPhone = [&suc, &foundMatch, &phoneReg](Phone::BasicPhoneIdT expectBasicPhoneId, const std::string& queryBasicPhoneStr) -> void
		{
			if (!suc || foundMatch)
				return;
			Phone::BasicPhoneIdT basicId = phoneReg.basicPhoneId(queryBasicPhoneStr, &suc);
			if (suc && expectBasicPhoneId == basicId)
				foundMatch = true;
		};
		usuallyHardPhone(basicPhoneId, "D");
		usuallyHardPhone(basicPhoneId, "DZ");
		usuallyHardPhone(basicPhoneId, "T");
		usuallyHardPhone(basicPhoneId, "TS");
		usuallyHardPhone(basicPhoneId, "Z");
		usuallyHardPhone(basicPhoneId, "S");
		usuallyHardPhone(basicPhoneId, "N");
		usuallyHardPhone(basicPhoneId, "L");
		usuallyHardPhone(basicPhoneId, "R");
		PG_DbgAssert(suc);
		return foundMatch;
	}

	bool isNoisyVoicedConsonant(const PhoneRegistry& phoneReg, Phone::BasicPhoneIdT basicPhoneId)
	{
		bool suc = true;
		bool foundMatch = false; // whether got the match
		auto match = [&suc, &foundMatch, &phoneReg](Phone::BasicPhoneIdT expectBasicPhoneId, const std::string& queryBasicPhoneStr) -> void
		{
			if (!suc || foundMatch)
				return;
			Phone::BasicPhoneIdT basicId = phoneReg.basicPhoneId(queryBasicPhoneStr, &suc);
			if (suc && expectBasicPhoneId == basicId)
				foundMatch = true;
		};
		match(basicPhoneId, "B");
		match(basicPhoneId, "H");
		match(basicPhoneId, "G");
		match(basicPhoneId, "D");
		match(basicPhoneId, "DZ");
		match(basicPhoneId, "DZH");
		match(basicPhoneId, "Z");
		match(basicPhoneId, "ZH");
		PG_DbgAssert(suc);
		return foundMatch;
	}

	bool isNoisyUnvoicedConsonant(const PhoneRegistry& phoneReg, Phone::BasicPhoneIdT basicPhoneId)
	{
		bool suc = true;
		bool foundMatch = false; // whether got the match
		auto match = [&suc, &foundMatch, &phoneReg](Phone::BasicPhoneIdT expectBasicPhoneId, const std::string& queryBasicPhoneStr) -> void
		{
			if (!suc || foundMatch)
				return;
			Phone::BasicPhoneIdT basicId = phoneReg.basicPhoneId(queryBasicPhoneStr, &suc);
			if (suc && expectBasicPhoneId == basicId)
				foundMatch = true;
		};
		match(basicPhoneId, "P");
		match(basicPhoneId, "KH");
		match(basicPhoneId, "K");
		match(basicPhoneId, "T");
		match(basicPhoneId, "TS");
		match(basicPhoneId, "CH");
		match(basicPhoneId, "S");
		match(basicPhoneId, "SH");
		PG_DbgAssert(suc);
		return foundMatch;
	}

	boost::optional<Phone::BasicPhoneIdT> getVoicedUnvoicedConsonantPair(const PhoneRegistry& phoneReg, Phone::BasicPhoneIdT basicPhoneId)
	{
		bool suc = true;
		boost::optional<Phone::BasicPhoneIdT> partnerBasicPhoneId = boost::none;
		auto match = [&suc, &partnerBasicPhoneId, &phoneReg](Phone::BasicPhoneIdT expectBasicPhoneId, const std::string& basicStr, const std::string& dualBasicStr) -> void
		{
			if (!suc || partnerBasicPhoneId != boost::none)
				return;
			Phone::BasicPhoneIdT basicId1 = phoneReg.basicPhoneId(basicStr, &suc);
			if (!suc)
				return;
			Phone::BasicPhoneIdT basicId2 = phoneReg.basicPhoneId(dualBasicStr, &suc);
			if (!suc)
				return;
			if (expectBasicPhoneId == basicId1)
				partnerBasicPhoneId = basicId2;
			else if (expectBasicPhoneId == basicId2)
				partnerBasicPhoneId = basicId1;
		};
		match(basicPhoneId, "B", "P");
		match(basicPhoneId, "H", "KH");
		match(basicPhoneId, "G", "K");
		match(basicPhoneId, "D", "T");
		match(basicPhoneId, "DZ", "TS");
		match(basicPhoneId, "DZH", "CH");
		match(basicPhoneId, "Z", "S");
		match(basicPhoneId, "ZH", "SH");
		return partnerBasicPhoneId;
	}

	bool isUnvoicedCharUk(wchar_t ch)
	{
		// êïñòôõøö÷
		// ÊÏÑÒÔÕØÖ×
		return
			ch == L'ê' || ch == L'Ê' ||
			ch == L'ï' || ch == L'Ï' ||
			ch == L'ñ' || ch == L'Ñ' ||
			ch == L'ò' || ch == L'Ò' ||
			ch == L'ô' || ch == L'Ô' ||
			ch == L'õ' || ch == L'Õ' ||
			ch == L'ø' || ch == L'Ø' ||
			ch == L'ö' || ch == L'Ö' ||
			ch == L'÷' || ch == L'×';
	}

#ifdef PG_HAS_JULIUS
	std::tuple<bool, const char*> loadPronunciationVocabulary(const std::wstring& vocabFilePathAbs, std::map<std::wstring, std::vector<std::string>>& wordToPhoneList, const QTextCodec& textCodec)
	{
		// file contains text in Windows-1251 encoding
		QFile file(QString::fromStdWString(vocabFilePathAbs));
		if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			return std::make_tuple(false, "Can't open file");

		// 
		std::array<char, 1024> lineBuff;

		// each line has a format:
		// sure\tsh u e\n
		while (true) {
			auto readBytes = file.readLine(lineBuff.data(), lineBuff.size());
			if (readBytes == -1) // EOF
			{
				break;
			}

			// read the first word

			char* pMutStr = lineBuff.data(); // note, strtok modifies the buffer
			char* pMutStrNext = nullptr;

			const char* DictDelim = " \t\n";

			// strtok seems to be quicker than std::regex or QString::split approaches
			pMutStr = strtok_s(pMutStr, DictDelim, &pMutStrNext);
			if (pMutStr == nullptr)
			{
				// the line contains only the whitespace
				continue;
			}

			QString word = textCodec.toUnicode(pMutStr);

			// read the tail of phones
			std::vector<std::string> phones;
			while (true)
			{
				pMutStr = strtok_s(nullptr, DictDelim, &pMutStrNext);
				if (pMutStr == nullptr)
					break;

				auto len = strlen(pMutStr);
				std::string phoneStr(pMutStr, len);
				phones.push_back(std::move(phoneStr));
			}

			wordToPhoneList.insert(std::make_pair<std::wstring, std::vector<std::string>>(word.toStdWString(), std::move(phones)));
		}

		return std::make_tuple(true, nullptr);
	}
#endif

	void parsePronId(boost::wstring_view pronId, boost::wstring_view& pronName)
	{
		size_t openBraceInd = pronId.find(L'(');
		if (openBraceInd == boost::wstring_view::npos)
		{
			pronName = pronId;
			return;
		}
		pronName = pronId.substr(0, openBraceInd);
	}

	bool isWordStressAssigned(const PhoneRegistry& phoneReg, const std::vector<PhoneId>& phoneIds)
	{
		int numVowels = 0;
		int numStressedVowels = 0;
		for (PhoneId phoneId : phoneIds)
		{
			const Phone* phone = phoneReg.phoneById(phoneId);
			if (phone->IsStressed == true)
				numStressedVowels++;
			const BasicPhone* basicPhone = phoneReg.basicPhone(phone->BasicPhoneId);
			if (basicPhone->DerivedFromChar == CharGroup::Vowel)
				numVowels++;
		}
		return numStressedVowels > 0 || numVowels == 0;
	}

	bool isPronCodeDefinesStress(boost::wstring_view pronCode)
	{
		return pronCode.ends_with(L')');
	}

	bool parsePronCodeNameAndStress(boost::wstring_view pronCode, boost::wstring_view* pronCodeName, boost::wstring_view* pronCodeStressSuffix)
	{
		size_t closeParInd = pronCode.find_last_of(L')');
		if (closeParInd == boost::wstring_view::npos)
		{
			*pronCodeName = pronCode;
			*pronCodeStressSuffix = boost::wstring_view();
			return true;
		}

		size_t openParInd = pronCode.find_last_of(L'(');
		if (openParInd == boost::wstring_view::npos)
			return false; // invalid pronCode format

		const wchar_t* numStr = pronCode.data() + openParInd + 1;
		int stress = -1;
		int numRead = swscanf(numStr, L"%d)", &stress);
		if (numRead != 1) // single digit in parenthesis
			return false; // can't parse number
		
		*pronCodeName = boost::wstring_view(pronCode.data(), openParInd);
		*pronCodeStressSuffix = boost::wstring_view(numStr, closeParInd - openParInd-1);
		return true;
	}

	std::tuple<bool, const char*> loadPhoneticDictionaryPronIdPerLine(const std::basic_string<wchar_t>& vocabFilePathAbs, const PhoneRegistry& phoneReg,
		const QTextCodec& textCodec, std::vector<PhoneticWord>& words, std::vector<std::string>& brokenLines,
		GrowOnlyPinArena<wchar_t>& stringArena)
	{
		// file contains text in Windows-1251 encoding
		QFile file(QString::fromStdWString(vocabFilePathAbs));
		if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			return std::make_tuple(false, "Can't open file");

		// 
		std::array<char, 1024> lineBuff;
		std::array<wchar_t, 64> wordBuff;
		PhoneticWord curPronGroup;
		std::vector<PhoneId> phones;

		// each line has a format:
		// sure\tsh u e\n
		while (true) {
			auto readBytes = file.readLine(lineBuff.data(), lineBuff.size());
			if (readBytes == -1) // EOF
				break;

			if (readBytes < 3) // 3=min length of Word->PhoneList
				continue;

			boost::string_view line(lineBuff.data(), readBytes);
			if (line.back() == '\n')
				line.remove_suffix(1);

			const char* DictDelim = " \t\n";
			size_t phoneListInd = line.find_first_of(DictDelim);
			if (phoneListInd == boost::string_view::npos)
				return std::make_tuple(false, "The word is too long (>1024 bytes)");

			int wordSize = phoneListInd;
			if (wordSize == 0) // empty line
				continue;

			boost::string_view phoneListRef;
			auto isBrokenLine = [&]() -> bool
			{
				if (wordSize > wordBuff.size()) // word buff can't fit the word
					return true;

				phoneListRef = line.substr(phoneListInd + 1);
				if (phoneListRef.empty()) // word without the list of phones
					return true;

				// parsing requires phone list to be uppercase
				std::transform(phoneListRef.begin(), phoneListRef.end(), (char*)phoneListRef.begin(), toupper);

				phones.clear();
				bool parseOp = parsePhoneList(phoneReg, phoneListRef, phones);
				if (!parseOp)
					return true;
				return false;
			};

			if (isBrokenLine())
			{
				brokenLines.push_back(lineBuff.data());
				continue;
			}

			QString word = textCodec.toUnicode(line.data(), phoneListInd);
			int copiedSize = word.toWCharArray(wordBuff.data());
			PG_DbgAssert(copiedSize == word.size());

			boost::wstring_view wordRef = boost::wstring_view(wordBuff.data(), word.size());
			boost::wstring_view arenaWordRef;
			if (!registerWord(wordRef, stringArena, arenaWordRef))
			{
				brokenLines.push_back(lineBuff.data());
				continue;
			}

			if (curPronGroup.Word.compare(wordRef) != 0)
			{
				// finish previous pronunciation group
				if (!curPronGroup.Word.empty())
				{
					words.push_back(curPronGroup);
					curPronGroup.Word.clear();
					curPronGroup.Pronunciations.clear();
				}

				// start new group
				PG_DbgAssert2(curPronGroup.Pronunciations.empty(), "Old pronunciation data must be purged");
				curPronGroup.Word = arenaWordRef;
			}

			PronunciationFlavour pron;
			pron.PronCode = arenaWordRef;
			pron.Phones = phones;
			curPronGroup.Pronunciations.push_back(pron);
		}

		if (!curPronGroup.Word.empty())
		{
			words.push_back(curPronGroup);
			curPronGroup.Word.clear();
			curPronGroup.Pronunciations.clear();
		}
		return std::make_tuple(true, nullptr);
	}

	void trimPhoneStrExtraInfos(const std::string& phoneStdStr, std::string& phoneStrTrimmed, bool toUpper, bool trimNumbers)
	{
		QString phoneStr = QString::fromStdString(phoneStdStr);
		if (trimNumbers)
		{
			if (phoneStr[phoneStr.size() - 1].isDigit())
			{
				phoneStr = phoneStr.left(phoneStr.size() - 1); // remove last digit
			}
		}
		if (toUpper)
			phoneStr = phoneStr.toUpper();
		phoneStrTrimmed = phoneStr.toStdString();
	}

	void normalizePronunciationVocabulary(std::map<std::wstring, std::vector<Pronunc>>& wordToPhoneList, bool toUpper, bool trimNumbers)
	{
		std::string phoneStrTrimmed;
		for (auto& pair : wordToPhoneList)
		{
			std::vector<Pronunc>& prons = pair.second;
			for (auto& pron : prons)
			{
				for (auto& phone : pron.Phones)
				{
					trimPhoneStrExtraInfos(phone, phoneStrTrimmed, toUpper, trimNumbers);
					phone = phoneStrTrimmed;
				}
			}

			std::sort(std::begin(prons), std::end(prons));
			auto it = std::unique(std::begin(prons), std::end(prons));
			size_t newSize = std::distance(std::begin(prons), it);
			prons.resize(newSize);
		}
	}

	boost::optional<PhoneId> parsePhoneStr(const PhoneRegistry& phoneReg, boost::string_view phoneStrRef)
	{
		if (phoneStrRef.empty())
			return boost::none;

		boost::string_view basicPhoneStrRef = phoneStrRef;

		// truncate last digit
		char ch = phoneStrRef.back();
		bool lastIsDigit = ::isdigit(ch);
		if (lastIsDigit)
			basicPhoneStrRef.remove_suffix(1);

		bool basicOp = false;
		std::string basicPhoneStr = std::string(basicPhoneStrRef.data(), basicPhoneStrRef.size());
		PhoneRegistry::BasicPhoneIdT basicPhoneId = phoneReg.basicPhoneId(basicPhoneStr, &basicOp);
		if (!basicOp)
			return boost::none;
		const BasicPhone* basicPhone = phoneReg.basicPhone(basicPhoneId);

		// defaults for phone name without a number suffix
		boost::optional<SoftHardConsonant> softHard = boost::none;
		if (basicPhone->DerivedFromChar == CharGroup::Consonant)
			softHard = phoneReg.defaultSoftHardConsonant();

		boost::optional<bool> isStressed = boost::none;
		if (basicPhone->DerivedFromChar == CharGroup::Vowel)
			isStressed = phoneReg.defaultIsVowelStressed();

		if (lastIsDigit)
		{
			// number on a consonant derived phone means half-softness for usually hard consonants and softness for other consonants
			if (basicPhone->DerivedFromChar == CharGroup::Consonant)
			{
				std::array<char, 2> digitBuf = { ch, 0 };
				int lastDigit = std::atoi(digitBuf.data());

				if (lastDigit == 1)
					softHard = SoftHardConsonant::Soft;
				else if (lastDigit == 2)
					softHard = SoftHardConsonant::Palatal;
				else return boost::none; // unknown number modifier
			}

			// number on a vowel derived phone means stress
			else if (basicPhone->DerivedFromChar == CharGroup::Vowel)
				isStressed = true;
		}

		boost::optional<PhoneId> result = phoneReg.phoneIdSingle(basicPhoneId, softHard, isStressed);
		return result;
	}

	bool parsePhoneList(const PhoneRegistry& phoneReg, boost::string_view phoneListStr, std::vector<PhoneId>& result)
	{
		boost::string_view curPhonesStr = phoneListStr;
		while (!curPhonesStr.empty())
		{
			size_t sepPos = curPhonesStr.find(' ');
			if (sepPos == boost::string_view::npos)
				sepPos = curPhonesStr.size();

			boost::string_view phoneRef = curPhonesStr.substr(0, sepPos);
			if (phoneRef.empty()) // a phone can't be an empty string
				continue;

			boost::optional<PhoneId> phoneId = parsePhoneStr(phoneReg, phoneRef);
			if (!phoneId)
				return false;

			result.push_back(phoneId.get());

			curPhonesStr.remove_prefix(sepPos + 1);
		}
		return true;
	}

	std::tuple<bool, const char*> parsePronuncLinesNew(const PhoneRegistry& phoneReg, const std::wstring& prons, std::vector<PronunciationFlavour>& result, GrowOnlyPinArena<wchar_t>& stringArena)
	{
		QString pronsQ = QString::fromStdWString(prons);
		QStringList pronItems = pronsQ.split('\n', QString::SkipEmptyParts);
		for (int pronInd = 0; pronInd < pronItems.size(); ++pronInd)
		{
			QString pronLine = pronItems[pronInd];
			int pronAsWordEndInd = pronLine.indexOf('\t');
			if (pronAsWordEndInd == -1)
				return std::make_tuple(false, "First part of line doesn't contain pronunciation id");

			QString pronAsWord = pronLine.left(pronAsWordEndInd);
			boost::wstring_view arenaPronAsWord;
			if (!registerWord(pronAsWord, stringArena, arenaPronAsWord))
				return std::make_tuple(false, "Can't allocate word");

			//
			QString phonesStr = pronLine.mid(pronAsWordEndInd + 1);

			std::vector<PhoneId> phones;
			bool parseOp = parsePhoneList(phoneReg, phonesStr.toStdString(), phones);
			if (!parseOp)
				return std::make_tuple(false, "Can't parse the list of phones");

			PronunciationFlavour pron;
			pron.PronCode = arenaPronAsWord;
			pron.Phones = std::move(phones);
			result.push_back(pron);
		}
		return std::make_tuple(true, nullptr);
	}

	bool phoneToStr(const PhoneRegistry& phoneReg, int phoneId, std::string& result)
	{
		const Phone* phone = phoneReg.phoneById(phoneId);
		if (phone == nullptr)
			return false;
		const BasicPhone* basicPh = phoneReg.basicPhone(phone->BasicPhoneId);
		result = basicPh->Name;

		const char SoftDecorator = '1';
		const char PalatalDecorator = '2';

		if (phoneReg.allowSoftHardConsonant()) // is soft consonant
		{
			     if (phone->SoftHard == SoftHardConsonant::Hard) { }
			else if (phone->SoftHard == SoftHardConsonant::Soft)
				result.push_back(SoftDecorator);
			else if (phone->SoftHard == SoftHardConsonant::Palatal)
			{
				     if (phoneReg.palatalSupport() == PalatalSupport::AsHard) { }
				else if (phoneReg.palatalSupport() == PalatalSupport::AsSoft)
					result.push_back(SoftDecorator);
				else if (phoneReg.palatalSupport() == PalatalSupport::AsPalatal)
					result.push_back(PalatalDecorator);
			}
		}
		if (phoneReg.allowVowelStress() && phone->IsStressed == true)
			result.push_back('1');

		return true;
	}

	bool phoneToStr(const PhoneRegistry& phoneReg, PhoneId phoneId, std::string& result)
	{
		return phoneToStr(phoneReg, phoneId.Id, result);
	}

	bool phoneListToStr(const PhoneRegistry& phoneReg, wv::slice<PhoneId> phones, std::string& result)
	{
		if (phones.empty())
			return true;

		std::string phStr;
		if (!phoneToStr(phoneReg, phones.front(), phStr))
			return false;
		result += phStr;

		for (int i = 1; i < phones.size(); ++i)
		{
			result.push_back(' ');

			if (!phoneToStr(phoneReg, phones[i], phStr))
				return false;
			result += phStr;
		}
		return true;
	}

	bool WordPhoneticTranscriber::hasError() const
	{
		return !errString_.empty();
	}

	const std::wstring& WordPhoneticTranscriber::errorString() const
	{
		return errString_;
	}

	void WordPhoneticTranscriber::tryInitStressedVowels()
	{
		isLetterStressed_.resize(word_->size());
		std::fill(isLetterStressed_.begin(), isLetterStressed_.end(), (char)-1);

		int stressedCharInd = -1;
		if (getStressedVowelCharIndAtMostOne(*word_, stressedCharInd) && stressedCharInd != -1)
		{
			isLetterStressed_[stressedCharInd] = (char)true;
			return;
		}

		// fallback to dictionary lookup
		std::vector<int> stressedSyllables;
		if (stressedSyllableIndFun_ != nullptr && stressedSyllableIndFun_(*word_, stressedSyllables))
		{
			// set all vowels unstressed
			for (size_t charInd = 0; charInd < word_->size(); ++charInd)
			{
				if (isUkrainianVowel((*word_)[charInd]))
					isLetterStressed_[charInd] = (char)false;
			}
			for (int stressedSyllable : stressedSyllables)
			{
				int charInd = syllableIndToVowelCharIndUk(*word_, stressedSyllable);
				if (charInd == -1)
				{
					errString_ = L"Invalid stressed syllable was provided";
					return;
				}
				isLetterStressed_[charInd] = (char)true;
			}
		}
	}

	void WordPhoneticTranscriber::transcribe(const PhoneRegistry& phoneReg, const std::wstring& word)
	{
		PG_Assert(&phoneReg != nullptr);
		phoneReg_ = &phoneReg;
		word_ = &word;
		errString_.clear();
		billetPhones_.clear();
		outputPhones_.clear();
		phoneIndToLetterInd_.clear();
		isLetterStressed_.clear();

		tryInitStressedVowels();
		if (hasError())
			return;

		for (letterInd_ = 0; letterInd_ < word.size(); ++letterInd_)
		{
			if (hasError())
				return;
			
			bool anyRuleWasApplied = false;

			auto tryRule = [this, &anyRuleWasApplied](decltype(&WordPhoneticTranscriber::ruleIgnore) ruleFun) -> void
			{
				if (hasError() || anyRuleWasApplied)
					return;
				anyRuleWasApplied = (this->*ruleFun)();
			};
			tryRule(&WordPhoneticTranscriber::ruleIgnore);
			tryRule(&WordPhoneticTranscriber::ruleJi);
			tryRule(&WordPhoneticTranscriber::ruleShCh);
			tryRule(&WordPhoneticTranscriber::ruleDzDzh);
			tryRule(&WordPhoneticTranscriber::ruleZhDzh);
			tryRule(&WordPhoneticTranscriber::ruleNtsk);
			tryRule(&WordPhoneticTranscriber::ruleSShEtc);
			tryRule(&WordPhoneticTranscriber::ruleTsEtc);
			tryRule(&WordPhoneticTranscriber::ruleSoftSign);
			tryRule(&WordPhoneticTranscriber::ruleApostrophe);
			tryRule(&WordPhoneticTranscriber::ruleHardConsonantBeforeE);
			tryRule(&WordPhoneticTranscriber::ruleSoftConsonantBeforeI);
			tryRule(&WordPhoneticTranscriber::ruleDoubleJaJeJu);
			tryRule(&WordPhoneticTranscriber::ruleSoftConsonantBeforeJaJeJu);
			tryRule(&WordPhoneticTranscriber::ruleDampVoicedConsonantBeforeUnvoiced);
			tryRule(&WordPhoneticTranscriber::ruleDefaultSimpleOneToOneMap);

			if (!anyRuleWasApplied && 
				errString_.empty()) // avoid overwriting existing error
			{
				wchar_t letter = word[letterInd_];
				errString_ = std::wstring(L"Unknown letter ") + letter;
				return;
			}
		}
		
		postRulePairOfConsonantsSoftenEachOther();
		postRuleAmplifyUnvoicedConsonantBeforeVoiced();

		buildOutputPhones();
	}

	void WordPhoneticTranscriber::copyOutputPhoneIds(std::vector<PhoneId>& phoneIds) const
	{
		std::copy(outputPhones_.begin(), outputPhones_.end(), std::back_inserter(phoneIds));
	}

	void WordPhoneticTranscriber::setStressedSyllableIndFun(decltype(stressedSyllableIndFun_) stressedSyllableFun)
	{
		stressedSyllableIndFun_ = stressedSyllableFun;
	}

	wchar_t WordPhoneticTranscriber::curLetter() const
	{
		return (*word_)[letterInd_];
	}

	boost::optional<bool> WordPhoneticTranscriber::isCurVowelStressed() const
	{
		wchar_t letter = curLetter();
		PG_DbgAssert(isUkrainianVowel(letter));
		char isStressed = isLetterStressed_[letterInd_];
		return isStressed == (char)-1 ? nullptr : (bool)isStressed;
	}

	wchar_t WordPhoneticTranscriber::offsetLetter(int offset) const
	{
		int newIndex = static_cast<int>(letterInd_) + offset;
		PG_DbgAssert(newIndex >= 0 && newIndex < word_->size());
		return (*word_)[newIndex];
	}

	bool WordPhoneticTranscriber::isFirstLetter() const
	{
		PG_Assert(!word_->empty());
		return letterInd_ == 0;
	}

	bool WordPhoneticTranscriber::isLastLetter() const
	{
		PG_Assert(!word_->empty());
		return letterInd_ == word_->size() - 1;
	}
	
	bool WordPhoneticTranscriber::ruleIgnore()
	{
		wchar_t letter = curLetter();
		return letter == Letter_Hyphen || letter == Letter_Space;
	}

	bool WordPhoneticTranscriber::ruleJi()
	{
		bool accept = curLetter() == Letter_JI;
		if (!accept)
			return false;

		// Rule: letter JI always converts as J and I
		addPhone(newConsonantPhone("J", SoftHardConsonant::Hard));
		addPhone(newVowelPhone("I", isCurVowelStressed()));
		return true;
	}
	
	bool WordPhoneticTranscriber::ruleShCh()
	{
		bool accept = curLetter() == Letter_SHCH;
		if (!accept)
			return false;

		addPhone(newConsonantPhone("SH", SoftHardConsonant::Hard));
		addPhone(newConsonantPhone("CH", SoftHardConsonant::Hard));
		return true;
	}

	bool WordPhoneticTranscriber::ruleDzDzh()
	{
		bool accept = curLetter() == Letter_D && !isLastLetter();
		if (!accept)
			return false;

		wchar_t nextLetter = offsetLetter(1);
		if (nextLetter == Letter_Z)
		{
			addPhone(newConsonantPhone("DZ", boost::none));
			letterInd_ += 1; // skip next letter
			return true;
		}
		else if (nextLetter == Letter_ZH)
		{
			addPhone(newConsonantPhone("DZH", SoftHardConsonant::Hard));
			letterInd_ += 1; // skip next letter
			return true;
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleZhDzh()
	{
		bool accept = curLetter() == Letter_Z && !isLastLetter();
		if (!accept)
			return false;

		wchar_t nextLetter = offsetLetter(1);

		// Z ZH -> ZH ZH
		// çæåð [ZH ZH E R]
		if (nextLetter == Letter_ZH)
		{
			// skip first T
			addPhone(newConsonantPhone("ZH", SoftHardConsonant::Hard));
			addPhone(newConsonantPhone("ZH", SoftHardConsonant::Hard));
			letterInd_ += 1;
			return true;
		}

		if (letterInd_ + 2 < word_->size()) // size(D ZH)=2
		{
			// Z D ZH -> ZH DZH
			// ç'¿çäæàþòü [Z J I ZH DZH A J U T]
			if (nextLetter == Letter_D && offsetLetter(2) == Letter_ZH)
			{
				// skip first T
				addPhone(newConsonantPhone("ZH", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("DZH", SoftHardConsonant::Hard));
				letterInd_ += 2;
				return true;
			}
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleNtsk()
	{
		bool accept = curLetter() == Letter_N;
		if (!accept)
			return false;
		if (letterInd_ + 3 < word_->size()) // size(T S T)=3
		{
			// N T S T -> N S T
			if (offsetLetter(1) == Letter_T && offsetLetter(2) == Letter_S && offsetLetter(3) == Letter_T)
			{
				// skip first T
				addPhone(newConsonantPhone("N", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("S", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("T", SoftHardConsonant::Hard));
				letterInd_ += 3;
				return true;
			}
		}
		if (letterInd_ + 4 < word_->size()) // size(T S 1 K)=4
		{
			// N T S 1 K -> N S1 K
			if (offsetLetter(1) == Letter_T && offsetLetter(2) == Letter_S && offsetLetter(3) == Letter_SoftSign && offsetLetter(4) == Letter_K)
			{
				// skip first T
				addPhone(newConsonantPhone("N", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("S", SoftHardConsonant::Soft));
				addPhone(newConsonantPhone("K", SoftHardConsonant::Hard));
				letterInd_ += 4;
				return true;
			}
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleSShEtc()
	{
		bool accept = curLetter() == Letter_S;
		if (!accept)
			return false;
		if (letterInd_ + 1 < word_->size()) // size(SH)=1
		{
			// S SH -> SH SH
			// äîí³ñøè [D O N I SH SH Y]
			if (offsetLetter(1) == Letter_SH)
			{
				addPhone(newConsonantPhone("SH", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("SH", SoftHardConsonant::Hard));
				letterInd_ += 1;
				return true;
			}
		}
		if (letterInd_ + 2 < word_->size()) // size(T D)=2
		{
			// S T D -> Z D
			// ø³ñòäåñÿò [SH I Z D E S A T]
			if (offsetLetter(1) == Letter_T && offsetLetter(2) == Letter_D)
			{
				addPhone(newConsonantPhone("Z", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("D", SoftHardConsonant::Hard));
				letterInd_ += 2;
				return true;
			}
		}
		// check STS1K group before STS group, because latter is inside the former
		if (letterInd_ + 4 < word_->size()) // size(T S 1 K)=4
		{
			// S T S 1 K -> S1 K
			// íàöèñòñüêî¿ [N A TS Y S1 K O J I]
			if (offsetLetter(1) == Letter_T && offsetLetter(2) == Letter_S && offsetLetter(3) == Letter_SoftSign && offsetLetter(4) == Letter_K)
			{
				addPhone(newConsonantPhone("S", SoftHardConsonant::Soft));
				addPhone(newConsonantPhone("K", SoftHardConsonant::Hard));
				letterInd_ += 4;
				return true;
			}
		}
		if (letterInd_ + 2 < word_->size()) // size(T S)=2
		{
			// S T S -> S S
			// ø³ñòñîò [SH I S S O T]
			if (offsetLetter(1) == Letter_T && offsetLetter(2) == Letter_S)
			{
				addPhone(newConsonantPhone("S", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("S", SoftHardConsonant::Hard));
				letterInd_ += 2;
				return true;
			}
		}
		if (letterInd_ + 2 < word_->size()) // size(T TS)=2
		{
			// S T TS -> S TS
			// â³äïóñòö³ [V I D P U S TS I]
			if (offsetLetter(1) == Letter_T && offsetLetter(2) == Letter_TS)
			{
				addPhone(newConsonantPhone("S", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("TS", SoftHardConsonant::Hard));
				letterInd_ += 2;
				return true;
			}
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleTsEtc()
	{
		bool accept = curLetter() == Letter_T && !isLastLetter();
		if (!accept)
			return false;

		if (letterInd_ + 1 < word_->size()) // size(S)=1
		{
			// T S -> TS
			// ï'ÿòñîò [P J A TS O T]
			if (offsetLetter(1) == Letter_S)
			{
				addPhone(newConsonantPhone("TS", SoftHardConsonant::Hard));
				letterInd_ += 1;
				return true;
			}
		}
		if (letterInd_ + 2 < word_->size()) // size(1 S)=2
		{
			// T 1 S -> TS
			// òðèìàòèìåòüñÿ [T R Y M A T Y M E TS1 A]
			if (offsetLetter(1) == Letter_SoftSign && offsetLetter(2) == Letter_S)
			{
				// if òö -> TS TS
				addPhone(newConsonantPhone("TS", SoftHardConsonant::Soft));
				letterInd_ += 2;
				return true;
			}
		}
		if (letterInd_ + 1 < word_->size()) // size(TS)=1
		{
			// T TS -> TS TS
			// êë³òö³ [K L I TS TS I]
			if (offsetLetter(1) == Letter_TS)
			{
				addPhone(newConsonantPhone("TS", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("TS", SoftHardConsonant::Hard));
				letterInd_ += 1;
				return true;
			}
		}
		if (letterInd_ + 1 < word_->size()) // size(CH)=1
		{
			// T CH -> CH CH
			// îò÷å [O CH CH E]
			if (offsetLetter(1) == Letter_CH)
			{
				addPhone(newConsonantPhone("CH", SoftHardConsonant::Hard));
				addPhone(newConsonantPhone("CH", SoftHardConsonant::Hard));
				letterInd_ += 1;
				return true;
			}
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleSoftSign()
	{
		bool accept = curLetter() == Letter_SoftSign;
		if (!accept)
			return false;

		// soften the previous char
		if (!billetPhones_.empty())
		{
			PhoneBillet& ph = billetPhones_.back();
			bool ok = ph.DerivedFromChar == CharGroup::Consonant;
			if (!ok)
				return false; // Only consonant can be softened
			ph.SoftHard = SoftHardConsonant::Soft;
			return true;
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleApostrophe()
	{
		bool accept = curLetter() == Letter_Apostrophe;
		if (!accept)
			return false;

		// soften the previous char
		if (!billetPhones_.empty())
		{
			PhoneBillet& ph = billetPhones_.back();
			bool hardingConsonant = ph.DerivedFromChar == CharGroup::Consonant;
			if (hardingConsonant)
				ph.SoftHard = SoftHardConsonant::Hard;
			else
			{
				// apostrophe after vowel may be used in uk->en transliteration eg. "he's -> õ³'ç"
				// accept it; do no action
			}
			return true;
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleHardConsonantBeforeE()
	{
		bool accept = curLetter() == Letter_E && !billetPhones_.empty();
		if (!accept)
			return false;
		
		// Rule: the vowel E dictates that the previous consonant is always hard
		PhoneBillet& prevPh = billetPhones_.back();
		if (prevPh.DerivedFromChar == CharGroup::Consonant)
		{
			boost::optional<SoftHardConsonant> prevValue = prevPh.SoftHard;
			if (prevValue != boost::none)
			{
				
				bool ok = prevValue == SoftHardConsonant::Hard || prevValue == SoftHardConsonant::Palatal;
				if (!ok)
				{
					// for eg for Russian word "÷üåé"
					errString_ = L"hard and usually hard consonants can become hard";
					return false;
				}
			}
			prevPh.SoftHard = SoftHardConsonant::Hard;
			addPhone(newVowelPhone("E", isCurVowelStressed()));
			return true;
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleSoftConsonantBeforeI()
	{
		bool accept = curLetter() == Letter_I && !billetPhones_.empty();
		if (!accept)
			return false;
		
		// Rule: the vowel E dictates that the previous consonant is always hard
		PhoneBillet& prevPh = billetPhones_.back();
		if (prevPh.DerivedFromChar == CharGroup::Consonant)
		{
			if (usuallyHardBasicPhone(*phoneReg_, prevPh.BasicPhoneId))
			{
				// Consonants (B,P,V,M,F), (H,K,KH,G), (CH,DZH,SH,ZH) become palatilized (half-softened) before sound I.
				prevPh.SoftHard = SoftHardConsonant::Palatal;
			}
			else
			{
				// Rule: the vowel I dictates that the previous consonant is always soft
				prevPh.SoftHard = SoftHardConsonant::Soft;
			}
			addPhone(newVowelPhone("I", isCurVowelStressed()));
			return true;
		}
		return false;
	}
	

	bool WordPhoneticTranscriber::ruleDoubleJaJeJu()
	{
		wchar_t letter = curLetter();
		bool accept = letter == Letter_JE || letter == Letter_JU || letter == Letter_JA;
		if (!accept)
			return false;
		
		// Rule: JA -> J A when it is the first letter
		// ºâðåé [J E V R E J]
		// þíàê [J U N A K]
		// ÿáëóêî [J A B L U K O]
		// Rule: JA -> J A when the previous letter is a vowel
		// âçàºìíî [V Z A J E M N O]
		// íàñòîþ [N A S T O J U]
		// àáèÿê [A B Y J A K]
		// Rule: JA -> J A when the previous letter is the soft sign
		// êîíüÿêó[K O N1 J A K]
		// ìîñüº [M O S1 J E]
		// íüþ [N1 J U]
		// "áóäü-ÿêà" [B U D1 J A K A]
		// Rule: JA -> J A when the previous letter is the apostrophe
		// áóð'ÿí [B U R J A N]
		// êàð'ºð [K A R J E R]
		// êîìï'þòåð [K O M P J U T E R]
		auto dualPhone = [this]() ->bool {
			if (isFirstLetter())
				return true;

			// the first letter of a compound word
			wchar_t prevLetter = offsetLetter(-1);
			if (prevLetter == Letter_Hyphen)
				return true;

			//
			bool prevVowel = isUkrainianVowel(prevLetter);
			if (prevVowel)
				return true;
			
			bool prevSoftSign = prevLetter == Letter_SoftSign;
			if (prevSoftSign)
				return true;

			bool prevApostrophe = prevLetter == Letter_Apostrophe;
			if (prevApostrophe)
				return true;

			return false;
		};
		bool doublePhone = dualPhone();
		if (!doublePhone)
			return false;

		PhoneBillet curPh;
		if (!makePhoneFromCurLetterOneToOne(curPh)) // try to create current phone before modifying the collection
			return false;

		addPhone(newConsonantPhone("J", SoftHardConsonant::Hard));
		addPhone(curPh);
		return true;
	}

	bool WordPhoneticTranscriber::ruleSoftConsonantBeforeJaJeJu()
	{
		wchar_t letter = curLetter();
		bool accept = (letter == Letter_JU || letter == Letter_JA || letter == Letter_JE) && !billetPhones_.empty();
		if (!accept)
			return false;
		// ëþäè [L1 U D Y]
		// îëåêñþê [O L E K S1 U K]
		// áóðþ [B U R1 U]
		// ëÿêàòè [L1 A K A T Y]
		// áóðÿ [B U R1 A]
		// çîðÿíèé [Z O R1 A N Y J]
		PhoneBillet& prevPh = billetPhones_.back();
		if (prevPh.DerivedFromChar == CharGroup::Consonant)
		{
			SoftHardConsonant softDegree;
			if (usuallyHardBasicPhone(*phoneReg_, prevPh.BasicPhoneId))
			{
				softDegree = SoftHardConsonant::Palatal;
			}
			else
			{
				// easily soft consonant
				softDegree = SoftHardConsonant::Soft;
			}
			prevPh.SoftHard = softDegree;

			// ëëº [L1 L1 E1]
			// ñóòòºâî [S U T T E V O]
			// ìîäåëëþ [M O D E L1 L1 U]
			// ³ëëÿ [I L1 L1 A]
			int prevPrevInd = (int)billetPhones_.size() - 2;
			if (prevPrevInd >= 0)
			{
				PhoneBillet& prevPrevPh = billetPhones_[prevPrevInd];
				if (prevPrevPh.BasicPhoneId == prevPh.BasicPhoneId)
					prevPrevPh.SoftHard = softDegree;
			}

			PhoneBillet curPh;
			if (makePhoneFromCurLetterOneToOne(curPh))
				return false;
			addPhone(curPh);
			return true;
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleDampVoicedConsonantBeforeUnvoiced()
	{
		wchar_t letter = curLetter();
		bool accept = (letter == Letter_B || letter == Letter_H || letter == Letter_D || letter == Letter_ZH || letter == Letter_Z) && !isLastLetter();
		if (!accept)
			return false;

		// B->P, H->KH, D->T, ZH->SH, Z->S before unvoiced sound
		// B->P íåîáõ³äíî [N E O P KH I D N O]
		// H->KH äîïîìîãòè [D O P O M O KH T Y]
		// D->T øâèäêî [SH V Y T K O]
		// ZH->SH äóæ÷å [D U SH CH E]
		// Z->S áåçïåêè [B E S P E K A]
		bool beforeUnvoiced = false;
		{
			wchar_t nextLetter = offsetLetter(1);
			if (isUnvoicedCharUk(nextLetter))
				beforeUnvoiced = true;
			else
			{
				// check if the next letter is a soft sign and only then is the unvoiced consonant
				if (nextLetter == Letter_SoftSign)
				{
					if (letterInd_ + 2 < word_->size())
					{
						wchar_t nextNextLetter = offsetLetter(2);
						if (isUnvoicedCharUk(nextNextLetter))
							beforeUnvoiced = true;
					}
				}
			}
		}
		if (beforeUnvoiced)
		{
			PhoneBillet ph;
			if (letter == Letter_B)
				ph = newConsonantPhone("P", SoftHardConsonant::Hard);
			else if (letter == Letter_H)
				ph = newConsonantPhone("KH", SoftHardConsonant::Hard);
			else if (letter == Letter_D)
				ph = newConsonantPhone("T", boost::none);
			else if (letter == Letter_ZH)
				ph = newConsonantPhone("SH", SoftHardConsonant::Hard);
			else if (letter == Letter_Z)
				ph = newConsonantPhone("S", boost::none);
			else PG_Assert(false);

			addPhone(ph);
			return true;
		}
		return false;
	}

	bool WordPhoneticTranscriber::ruleDefaultSimpleOneToOneMap()
	{
		// default char->phone mapping
		PhoneBillet ph;
		bool makeOp = makePhoneFromCurLetterOneToOne(ph);
		if (!makeOp)
			return false;
		addPhone(ph);
		return true;
	}

	bool WordPhoneticTranscriber::isMutuallySoftConsonant(Phone::BasicPhoneIdT basicPhoneId) const
	{
		bool suc = true;
		bool foundMatch = false; // whether got the match
		auto matchPhone = [this, &suc, &foundMatch](Phone::BasicPhoneIdT expectBasicPhoneId, const std::string& queryBasicPhoneStr) -> void
		{
			if (!suc || foundMatch)
				return;
			Phone::BasicPhoneIdT basicId = phoneReg_->basicPhoneId(queryBasicPhoneStr, &suc);
			if (suc && expectBasicPhoneId == basicId)
				foundMatch = true;
		};
		matchPhone(basicPhoneId, "D");
		matchPhone(basicPhoneId, "DZ");
		matchPhone(basicPhoneId, "T");
		matchPhone(basicPhoneId, "TS");
		matchPhone(basicPhoneId, "Z");
		matchPhone(basicPhoneId, "S");
		matchPhone(basicPhoneId, "N");
		matchPhone(basicPhoneId, "L");
		PG_DbgAssert(suc);
		return foundMatch;
	}

	void WordPhoneticTranscriber::postRulePairOfConsonantsSoftenEachOther()
	{
		for (int i = static_cast<int>(billetPhones_.size()) - 1; i > 0; --i)
		{
			const PhoneBillet& right = billetPhones_[i];
			PhoneBillet& left = billetPhones_[i - 1];
			if (left.DerivedFromChar == CharGroup::Consonant &&
				right.DerivedFromChar == CharGroup::Consonant &&
				right.SoftHard == SoftHardConsonant::Soft &&
				isMutuallySoftConsonant(left.BasicPhoneId) &&
				isMutuallySoftConsonant(right.BasicPhoneId))
			{
				left.SoftHard = SoftHardConsonant::Soft;
			}
		}
	}

	void WordPhoneticTranscriber::postRuleAmplifyUnvoicedConsonantBeforeVoiced()
	{
		// Rule: unvoiced consonant becomes voiced before another voiced consonant
		for (int phInd = static_cast<int>(billetPhones_.size()) - 1; phInd > 0; phInd--)
		{
			PhoneBillet& prevPh = billetPhones_[phInd - 1];
			const PhoneBillet& ph = billetPhones_[phInd];

			if (isNoisyUnvoicedConsonant(*phoneReg_, prevPh.BasicPhoneId) && isNoisyVoicedConsonant(*phoneReg_, ph.BasicPhoneId))
			{
				boost::optional<PhoneRegistry::BasicPhoneIdT> partnerBasicPhoneId = getVoicedUnvoicedConsonantPair(*phoneReg_, prevPh.BasicPhoneId);
				PG_Assert2(partnerBasicPhoneId != boost::none, "Can't find paired consonant");

				const BasicPhone* partnerBasicPhone = phoneReg_->basicPhone(partnerBasicPhoneId.get());

				PhoneBillet newPhone = newConsonantPhone(partnerBasicPhone->Name, prevPh.SoftHard);
				billetPhones_[phInd - 1] = newPhone;
			}
		}
	}

	void WordPhoneticTranscriber::buildOutputPhones()
	{
		// build phoneIds sequnces from phone billets
		for (size_t billetInd = 0; billetInd < billetPhones_.size(); ++billetInd)
		{
			const PhoneBillet& ph = billetPhones_[billetInd];
			boost::optional<PhoneId> phoneId = boost::none;
			if (ph.DerivedFromChar == CharGroup::Consonant)
			{
				boost::optional<SoftHardConsonant> softHard = ph.SoftHard;
				if (softHard == boost::none)
					softHard = phoneReg_->defaultSoftHardConsonant();
				phoneId = phoneReg_->phoneIdSingle(ph.BasicPhoneId, softHard, boost::none);
			}
			else if (ph.DerivedFromChar == CharGroup::Vowel)
			{
				boost::optional<bool> isStressed = ph.IsStressed;
				if (isStressed == boost::none)
					isStressed = phoneReg_->defaultIsVowelStressed();
				phoneId = phoneReg_->phoneIdSingle(ph.BasicPhoneId, boost::none, isStressed);
			}
			if (phoneId == boost::none)
			{
				std::wstring phStr;
				phoneBilletToStr(ph, phStr);
				errString_ = std::wstring(L"Can't map phone billet to phoneId. ") + phStr;
				return;
			}
			outputPhones_.push_back(phoneId.get());
		}
	}

	PhoneBillet WordPhoneticTranscriber::newConsonantPhone(const std::string& basicPhoneStr, boost::optional<SoftHardConsonant> SoftHard) const
	{
		bool success = false;
		BasicPhoneIdT basicId = phoneReg_->basicPhoneId(basicPhoneStr, &success);
		PG_Assert2(success, "Unknown basic phone str");

		PhoneBillet billet;
		billet.BasicPhoneId = basicId;
		billet.DerivedFromChar = CharGroup::Consonant;
		billet.SoftHard = SoftHard;
		return billet;
	}

	PhoneBillet WordPhoneticTranscriber::newVowelPhone(const std::string& basicPhoneStr, boost::optional<bool> isStressed) const
	{
		bool success = false;
		BasicPhoneIdT basicId = phoneReg_->basicPhoneId(basicPhoneStr, &success);
		PG_Assert2(success, "Unknown basic phone str");

		PhoneBillet billet;
		billet.BasicPhoneId = basicId;
		billet.DerivedFromChar = CharGroup::Vowel;
		billet.IsStressed = isStressed;
		return billet;
	}

	void WordPhoneticTranscriber::addPhone(const PhoneBillet& phone)
	{
		if (phone.DerivedFromChar == CharGroup::Vowel)
			phoneIndToLetterInd_[billetPhones_.size()] = letterInd_;
		billetPhones_.push_back(phone);
	}

	void WordPhoneticTranscriber::phoneBilletToStr(const PhoneBillet& phone, std::wstring& result) const
	{
		std::wstringstream buf;
		const BasicPhone* basicPhone = phoneReg_->basicPhone(phone.BasicPhoneId);
		if (basicPhone != nullptr)
			buf << QString::fromStdString(basicPhone->Name).toStdWString();
		if (phone.SoftHard != boost::none)
		{
			std::string softHardStr;
			toString(phone.SoftHard.get(), softHardStr);
			buf << L" soft=" << QString::fromStdString(softHardStr).toStdWString();
		}
		if (phone.IsStressed != boost::none)
			buf << L" isStressed=" << phone.IsStressed.get();
		result = buf.str();
	}

	int WordPhoneticTranscriber::getVowelLetterInd(int vowelPhoneInd) const
	{
		auto it = phoneIndToLetterInd_.find(vowelPhoneInd);
		if (it != phoneIndToLetterInd_.end())
			return it -> second;
		return -1;
	}

	bool mapLetterToBasicPhoneInfo(wchar_t letter, boost::string_view& basicPhoneStr, CharGroup& charGroup)
	{
		auto init = [&basicPhoneStr, &charGroup](const char* basicPhoneCStr, CharGroup group)
		{
			basicPhoneStr = basicPhoneCStr;
			charGroup = group;
		};
		switch (letter)
		{
		case L'à':
			init("A", CharGroup::Vowel); break;
		case L'á':
			init("B", CharGroup::Consonant); break;
		case L'â':
			init("V", CharGroup::Consonant); break;
		case L'ã':
			init("H", CharGroup::Consonant); break;
		case L'´':
			init("G", CharGroup::Consonant); break;
		case L'ä':
			init("D", CharGroup::Consonant); break;
		case L'å':
		case L'º':
			init("E", CharGroup::Vowel); break;
		case L'æ':
			init("ZH", CharGroup::Consonant); break;
		case L'ç':
			init("Z", CharGroup::Consonant); break;
		case L'è':
			init("Y", CharGroup::Vowel); break;
		case L'³':
		case L'¿':
			init("I", CharGroup::Vowel); break;
		case L'é':
			init("J", CharGroup::Consonant); break;
		case L'ê':
			init("K", CharGroup::Consonant); break;
		case L'ë':
			init("L", CharGroup::Consonant); break;
		case L'ì':
			init("M", CharGroup::Consonant); break;
		case L'í':
			init("N", CharGroup::Consonant); break;
		case L'î':
			init("O", CharGroup::Vowel); break;
		case L'ï':
			init("P", CharGroup::Consonant); break;
		case L'ð':
			init("R", CharGroup::Consonant); break;
		case L'ñ':
			init("S", CharGroup::Consonant); break;
		case L'ò':
			init("T", CharGroup::Consonant); break;
		case L'ó':
			init("U", CharGroup::Vowel); break;
		case L'ô':
			init("F", CharGroup::Consonant); break;
		case L'õ':
			init("KH", CharGroup::Consonant); break;
		case L'ö':
			init("TS", CharGroup::Consonant); break;
		case L'÷':
			init("CH", CharGroup::Consonant); break;
		case L'ø':
		case L'ù':
			init("SH", CharGroup::Consonant); break;
		case L'þ':
			init("U", CharGroup::Vowel); break;
		case L'ÿ':
			init("A", CharGroup::Vowel); break;
		default:
			return false;
		}
		return true;
	}

	bool WordPhoneticTranscriber::makePhoneFromCurLetterOneToOne(PhoneBillet& ph) const
	{
		wchar_t letter = curLetter();

		boost::string_view basicPhoneStr;
		CharGroup charGroup;
		if (!mapLetterToBasicPhoneInfo(letter, basicPhoneStr, charGroup))
			return false;

		bool success = false;
		BasicPhoneIdT basicId = phoneReg_->basicPhoneId(std::string(basicPhoneStr.data(), basicPhoneStr.size()), &success);
		if (!success)
			return false;

		boost::optional<SoftHardConsonant> softHard = boost::none;
		if (charGroup == CharGroup::Consonant)
			softHard = SoftHardConsonant::Hard;

		boost::optional<bool> isStressed = boost::none;
		if (charGroup == CharGroup::Vowel)
			isStressed = isCurVowelStressed();

		PhoneBillet billet;
		billet.BasicPhoneId = basicId;
		billet.DerivedFromChar = charGroup;
		billet.SoftHard = softHard;
		billet.IsStressed = isStressed;
		ph = billet;

		return true;
	}

	std::tuple<bool, const char*> spellWordUk(const PhoneRegistry& phoneReg, const std::wstring& word, std::vector<PhoneId>& phones,
		WordPhoneticTranscriber::StressedSyllableIndFunT stressedSyllableIndFun)
	{
		WordPhoneticTranscriber phoneticTranscriber;
		phoneticTranscriber.setStressedSyllableIndFun(stressedSyllableIndFun);
		phoneticTranscriber.transcribe(phoneReg, word);
		if (phoneticTranscriber.hasError())
			return std::make_tuple(false, "Can't transcribe word");
		phoneticTranscriber.copyOutputPhoneIds(phones);
		return std::make_tuple(true, nullptr);
	}

	void updatePhoneModifiers(const PhoneRegistry& phoneReg, bool keepConsonantSoftness, bool keepVowelStress, std::vector<PhoneId>& phonesList)
	{
		for (size_t i = 0; i < phonesList.size(); ++i)
		{
			PhoneId phoneId = phonesList[i];

			const Phone* oldPhone = phoneReg.phoneById(phoneId);
			const BasicPhone* basicPhone = phoneReg.basicPhone(oldPhone->BasicPhoneId);

			if (!keepConsonantSoftness && basicPhone->DerivedFromChar == CharGroup::Consonant)
			{
				if (oldPhone->SoftHard == SoftHardConsonant::Soft)
				{
					boost::optional<PhoneId> newPhoneId = phoneReg.phoneIdSingle(oldPhone->BasicPhoneId, SoftHardConsonant::Hard, boost::none);
					PG_DbgAssert(newPhoneId != boost::none);
					phonesList[i] = newPhoneId.get();
					continue;
				}
			}
			if (!keepVowelStress && basicPhone->DerivedFromChar == CharGroup::Vowel)
			{
				if (oldPhone->IsStressed == true)
				{
					boost::optional<PhoneId> newPhoneId = phoneReg.phoneIdSingle(oldPhone->BasicPhoneId, boost::none, false);
					PG_DbgAssert(newPhoneId != boost::none);
					phonesList[i] = newPhoneId.get();
					continue;
				}
			}
		}
	}

	//

	template <typename T>
	bool endsWith(wv::slice<T> items, wv::slice<T> suffix)
	{
		if (suffix.size() > items.size())
			return false; // suffix will not fit the items?

		size_t itemsStartInd = items.size() - suffix.size();
		for (int i = 0; i < suffix.size(); ++i)
		{
			if (suffix[i] == items[itemsStartInd + i])
				continue;
			return false;
		}
		return true;
	}
	template <typename T>
	bool startsWith(wv::slice<T> items, wv::slice<T> prefix)
	{
		if (prefix.size() > items.size())
			return false; // prefix will not fit the items?

		for (int i = 0; i < prefix.size(); ++i)
		{
			if (prefix[i] == items[i])
				continue;
			return false;
		}
		return true;
	}

	// Finds the length of the common prefix of two words.
	template <typename T>
	size_t commonPrefixSize(wv::slice<T> word, wv::slice<T> other)
	{
		size_t minSize = std::min(word.size(), other.size());

		for (size_t i = 0; i < minSize; ++i)
		{
			if (word[i] != other[i])
				return i;
		}
		return minSize;
	}

	struct SuffixEnd
	{
		std::wstring MatchSuffix;
		int TakeCharsCount;
		WordClass WordClass = WordClass::Verb;
		int UsedCount = 0;

		SuffixEnd(const std::wstring& matchSuffix, int takeCharsCount)
			: MatchSuffix(matchSuffix),
			TakeCharsCount(takeCharsCount) {}
		SuffixEnd(const std::wstring& matchSuffix, int takeCharsCount, PticaGovorun::WordClass wordClass)
			: MatchSuffix(matchSuffix),
			TakeCharsCount(takeCharsCount),
			WordClass(wordClass) {}
	};

	std::vector<SuffixEnd> sureSuffixes;
	std::map<std::wstring, std::wstring> participleSuffixToWord;
	std::map<std::wstring, std::wstring> participleSuffixToWord2;

	void ensureSureSuffixesInitialized()
	{
		// good: íàçèâàòè ³ñíóþòü
		// verb+t1
		// èòè
		static std::vector<SuffixEnd> sureSuffixesStatic = {
			{ std::wstring(    L"à"), 1, WordClass::Noun }, // ðó÷ê~à noun
			{ std::wstring(    L"à"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~à ñò~à
			{ std::wstring(    L"à"), 1, WordClass::Adjective }, // áëèæ÷~à adj
			{ std::wstring(  L"àëà"), 2 }, // ñêàçà~ëà
			{ std::wstring(L"óâàëà"), 4 }, // ³ñíó~âàëà àêòóàë³çó~âàëà
			{ std::wstring(L"þâàëà"), 4 }, // áàçàðþ~âàëà
			{ std::wstring(  L"èëà"), 2 }, // æè~ëà áè~ëà
			{ std::wstring(  L"³ëà"), 2 }, // áóðêîò³~ëà
			//{ std::wstring(  L"¿ëà"), 2 }, // áëàãîóñòðî¿~ëà
			{ std::wstring( L"î¿ëà"), 3 }, // áëàãîóñòðî~¿ëà
			{ std::wstring(  L"îëà"), 2 }, // áîðî~ëà
			{ std::wstring(  L"óëà"), 2 }, // áàìêíó~ëà
			{ std::wstring(  L"üìà"), 2, WordClass::Numeral}, // äåâ'ÿòü~ìà
			{ std::wstring(  L"îìà"), 3, WordClass::Numeral}, // äâ~îìà äåâ'ÿòü~îìà
			{ std::wstring(  L"³øà"), 3, WordClass::Adjective }, // àáñóðäí~³øà

			{ std::wstring(  L"àâ"), 1 }, // áóâà~â íàçèâà~â ìà~â âïëèâà~â
			{ std::wstring(L"óâàâ"), 3 }, // àêòóàë³çó~âàâ ³ñíó~âàâ
			{ std::wstring(L"þâàâ"), 3 }, // áàçàðþ~âàâ
			//{ std::wstring(  L"åâ"), 1 }, // ?? NOT äåðåâ~
			{ std::wstring(  L"èâ"), 1 }, // áåç÷åñòè~â áè~â
			{ std::wstring(  L"³â"), 1 }, // áóðêîò³~â
			{ std::wstring(  L"³â"), 2, WordClass::Noun }, // ôóðãîí~³â noun
			{ std::wstring(  L"¿â"), 2, WordClass::Noun }, // àãðàð³~¿â îäíîñòðî~¿â noun
			//{ std::wstring(  L"¿â"), 1 }, // îäíîñòðî¿~â áëàãîóñòðî¿~â
			{ std::wstring( L"³¿â"), 2 }, // áëàãîóñòðî~¿â
			{ std::wstring( L"î¿â"), 2 }, // áëàãîóñòðî~¿â verb
			{ std::wstring(  L"îâ"), 1 }, // áîðî~â (weird word, =áîðîâñÿ)
			{ std::wstring(  L"îâ"), 2, WordClass::Noun }, // öåðê~îâ
			{ std::wstring(  L"óâ"), 1 }, // áàìêíó~â

			{ std::wstring(        L"å"), 1 }, // áåð~å áàìêí~å
			{ std::wstring(        L"å"), 1, WordClass::Adjective }, // áëèæ÷~å áëèçüê~å
			{ std::wstring(        L"å"), 1, WordClass::Noun }, // ôóðãîí~å
			{ std::wstring(        L"å"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~å
			{ std::wstring(      L"èìå"), 2 }, // áðåñòè~ìå
			{ std::wstring(    L"àòèìå"), 4 }, // íàçèâà~òèìå
			{ std::wstring(    L"ÿòèìå"), 4 }, // ðîçìîâëÿ~òèìå
			{ std::wstring(  L"óâàòèìå"), 6 }, // ³ñíó~âà~òèìå àêòóàë³çó~âàòèìå
			{ std::wstring(  L"þâàòèìå"), 6 }, // áàçàðþ~âà~òèìå
			{ std::wstring(    L"èòèìå"), 4 }, // ðîáè~òèìå áè~òèìå
			{ std::wstring(    L"³òèìå"), 4 }, // áóðêîò³~òèìå
			//{ std::wstring(    L"¿òèìå"), 4 }, // ãíî¿~òèìå
			{ std::wstring(   L"î¿òèìå"), 5 }, // ãíî~¿òèìå
			{ std::wstring(    L"îòèìå"), 4 }, // áîðî~òèìå
			{ std::wstring(    L"óòèìå"), 4 }, // áëÿêíó~òèìå
			{ std::wstring(     L"àéòå"), 3 }, // íàçèâà~éòå âïëèâà~éòå
			{ std::wstring(     L"³éòå"), 3 }, // áóð³~éòå
			{ std::wstring(     L"îéòå"), 3 }, // áëàãîóñòðî~éòå
			{ std::wstring(     L"óéòå"), 3 }, // ó~éòå ³ñíó~éòå
			{ std::wstring(     L"þéòå"), 3 }, // äîð³âíþ~éòå
			//{ std::wstring(       L"òå"), 2 }, // áóðêîòü~òå
			{ std::wstring(      L"åòå"), 2 }, // áåðå~òå áàìêíå~òå
			//{ std::wstring(     L"ìåòå"), 4 }, // â³çü~ìåòå
			{ std::wstring(    L"èìåòå"), 4 }, // ³òè~ìåòå
			{ std::wstring(  L"àòèìåòå"), 6 }, // ³ñíó~âà~òèìåòå ìà~òèìåòå áðà-òèìåòå
			{ std::wstring(  L"èòèìåòå"), 6 }, // áåç÷åñòè~òèìåòå áè~òèìåòå
			{ std::wstring(  L"³òèìåòå"), 6 }, // áóðêîò³~òèìåòå
			//{ std::wstring(  L"¿òèìåòå"), 6 }, // ãíî¿~òèìåòå
			{ std::wstring(  L"î¿òèìåòå"), 7 }, // ãíî~¿òèìåòå
			{ std::wstring(  L"îòèìåòå"), 6 }, // áîðî~òèìåòå
			{ std::wstring(  L"óòèìåòå"), 6 }, // áëÿêíó~òèìåòå
			{ std::wstring(L"óâàòèìåòå"), 8 }, // àêòóàë³çó~âàòèìåòå
			{ std::wstring(L"þâàòèìåòå"), 8 }, // äîð³âíþ~âàòèìåòå
			{ std::wstring(    L"üìåòå"), 4 }, // â³çü~ìåòå
			{ std::wstring(     L"àºòå"), 3 }, // çíà~ºòå
			{ std::wstring(     L"³ºòå"), 3 }, // áóð³~ºòå
			{ std::wstring(     L"óºòå"), 3 }, // ³ñíó~ºòå
			{ std::wstring(     L"þºòå"), 3 }, // äîð³âíþ~ºòå
			{ std::wstring(     L"'ºòå"), 3 }, // á'~ºòå
			{ std::wstring(      L"èòå"), 2 }, // áóðêîòè~òå
			{ std::wstring(      L"³òå"), 2 }, // áåð³~òå áàìêí³~òå
			//{ std::wstring(      L"¿òå"), 2 }, // áëàãîóñòðî¿~òå
			{ std::wstring(     L"î¿òå"), 3 }, // áëàãîóñòðî~¿òå
			{ std::wstring(     L"èéòå"), 3 }, // áè~éòå
			{ std::wstring(      L"üòå"), 2 }, // áóðêîòü~òå
			{ std::wstring(      L"³øå"), 3, WordClass::Adjective }, // àáñóðäí~³øå
			{ std::wstring(      L"³øå"), 3, WordClass::Adverb }, // àçàðòí~³øå
			{ std::wstring( L"º"), 1, WordClass::Adjective }, // àâòîäîðîæí~º
			{ std::wstring(L"àº"), 1 }, // âïëèâà~º
			{ std::wstring(L"åº"), 2, WordClass::Adjective }, // áåçïîñàäêîâ~åº áàãàòåíüê~åº áëèçüê~åº adj
			{ std::wstring(L"³º"), 1 }, // áóð³~º
			{ std::wstring(L"óº"), 1 }, // ³ñíó~º
			{ std::wstring(L"þº"), 1 }, // äîð³âíþ~º
			{ std::wstring(L"'º"), 1, WordClass::Noun }, // ñ³ì'~º

			{ std::wstring(     L"è"), 1, WordClass::Noun }, // ðó÷ê~è áóðêí~è áåðåæ~è ðåêëàì~è noun
			{ std::wstring(     L"è"), 1, WordClass::Numeral }, // ø³ñòäåñÿò~è
			{ std::wstring(   L"àëè"), 2 }, // áóâà~ëè
			{ std::wstring( L"óâàëè"), 4 }, // àêòóàë³çó~âàëè ³ñíó~âàëè
			{ std::wstring( L"þâàëè"), 4 }, // áàçàðþ~âàëè (soft U, not J-U)
			{ std::wstring(   L"èëè"), 2 }, // áè~ëè
			{ std::wstring(   L"³ëè"), 2 }, // áóðêîò³~ëè
			//{ std::wstring(   L"¿ëè"), 2 }, // áëàãîóñòðî¿~ëè
			{ std::wstring(  L"î¿ëè"), 3 }, // áëàãîóñòðî~¿ëè
			{ std::wstring(   L"îëè"), 2 }, // áîðî~ëè
			{ std::wstring(   L"óëè"), 2 }, // áàìêíó~ëè
			{ std::wstring(   L"àìè"), 3, WordClass::Numeral }, // ÷îòèðìàñò~àìè
			{ std::wstring(   L"èìè"), 2 }, // âåëèêè~ìè
			{ std::wstring(   L"èìè"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èìè
			//{ std::wstring( L"îâèìè"), 5 }, // adjective
			{ std::wstring(   L"àìè"), 3, WordClass::Noun }, // ðåêëàì~àìè ðóê~àìè ðó÷ê~àìè ôóðãîí~àìè
			{ std::wstring(   L"ÿìè"), 3, WordClass::Noun }, // àãðàð³~ÿìè îáñëóãîâóâàíí~ÿìè
			//{ std::wstring(  L"îÿìè"), 2 }, // è~ëè noun
			{ std::wstring(  L"'ÿìè"), 3, WordClass::Noun }, // ñ³ì'~ÿìè
			{ std::wstring(   L"àòè"), 2 }, // âïëèâà~òè áðà~òè
			{ std::wstring( L"þâàòè"), 4 }, // áàçàðþ~âàòè (soft U)
			{ std::wstring(   L"èòè"), 2 }, // æè~òè àðêàíè~òè áè~òè
			{ std::wstring(   L"³òè"), 2 }, // áóðêîò³~òè
			//{ std::wstring(   L"¿òè"), 2 }, // áëàãîóñòðî¿~òè
			{ std::wstring(  L"î¿òè"), 3 }, // áëàãîóñòðî~¿òè
			{ std::wstring(   L"îòè"), 2 }, // áîðî~òè
			{ std::wstring(   L"óòè"), 2 }, // áàìêíó~òè
			{ std::wstring( L"óâàòè"), 4 }, // àêòóàë³çó~âàòè
			{ std::wstring(   L"à÷è"), 2, WordClass::VerbalAdverb }, // áóðëà÷à~÷è âàíòàæà~÷è
			{ std::wstring(   L"ó÷è"), 2, WordClass::VerbalAdverb }, // áåðó~÷è áåðåæó~÷è
			{ std::wstring(   L"þ÷è"), 3, WordClass::VerbalAdverb }, // áîð~þ÷è ?
			//{ std::wstring(  L"àþ÷è"), 3, WordClass::VerbalAdverb }, // íåçâàæà~þ÷è áóâà~þ÷è
			//{ std::wstring(  L"³þ÷è"), 3, WordClass::VerbalAdverb }, // áóð³~þ÷è áàéäóæ³~þ÷è
			//{ std::wstring(  L"óþ÷è"), 3, WordClass::VerbalAdverb }, // ó~þ÷è ³ñíó~þ÷è
			//{ std::wstring(  L"þþ÷è"), 3, WordClass::VerbalAdverb }, // äîð³âíþ~þ÷è
			//{ std::wstring(  L"'þ÷è"), 3, WordClass::VerbalAdverb }, // á'~þ÷è
			{ std::wstring(   L"ÿ÷è"), 3, WordClass::VerbalAdverb }, // áóðêîò~ÿ÷è âèõîä~ÿ÷è áóä~ÿ÷è
			{ std::wstring(  L"îÿ÷è"), 3, WordClass::VerbalAdverb }, // ãíî~ÿ÷è
			{ std::wstring(  L"àâøè"), 3, WordClass::VerbalAdverb }, // ìà~âøè çíà~âøè áðà~âøè
			{ std::wstring(  L"³âøè"), 3, WordClass::VerbalAdverb }, // áóðêîò³~âøè áóáîò³~âøè
			//{ std::wstring(  L"¿âøè"), 3, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøè
			{ std::wstring( L"î¿âøè"), 4, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøè
			{ std::wstring(  L"óâøè"), 3, WordClass::VerbalAdverb }, // áàìêíó~âøè áó~âøè
			{ std::wstring(  L"èâøè"), 3, WordClass::VerbalAdverb }, // áåç÷åñòè~âøè áè~âøè
			{ std::wstring(  L"îâøè"), 3, WordClass::VerbalAdverb }, // áîðî~âøè
			{ std::wstring(L"þâàâøè"), 5, WordClass::VerbalAdverb }, // ³äîð³âíþ~âàâøè àñîö³þ~âàâøè
			{ std::wstring(L"óâàâøè"), 5, WordClass::VerbalAdverb }, // ³ñíó~âàâøè àêòóàë³çó~âàâøè áó~âàâøè

			{ std::wstring(   L"³"), 1, WordClass::Noun }, // òàê~³ óêðà¿í~³
			{ std::wstring(   L"³"), 1, WordClass::Adjective }, // áëèæ÷~³ áëèçüê~³
			{ std::wstring(   L"³"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³
			{ std::wstring(L"îºâ³"), 3, WordClass::Noun }, // îäíîñòðî~ºâ³ noun
			{ std::wstring( L"åâ³"), 3, WordClass::Noun }, // êíÿç~åâ³
			{ std::wstring( L"ºâ³"), 3, WordClass::Noun }, // àãðàð³~ºâ³
			{ std::wstring( L"îâ³"), 3, WordClass::Noun }, // ôóðãîí~îâ³ noun
			{ std::wstring( L"³ø³"), 3, WordClass::Adjective }, // àáñóðäí~³ø³ adj

			{ std::wstring( L"¿"), 1, WordClass::Adjective }, // á³ëîøè~¿
			{ std::wstring( L"¿"), 1, WordClass::Noun }, // îäíîñòðî~¿
			{ std::wstring(L"å¿"), 1, WordClass::Noun }, // ìóçå~¿
			{ std::wstring(L"º¿"), 2, WordClass::Pronoun }, // ö³~º¿
			{ std::wstring(L"è¿"), 1, WordClass::Noun }, // êîëîìè~¿
			{ std::wstring(L"³¿"), 2, WordClass::Adjective }, // áàãàòåíüê~³¿ áåçïîñàäêîâ~³¿ adj
			{ std::wstring(L"³¿"), 1, WordClass::Noun }, // ïîëîíiçàöi~¿ òåëåïîðòàö³~¿ ë³í³~¿
			{ std::wstring(L"î¿"), 2, WordClass::Adjective }, // çàìîæí~î¿
			{ std::wstring(L"î¿"), 1, WordClass::Noun }, // îäíîñòðî~¿
			{ std::wstring(L"î¿"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~î¿
			{ std::wstring(L"ó¿"), 1, WordClass::Noun }, // áóðæó~¿
			{ std::wstring(L"þ¿"), 1 }, // áðþ~¿
			{ std::wstring(L"ÿ¿"), 1, WordClass::Noun }, // õàçÿ~¿

			{ std::wstring(      L"àé"), 1 }, // íàçèâà~é âïëèâà~é
			{ std::wstring(      L"åé"), 2, WordClass::Noun }, // ñ³ì~åé
			{ std::wstring(      L"èé"), 2, WordClass::Adjective }, // òåïë~èé áàãàòåíüê~èé adj 
			{ std::wstring(      L"èé"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èé
			{ std::wstring(      L"³é"), 2, WordClass::Adjective }, // óêðà¿íñüê~³é îñòàíí~³é àâòîäîðîæí~³é adj
			{ std::wstring(      L"³é"), 1, WordClass::Noun }, // îäíîñòð³~é îðãàí³çàö³~é noun
			{ std::wstring(      L"³é"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³é
			{ std::wstring(      L"³é"), 2, WordClass::Pronoun }, // ¿õí~³é
			{ std::wstring(      L"¿é"), 2, WordClass::Adjective }, // áåçêðà~¿é
			{ std::wstring(      L"îé"), 1 }, // áëàãîóñòðî~é
			{ std::wstring(      L"óé"), 1 }, // ³ñíó~é
			{ std::wstring(      L"þé"), 1 }, // äîð³âíþ~é
			{ std::wstring(    L"³ëèé"), 3, WordClass::Participle }, // áóð³~ëèé áàéäóæ³~ëèé ÈÉ
			{ std::wstring(    L"àíèé"), 3, WordClass::Participle }, // à~íèé áðà~íèé ÈÉ
			{ std::wstring(  L"îâàíèé"), 5, WordClass::Participle }, // àêòóàë³çî~âàíèé àí³ã³ëüî~âàíèé àñîö³éî~âàíèé
			{ std::wstring(  L"óâàíèé"), 5, WordClass::Participle }, // àðåøòîâó~âàíèé
			{ std::wstring(  L"þâàíèé"), 5, WordClass::Participle }, // ï³äîçðþ~âàíèé
			{ std::wstring(    L"åíèé"), 3, WordClass::Participle }, // áåç÷åùå~íèé áåðåæå~íèé âàíòàæå~íèé ÈÉ
			{ std::wstring(    L"ºíèé"), 4, WordClass::Adjective }, // áëàãîóñòðî~ºíèé ãíî~ºíèé çàñïîêî~ºíèé ÈÉ
			{ std::wstring(   L"îºíèé"), 4, WordClass::Adjective }, // áëàãîóñòðî~ºíèé ãíî~ºíèé çàñïîêî~ºíèé
			{ std::wstring(    L"èòèé"), 3, WordClass::Participle }, // áè~òèé
			{ std::wstring(    L"îòèé"), 3, WordClass::Participle }, // áîðî~òèé
			{ std::wstring(    L"óòèé"), 3, WordClass::Participle }, // áîâòíó~òèé
			{ std::wstring(    L"à÷èé"), 3, WordClass::Participle }, // áóðëà÷à~÷èé âàíòàæà~÷èé
			{ std::wstring(    L"ó÷èé"), 3, WordClass::Participle}, // áåðó~÷èé áàìêíó~÷èé áåðåæó~÷èé áóäó~÷èé
			{ std::wstring(    L"þ÷èé"), 4, WordClass::Participle }, // compound áîð~þ÷èé
			//{ std::wstring(   L"àþ÷èé"), 4, WordClass::Participle }, // âïëèâà~þ÷èé
			//{ std::wstring(   L"³þ÷èé"), 4, WordClass::Participle }, // áóð³~þ÷èé áàéäóæ³~þ÷èé
			//{ std::wstring(   L"óþ÷èé"), 4 , WordClass::Participle}, // ³ñíó~þ÷èé
			//{ std::wstring(   L"þþ÷èé"), 4, WordClass::Participle }, // äîð³âíþ~þ÷èé
			//{ std::wstring(   L"'þ÷èé"), 4, WordClass::Participle }, // á'~þ÷èé
			{ std::wstring(    L"ÿ÷èé"), 4, WordClass::Participle }, // áóðêîò~ÿ÷èé áóä~ÿ÷èé
			{ std::wstring(   L"îÿ÷èé"), 4, WordClass::Participle }, // ãíî~ÿ÷èé
			{ std::wstring(     L"øèé"), 3, WordClass::Adjective }, // áàãàò~øèé
			{ std::wstring(   L"àâøèé"), 4, WordClass::Participle }, // áðà~âøèé
			{ std::wstring( L"óâàâøèé"), 6, WordClass::Participle }, // ³ñíó~âàâøèé àêòóàë³çó~âàâøèé áó~âàâøèé
			{ std::wstring( L"þâàâøèé"), 6, WordClass::Participle }, // áàçàðþ~âàâøèé àñîö³þ~âàâøèé
			{ std::wstring(   L"èâøèé"), 4, WordClass::Participle }, // áåç÷åñòè~âøèé áè~âøèé
			{ std::wstring(   L"³âøèé"), 4, WordClass::Participle }, // áóðêîò³~âøèé áóáîò³~âøèé
			//{ std::wstring(   L"¿âøèé"), 4 }, // áëàãîóñòðî¿~âøèé
			{ std::wstring(  L"î¿âøèé"), 5, WordClass::Participle }, // áëàãîóñòðî~¿âøèé
			{ std::wstring(   L"îâøèé"), 4, WordClass::Participle }, // áîðî~âøèé
			{ std::wstring(   L"óâøèé"), 4, WordClass::Participle }, // áàìêíó~âøèé áó~âøèé
			{ std::wstring(    L"³øèé"), 4, WordClass::Adjective }, // àáñóðäí~³øèé

			{ std::wstring(      L"àì"), 2, WordClass::Noun }, // ôóðãîí~àì
			{ std::wstring(      L"àì"), 2, WordClass::Numeral }, // ÷îòèðüîìñò~àì
			{ std::wstring(      L"åì"), 1 }, // áåð~åì áàìêí~åì
			{ std::wstring(      L"åì"), 2, WordClass::Noun }, // ñàáîòàæ~åì ERROR: áóðîçåì~ àíàõòåì~(àíàõòåìà)
			{ std::wstring(    L"èìåì"), 3 }, // áðåñòè~ìåì
			{ std::wstring(  L"àòèìåì"), 5 }, // áðà~òèìåì
			{ std::wstring(  L"îòèìåì"), 5 }, // áîðî~òèìåì
			{ std::wstring(L"óâàòèìåì"), 7 }, // ³ñíó~âà~òèìåì àêòóàë³çó~âàòèìåì
			{ std::wstring(L"þâàòèìåì"), 7 }, // áàçàðþ~âà~òèìåì
			{ std::wstring(  L"èòèìåì"), 5 }, // ðîáè~òèìåì áè~òèìåì
			{ std::wstring(  L"³òèìåì"), 5 }, // òåðï³~òèìåì ?
			//{ std::wstring( L"¿òèìåì"), 5 }, // ãíî¿~òèìåì
			{ std::wstring( L"î¿òèìåì"), 6 }, // ãíî~¿òèìåì
			{ std::wstring(  L"óòèìåì"), 5 }, // áëÿêíó~òèìåì
			{ std::wstring(  L"ÿòèìåì"), 5 }, // ðîçìîâë~ÿòèìåì
			{ std::wstring(      L"ºì"), 2, WordClass::Noun }, // composite
			{ std::wstring(      L"ºì"), 2 }, // composite
			//{ std::wstring(     L"àºì"), 2 }, // çíà~ºì
			//{ std::wstring(     L"åºì"), 2 }, // ïðîìåòå~ºì noun
			//{ std::wstring(     L"³ºì"), 2 }, // êðèòåð³~ºì noun
			//{ std::wstring(     L"îºì"), 2 }, // îäíîñòðî~ºì
			//{ std::wstring(     L"óºì"), 2 }, // ÷ó~ºì
			//{ std::wstring(     L"þºì"), 2 }, // áàçàðþ~ºì
			//{ std::wstring(     L"'ºì"), 2 }, // á'~ºì
			{ std::wstring(      L"èì"), 1 }, // áóðêîòè~ì
			{ std::wstring(      L"èì"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èì
			{ std::wstring(      L"³ì"), 1 }, // áàìêí³~ì áåð³~ì áåðåæ³~ì
			{ std::wstring(      L"³ì"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~³ì
			//{ std::wstring(      L"¿ì"), 1 }, // áëàãîóñòðî¿~ì
			{ std::wstring(     L"î¿ì"), 2 }, // áëàãîóñòðî~¿ì
			{ std::wstring(      L"îì"), 2, WordClass::Noun }, // ôóðãîí~îì
			{ std::wstring(      L"îì"), 2, WordClass::Numeral }, // äâ~îì îäèíàäöÿòü~îì
			{ std::wstring(      L"ÿì"), 2, WordClass::Noun }, // compound ëþä~ÿì îáñëóãîâóâàíí~ÿì
			//{ std::wstring(     L"îÿì"), 2, WordClass::Noun }, // îäíîñòðî~ÿì
			//{ std::wstring(     L"'ÿì"), 2, WordClass::Noun }, // ñ³ì'~ÿì

			{ std::wstring(        L"î"), 1 }, // ðó÷ê~î
			{ std::wstring(        L"î"), 1, WordClass::Adverb }, // àçàðòí~î adverb
			{ std::wstring(        L"î"), 1, WordClass::Numeral }, // ñò~î
			{ std::wstring(      L"îãî"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îãî
			{ std::wstring(     L"üîãî"), 3, WordClass::Pronoun }, // ¿õíü~îãî
			{ std::wstring(      L"àëî"), 2 }, // áðàêóâà~ëî
			{ std::wstring(    L"óâàëî"), 4 }, // ³ñíó~âàëî àêòóàë³çó~âàëî
			{ std::wstring(    L"þâàëî"), 4 }, // áàçàðþ~âàëî (soft U)
			{ std::wstring(      L"èëî"), 2 }, // æè~ëî áè~ëî
			{ std::wstring(      L"³ëî"), 2 }, // áóðêîò³~ëî
			//{ std::wstring(      L"¿ëî"), 2 }, // áëàãîóñòðî¿~ëî
			{ std::wstring(     L"î¿ëî"), 3 }, // áëàãîóñòðî~¿ëî
			{ std::wstring(      L"îëî"), 2 }, // áîðî~ëî
			{ std::wstring(      L"óëî"), 2 }, // áàìêíó~ëî
			//{ std::wstring(       L"ìî"), 2 }, // áóðêîòü~ìî áåç÷åñòü~ìî
			{ std::wstring(      L"åìî"), 2 }, // áåðå~ìî áàìêíå~ìî
			{ std::wstring(      L"èìî"), 2 }, // áóðêîòè~ìî
			{ std::wstring(  L"àòèìåìî"), 6 }, // ³ñíó~âà~òèìåìî ìà~òèìåìî
			{ std::wstring(  L"èòèìåìî"), 6 }, // æè~òèìåìî áè~òèìåìî
			{ std::wstring(  L"³òèìåìî"), 6 }, // áóðêîò³~òèìåìî
			//{ std::wstring(  L"¿òèìåìî"), 6 }, // ãíî¿~òèìåìî
			{ std::wstring( L"î¿òèìåìî"), 7 }, // ãíî~¿òèìåìî
			{ std::wstring(  L"îòèìåìî"), 6 }, // áîðî~òèìåìî
			{ std::wstring(  L"óòèìåìî"), 6 }, // áëÿêíó~òèìåìî
			{ std::wstring(L"óâàòèìåìî"), 8 }, // àêòóàë³çó~âàòèìåìî
			{ std::wstring(L"þâàòèìåìî"), 8 }, // äîð³âíþ~âàòèìåìî
			{ std::wstring(     L"àºìî"), 3 }, // çíà~ºìî
			{ std::wstring(     L"³ºìî"), 3 }, // áóð³~ºìî
			{ std::wstring(     L"óºìî"), 3 }, // ³ñíó~ºìî
			{ std::wstring(     L"þºìî"), 3 }, // äîð³âíþ~ºìî
			{ std::wstring(     L"'ºìî"), 3 }, // á'~ºìî
			{ std::wstring(      L"³ìî"), 2 }, // áåð³~ìî áàìêí³~ìî áåðåæ³~ìî
			//{ std::wstring(      L"¿ìî"), 2 }, // áëàãîóñòðî¿~ìî
			{ std::wstring(     L"î¿ìî"), 3 }, // áëàãîóñòðî~¿ìî
			//{ std::wstring(      L"éìî"), 3 }, // NOT êëåé*éìî
			{ std::wstring(     L"àéìî"), 3 }, // íàçèâà~éìî ðóøà~éìî
			//{ std::wstring(     L"åéìî"), 3 }, // no words
			{ std::wstring(     L"èéìî"), 3 }, // áóð³~éìî áè~éìî
			{ std::wstring(     L"³éìî"), 3 }, // áóð³~éìî
			{ std::wstring(     L"îéìî"), 3 }, // áëàãîóñòðî~éìî
			{ std::wstring(     L"óéìî"), 3 }, // ³ñíó~éìî àêòóàë³çó~éìî
			{ std::wstring(     L"þéìî"), 3 }, // äîð³âíþ~éìî
			{ std::wstring(     L"ÿéìî"), 3 }, // ïîð³âíÿ~éìî
			{ std::wstring(      L"üìî"), 2 }, // áóðêîòü~ìî áåç÷åñòü~ìî
			{ std::wstring(      L"åðî"), 3, WordClass::Numeral }, // äåâ'ÿò~åðî
			
			{ std::wstring(      L"ó"), 1, WordClass::Noun }, // noun, ðó÷ê~ó áåð~ó áóðêî÷~ó áåç÷åù~ó áåðåæ~ó
			{ std::wstring(      L"ó"), 1, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~ó
			//{ std::wstring(     L"ìó"), 2 }, // not usable (ôîð*ì~ó)
			//{ std::wstring(    L"àìó"), 2 }, // not usable (ñà*ì~ó)
			{ std::wstring(    L"ºìó"), 2, WordClass::Pronoun }, // ñâîº~ìó
			{ std::wstring(    L"èìó"), 2 }, // áåðåã*òè~ìó
			//{ std::wstring(   L"òèìó"), 4 }, // áåðåã*òèìó; ã*òèìó is too rare to use
			{ std::wstring(  L"àòèìó"), 4 }, // áðà~òèìó
			{ std::wstring(  L"èòèìó"), 4 }, // áåç÷åñòè~òèìó áè~òèìó
			{ std::wstring(  L"³òèìó"), 4 }, // áóðêîò³~òèìó
			//{ std::wstring(  L"¿òèìó"), 4 }, // ãíî¿~òèìó
			{ std::wstring( L"î¿òèìó"), 5 }, // ãíî~¿òèìó
			{ std::wstring(  L"îòèìó"), 4 }, // áîðî~òèìó
			{ std::wstring(  L"ñòèìó"), 4 }, // áðåñ~òèìó
			{ std::wstring(  L"óòèìó"), 4 }, // áëÿêíó~òèìó
			{ std::wstring(L"óâàòèìó"), 6 }, // ³ñíó~âàòèìó àêòóàë³çó~âàòèìó
			{ std::wstring(L"þâàòèìó"), 6 }, // áàçàðþ~âàòèìó
			{ std::wstring(    L"îìó"), 3, WordClass::Adjective }, // áþäæåòí~îìó adj
			{ std::wstring(    L"îìó"), 3, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îìó
			//{ std::wstring(    L"óìó"), 2 }, // not usable (ðîçó*ì~ó)

			{ std::wstring(  L"àõ"), 2, WordClass::Noun }, // ðó÷ê~àõ ôóðãîí~àõ
			{ std::wstring(  L"àõ"), 2, WordClass::Numeral }, // ÷îòèðüîõñò~àõ
			{ std::wstring(  L"èõ"), 2, WordClass::Adjective }, // áþäæåòí~èõ
			{ std::wstring(  L"èõ"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~èõ
			{ std::wstring(  L"îõ"), 2, WordClass::Numeral }, // äåâ'ÿòü~îõ äâ~îõ
			{ std::wstring(  L"ÿõ"), 2, WordClass::Noun }, // compound
			//{ std::wstring( L"îÿõ"), 2, WordClass::Noun }, // îäíîñòðî~ÿõ
			//{ std::wstring(  L"ÿõ"), 2, WordClass::Noun }, // îáñëóãîâóâàíí~ÿõ
			//{ std::wstring( L"'ÿõ"), 2, WordClass::Noun }, // ñ³ì'~ÿõ

			{ std::wstring(      L"åø"), 2 }, // áåð~åø áàìêí~åø
			{ std::wstring(    L"èìåø"), 3 }, // áðåñòè~ìåø
			{ std::wstring(  L"àòèìåø"), 5 }, // áðà~òèìåø íàçèâà~òèìåø
			{ std::wstring(  L"èòèìåø"), 5 }, // áåç÷åñòè~òèìåø áè~òèìåø
			{ std::wstring(  L"³òèìåø"), 5 }, // áóðêîò³~òèìåø
			//{ std::wstring(  L"¿òèìåø"), 5 }, // ãíî¿~òèìåø
			{ std::wstring( L"î¿òèìåø"), 6 }, // ãíî~¿òèìåø
			{ std::wstring(  L"îòèìåø"), 5 }, // áîðî~òèìåø
			{ std::wstring(  L"óòèìåø"), 5 }, // áëÿêíó~òèìåø
			//{ std::wstring(L"èâàòèìåø"), 7 }, // no words with such suffix
			{ std::wstring(L"óâàòèìåø"), 7 }, // àêòóàë³çó~âàòèìåø ³ñíó~âàòèìåø
			{ std::wstring(L"þâàòèìåø"), 7 }, // áàçàðþ~âàòèìåø (soft U)
			{ std::wstring(     L"àºø"), 2 }, // à~ºø ìà~ºø
			{ std::wstring(     L"³ºø"), 2 }, // áóð³~ºø
			{ std::wstring(     L"óºø"), 2 }, // ³ñíó~ºø
			{ std::wstring(     L"þºø"), 2 }, // äîð³âíþ~ºø
			{ std::wstring(     L"'ºø"), 2 }, // á'~ºø
			{ std::wstring(      L"èø"), 1 }, // áóðêîò~èø
			{ std::wstring(      L"³ø"), 2, WordClass::Adverb }, // àçàðòí~³ø
			//{ std::wstring(      L"¿ø"), 1 }, // áëàãîóñòðî¿~ø
			{ std::wstring(     L"î¿ø"), 2 }, // áëàãîóñòðî~¿ø

			{ std::wstring(      L"àëàñü"), 4 }, // íàçèâà~ëàñü
			{ std::wstring(    L"óâàëàñü"), 6 }, // àêòóàë³çó~âàëàñü
			{ std::wstring(    L"þâàëàñü"), 6 }, // àí³ã³ëþ~âàëàñü
			{ std::wstring(      L"èëàñü"), 4 }, // áðèæè~ëàñü áè~ëàñü
			//{ std::wstring(      L"¿ëàñü"), 4 }, // áëàãîóñòðî¿~ëàñü
			{ std::wstring(     L"î¿ëàñü"), 5 }, // áëàãîóñòðî~¿ëàñü
			{ std::wstring(      L"îëàñü"), 4 }, // áîðî~ëàñü
			{ std::wstring(      L"óëàñü"), 4 }, // áåõíó~ëºìîñÿàñü
			{ std::wstring(     L"îÿëàñü"), 5 }, // áî~ÿëàñü
			{ std::wstring(       L"àâñü"), 3 }, // íàçèâà~âñü
			{ std::wstring(     L"óâàâñü"), 5 }, // àêòóàë³çó~âàâñü
			{ std::wstring(     L"þâàâñü"), 5 }, // àí³ã³ëþ~âàâñü
			{ std::wstring(       L"èâñü"), 3 }, // áåç÷åñòè~âñü áè~âñü
			//{ std::wstring(       L"¿âñü"), 3 }, // áëàãîóñòðî¿~âñü
			{ std::wstring(      L"î¿âñü"), 4 }, // áëàãîóñòðî~¿âñü
			{ std::wstring(       L"îâñü"), 3 }, // áîðî~âñü
			{ std::wstring(       L"óâñü"), 3 }, // áåõíó~âñü
			{ std::wstring(       L"ÿâñü"), 4 }, // áî~ÿâñü
			// { std::wstring(        L"åñü"), 2 }, // no words
			{ std::wstring(   L"òèìåòåñü"), 8 }, // áåðåã~òèìåòåñü
			{ std::wstring(  L"àòèìåòåñü"), 8 }, // íàçèâà~òèìåòåñü
			//{ std::wstring(  L"¿òèìåòåñü"), 7 }, // ãíî¿~òèìåòåñü
			{ std::wstring( L"î¿òèìåòåñü"), 9 }, // ãíî~¿òèìåòåñü
			{ std::wstring(  L"îòèìåòåñü"), 8 }, // áîðî~òèìåòåñü
			{ std::wstring(L"óâàòèìåòåñü"), 10 }, // àêòóàë³çó~âàòèìåòåñü
			{ std::wstring(L"þâàòèìåòåñü"), 10 }, // àí³ã³ëþ~âàòèìåòåñü
			{ std::wstring(  L"èòèìåòåñü"), 8 }, // áðèæè~òèìåòåñü áè~òèìåòåñü
			{ std::wstring(  L"ÿòèìåòåñü"), 9 }, // áî~ÿòèìåòåñü
			{ std::wstring(      L"åòåñü"), 4 }, // áåðå~òåñü
			{ std::wstring(      L"ºòåñü"), 5 }, // á'~ºòåñü
			{ std::wstring(     L"óºòåñü"), 5 }, // àêòóàë³çó~ºòåñü
			{ std::wstring(      L"èòåñü"), 4 }, // áåç÷åñòè~òåñü
			{ std::wstring(      L"³òåñü"), 4 }, // áåð³~òåñü áðèæ³~òåñü äèâ³~òåñü
			//{ std::wstring(      L"¿òåñü"), 4 }, // áëàãîóñòðî¿~òåñü
			{ std::wstring(     L"î¿òåñü"), 5 }, // áëàãîóñòðî~¿òåñü áî~¿òåñü
			{ std::wstring(     L"àéòåñü"), 5 }, // íàçèâà~éòåñü
			{ std::wstring(     L"èéòåñü"), 5 }, // áè~éòåñü
			{ std::wstring(     L"³éòåñü"), 5 }, // á³~éòåñü
			{ std::wstring(     L"îéòåñü"), 5 }, // áëàãîóñòðî~éòåñü
			{ std::wstring(     L"óéòåñü"), 5 }, // àêòóàë³çó~éòåñü
			{ std::wstring(     L"þéòåñü"), 5 }, // àí³ã³ëþ~éòåñü
			{ std::wstring(     L"àºòåñü"), 5 }, // à~ºòåñü íàçèâà~ºòåñü
			{ std::wstring(     L"þºòåñü"), 5 }, // àí³ã³ëþ~ºòåñü
			{ std::wstring(      L"üòåñü"), 4 }, // áàãðÿíü~òåñü
			{ std::wstring(        L"èñü"), 2, WordClass::Verb }, // áåðè~ñü
			{ std::wstring(        L"èñü"), 2, WordClass::VerbalAdverb }, // áåð³ãøè~ñü
			{ std::wstring(      L"àëèñü"), 4 }, // íàçèâà~ëèñü
			{ std::wstring(    L"þâàëèñü"), 6 }, // àí³ã³ëþ~âàëèñü
			{ std::wstring(      L"èëèñü"), 4 }, // áðèæè~ëèñü áè~ëèñü
			//{ std::wstring(      L"¿ëèñü"), 4 }, // áëàãîóñòðî¿~ëèñü
			{ std::wstring(     L"î¿ëèñü"), 5 }, // áëàãîóñòðî~¿ëèñü
			{ std::wstring(      L"îëèñü"), 4 }, // áîðî~ëèñü
			{ std::wstring(      L"óëèñü"), 4 }, // áåõíó~ëèñü
			{ std::wstring(    L"óâàëèñü"), 6 }, // àêòóàë³çó~âàëèñü
			{ std::wstring(      L"ÿëèñü"), 5 }, // áî~ÿëèñü
			{ std::wstring(      L"àòèñü"), 4 }, // áðà~òèñü
			{ std::wstring(    L"óâàòèñü"), 6 }, // àêòóàë³çó~âàòèñü
			{ std::wstring(    L"þâàòèñü"), 6 }, // àí³ã³ëþ~âàòèñü
			{ std::wstring(      L"èòèñü"), 4 }, // áðèæè~òèñü áè~òèñü
			//{ std::wstring(      L"¿òèñü"), 4 }, // áëàãîóñòðî¿~òèñü
			{ std::wstring(     L"î¿òèñü"), 5 }, // áëàãîóñòðî~¿òèñü
			{ std::wstring(      L"îòèñü"), 4 }, // áîðî~òèñü
			{ std::wstring(      L"óòèñü"), 4 }, // áåõíó~òèñü
			{ std::wstring(      L"ÿòèñü"), 5 }, // áî~ÿòèñü
			{ std::wstring(      L"à÷èñü"), 4, WordClass::VerbalAdverb }, // áðèæà~÷èñü âàíòàæà~÷èñü
			{ std::wstring(      L"ó÷èñü"), 4, WordClass::VerbalAdverb }, // áåðó~÷èñü
			{ std::wstring(      L"þ÷èñü"), 5, WordClass::VerbalAdverb }, // compound
			//{ std::wstring(     L"àþ÷èñü"), 5, WordClass::VerbalAdverb }, // íàìàãà~þ÷èñü
			//{ std::wstring(     L"óþ÷èñü"), 5, WordClass::VerbalAdverb }, // äèâó~þ÷èñü
			//{ std::wstring(     L"þþ÷èñü"), 5, WordClass::VerbalAdverb }, // àí³ã³ëþ~þ÷èñü
			//{ std::wstring(      L"þ÷èñü"), 5, WordClass::VerbalAdverb }, // áîðþ~÷èñü
			//{ std::wstring(     L"'þ÷èñü"), 5, WordClass::VerbalAdverb }, // á'~þ÷èñü
			{ std::wstring(      L"ÿ÷èñü"), 5, WordClass::VerbalAdverb }, // áî~ÿ÷èñü ãíî~ÿ÷èñü äèâë~ÿ÷èñü áóä~ÿ÷èñü
			{ std::wstring(     L"îÿ÷èñü"), 5, WordClass::VerbalAdverb }, // ãíî~ÿ÷èñü áî~ÿ÷èñü

			{ std::wstring(     L"àâøèñü"), 5, WordClass::VerbalAdverb }, // íàçèâà~âøèñü áðà~âøèñü
			{ std::wstring(     L"îâøèñü"), 5, WordClass::VerbalAdverb }, // áîðî~âøèñü
			{ std::wstring(   L"þâàâøèñü"), 7, WordClass::VerbalAdverb }, // àí³ã³ëþ~âàâøèñü àñîö³þ~âàâøèñü
			{ std::wstring(   L"óâàâøèñü"), 7, WordClass::VerbalAdverb }, // àêòóàë³çó~âàâøèñü
			{ std::wstring(     L"èâøèñü"), 5, WordClass::VerbalAdverb }, // áðèæè~âøèñü áè~âøèñü
			//{ std::wstring(     L"¿âøèñü"), 5, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøèñü
			{ std::wstring(    L"î¿âøèñü"), 6, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøèñü
			{ std::wstring(     L"óâøèñü"), 5, WordClass::VerbalAdverb }, // áåõíó~âøèñü çâåðíó~âøèñü
			{ std::wstring(     L"ÿâøèñü"), 5, WordClass::VerbalAdverb }, // âçÿ~âøèñü
			{ std::wstring(    L"îÿâøèñü"), 6, WordClass::VerbalAdverb }, // áî~ÿâøèñü
			{ std::wstring(       L"àéñü"), 3 }, // çíà~éñü íàçèâà~éñü
			{ std::wstring(       L"èéñü"), 3 }, // á³~éñü áè~éñü
			{ std::wstring(       L"³éñü"), 3 }, // á³~éñü
			{ std::wstring(       L"îéñü"), 3 }, // áëàãîóñòðî~éñü
			{ std::wstring(       L"óéñü"), 3 }, // àêòóàë³çó~éñü
			{ std::wstring(       L"þéñü"), 3 }, // àí³ã³ëþ~éñü
			//{ std::wstring(        L"îñü"), 2 }, // no actual words (all are LOS or MOS) êîãî~ñü ??
			{ std::wstring(      L"àëîñü"), 5 }, // áðà~ëîñü íàçèâà~ëîñü ñòà~ëîñü
			{ std::wstring(    L"þâàëîñü"), 6 }, // àí³ã³ëþ~âàëîñü
			{ std::wstring(      L"èëîñü"), 4 }, // áðèæè~ëîñü áè~ëîñü
			//{ std::wstring(      L"¿ëîñü"), 4 }, // áëàãîóñòðî¿~ëîñü
			{ std::wstring(     L"î¿ëîñü"), 5 }, // áëàãîóñòðî~¿ëîñü
			{ std::wstring(      L"îëîñü"), 4 }, // áîðî~ëîñü
			{ std::wstring(      L"óëîñü"), 4 }, // áåõíó-ëîñü
			{ std::wstring(    L"óâàëîñü"), 6 }, // àêòóàë³çó~âàëîñü
			{ std::wstring(      L"ÿëîñü"), 5 }, // áî~ÿëîñü
			// { std::wstring(       L"ìîñü"), 4 }, // 
			{ std::wstring(      L"åìîñü"), 4 }, // áåðåæå~ìîñü áåðå~ìîñü
			{ std::wstring(    L"èìåìîñü"), 6 }, // áåðåãòè~ìåìîñü (we can't split áåðåã*òèìåìîñü)
			{ std::wstring(  L"àòèìåìîñü"), 8 }, // áðà~òèìåìîñü íàçè~âà~òèìåìîñü
			{ std::wstring(  L"èòèìåìîñü"), 8 }, // áðèæè~òèìåìîñü áè~òèìåìîñü
			//{ std::wstring(  L"¿òèìåìîñü"), 8 }, // ãíî¿~òèìåìîñü
			{ std::wstring(  L"î¿òèìåìîñü"), 9 }, // ãíî~¿òèìåìîñü
			{ std::wstring(  L"îòèìåìîñü"), 8 }, // áîðî~òèìåìîñü
			{ std::wstring(L"óâàòèìåìîñü"), 10 }, // àêòóàë³çó~âàòèìåìîñü
			{ std::wstring(L"þâàòèìåìîñü"), 10 }, // àí³ã³ëþ~âàòèìåìîñü
			{ std::wstring(  L"ÿòèìåìîñü"), 9 }, // áî~ÿòèìåìîñü
			{ std::wstring(      L"ºìîñü"), 5 }, // á'~ºìîñü
			//{ std::wstring(     L"àºìîñü"), 5 }, // ñïîä³âà~ºìîñü
			//{ std::wstring(     L"èºìîñü"), 5 }, // ïîøè~ºìîñü
			//{ std::wstring(     L"³ºìîñü"), 5 }, // íàä³~ºìîñü
			//{ std::wstring(     L"îºìîñü"), 5 }, // ïîáîþ~ºìîñü
			//{ std::wstring(     L"óºìîñü"), 5 }, // êîðèñòó~ºìîñü àêòóàë³çó~ºìîñü
			//{ std::wstring(     L"þºìîñü"), 5 }, // âèñëîâëþ~ºìîñü àí³ã³ëþ~ºìîñü
			//{ std::wstring(     L"ÿºìîñü"), 5 }, // ñïèíÿ~ºìîñü
			//{ std::wstring(     L"'ºìîñü"), 5 }, // â³ä³á'~ºìîñü á'~ºìîñü
			{ std::wstring(      L"èìîñü"), 4 }, // áåç÷åñòè~ìîñü
			//{ std::wstring(      L"¿ìîñü"), 4 }, // áî¿~ìîñü áëàãîóñòðî¿~ìîñü
			{ std::wstring(      L"³ìîñü"), 4 }, // áåðåæ³~ìîñü áåð³~ìîñü äèâ³~ìîñü
			{ std::wstring(      L"¿ìîñü"), 5 }, // compound
			//{ std::wstring(     L"è¿ìîñü"), 5 }, // ÷è~¿ìîñü
			//{ std::wstring(     L"î¿ìîñü"), 5 }, // áî~¿ìîñü áëàãîóñòðî~¿ìîñü
			{ std::wstring(      L"éìîñü"), 5 }, // compound
			//{ std::wstring(     L"àéìîñü"), 5 }, // íàçèâà~éìîñü
			//{ std::wstring(     L"èéìîñü"), 5 }, // áè~éìîñü
			//{ std::wstring(     L"³éìîñü"), 5 }, // á³~éìîñü
			//{ std::wstring(     L"îéìîñü"), 5 }, // áëàãîóñòðî~éìîñü
			//{ std::wstring(     L"óéìîñü"), 5 }, // àêòóàë³çó~éìîñü
			//{ std::wstring(     L"þéìîñü"), 5 }, // àí³ã³ëþ~éìîñü
			{ std::wstring(      L"üìîñü"), 4 }, // áåç÷åñòü~ìîñü
			{ std::wstring(        L"óñü"), 2 }, // áåðó~ñü áåç÷åùó~ñü
			{ std::wstring(      L"èìóñü"), 4 }, // áåðåãòè~ìóñü
			{ std::wstring(    L"àòèìóñü"), 6 }, // íàçèâà~òèìóñü
			{ std::wstring(    L"¿òèìóñü"), 7 }, // compound
			//{ std::wstring(   L"î¿òèìóñü"), 7 }, // ãíî~¿òèìóñü
			{ std::wstring(    L"îòèìóñü"), 6 }, // áîðî~òèìóñü
			{ std::wstring(  L"óâàòèìóñü"), 8 }, // àêòóàë³çó~âàòèìóñü
			{ std::wstring(  L"þâàòèìóñü"), 8 }, // àí³ã³ëþ~âàòèìóñü
			{ std::wstring(    L"èòèìóñü"), 6 }, // áðèæè~òèìóñü áè~òèìóñü
			{ std::wstring(    L"ÿòèìóñü"), 7 }, // áî~ÿòèìóñü

			{ std::wstring(        L"þñü"), 3 }, // äèâë~þñü àðêàí~þñü æóð~þñü
			{ std::wstring(       L"àþñü"), 3 }, // íàçèâà~þñü
			{ std::wstring(       L"³þñü"), 3 }, // ðîçóì³~þñü
			{ std::wstring(       L"èþñü"), 3 }, // ÷è~þñü
			{ std::wstring(       L"îþñü"), 3 }, // áî~þñü(?or zero) áëàãîóñòðî~þñü ERROR: ãíî~þñü (need to keep letter 'o')
			{ std::wstring(       L"óþñü"), 3 }, // àêòóàë³çó~þñü
			{ std::wstring(       L"ºþñü"), 4 }, // ÷è~ºþñü
			{ std::wstring(       L"þþñü"), 3 }, // àí³ã³ëþ~þñü õâèëþ~þñü
			{ std::wstring(       L"ÿþñü"), 3 }, // ïîìèëÿ~þñü
			{ std::wstring(       L"'þñü"), 3 }, // á'~þñü

			{ std::wstring(       L"àòü"), 2 }, // áðà~òü áóðëà÷à~òü
			{ std::wstring(     L"óâàòü"), 4 }, // ³ñíó~âàòü
			{ std::wstring(     L"þâàòü"), 4 }, // äîð³âíþ~âàòü
			{ std::wstring(       L"èòü"), 2 }, // áåç÷åñòè~òü áè~òü
			{ std::wstring(       L"³òü"), 3 }, // áåð~³òü áóðêîò~³òü áàìêí~³òü
			//{ std::wstring(       L"¿òü"), 3 }, // áëàãîóñòðî¿~òü
			{ std::wstring(      L"î¿òü"), 3 }, // áëàãîóñòðî~¿òü
			{ std::wstring(       L"îòü"), 3 }, // áîð~îòü ïîë~îòü êîë~îòü ê³ã~îòü
			{ std::wstring(       L"óòü"), 3 }, // áåð~óòü áàìêí~óòü
			{ std::wstring(     L"èìóòü"), 4 }, // áðåñòè~ìóòü
			{ std::wstring(   L"àòèìóòü"), 6 }, // à~òèìóòü ³ñíóâà~òèìóòü
			{ std::wstring(   L"èòèìóòü"), 6 }, // æè~òèìóòü áè~òèìóòü
			{ std::wstring(   L"³òèìóòü"), 6 }, // áóðêîò³~òèìóòü
			//{ std::wstring(   L"¿òèìóòü"), 6 }, // ãíî¿~òèìóòü
			{ std::wstring(  L"î¿òèìóòü"), 7 }, // ãíî~¿òèìóòü
			{ std::wstring(   L"îòèìóòü"), 6 }, // áîðî~òèìóòü
			{ std::wstring(   L"óòèìóòü"), 6 }, // áëÿêíó~òèìóòü
			{ std::wstring( L"óâàòèìóòü"), 8 }, // àêòóàë³çó~âàòèìóòü
			{ std::wstring( L"þâàòèìóòü"), 8 }, // äîð³âíþ~âàòèìóòü
			{ std::wstring(       L"þòü"), 3 }, // áîð~þòü
			{ std::wstring(      L"àþòü"), 3 }, // ââàæà~þòü âïëèâà~þòü
			{ std::wstring(      L"³þòü"), 3 }, // áóð³~þòü
			{ std::wstring(      L"óþòü"), 3 }, // ³ñíó~þòü
			{ std::wstring(      L"þþòü"), 3 }, // äîð³âíþ~þòü
			{ std::wstring(      L"'þòü"), 3 }, // äîð³âíþ~þòü á'~þòü
			{ std::wstring(       L"ÿòü"), 3 }, // áóðêîò~ÿòü ãíî~ÿòü
			{ std::wstring(      L"îÿòü"), 3 }, // áëàãîóñòðî~ÿòü

			{ std::wstring( L"þ"), 1 }, // àðêàí~þ
			{ std::wstring( L"þ"), 1 , WordClass::Noun}, // áåççì³íí³ñò~þ
			{ std::wstring(L"àþ"), 1 }, // íàçèâà~þ
			{ std::wstring(L"ºþ"), 2, WordClass::Noun }, // ñ³ì'~ºþ
			{ std::wstring(L"³þ"), 1 }, // áóð³~þ
			{ std::wstring(L"îþ"), 1 }, // ãíî~þ
			{ std::wstring(L"îþ"), 2, WordClass::Noun }, // áëàãîóñòð~îþ çì³í~îþ
			{ std::wstring(L"îþ"), 2, WordClass::Numeral }, // áàãàòîì³ëüÿðäí~îþ
			{ std::wstring(L"óþ"), 1 }, // ³ñíó~þ àêòóàë³çó~þ
			{ std::wstring(L"þþ"), 1 }, // äîð³íþ~þ
			{ std::wstring(L"'þ"), 1, WordClass::Noun }, // ñ³ì'~þ

			{ std::wstring(          L"ÿ"), 1, WordClass::Adjective }, // äîðîæí~ÿ
			{ std::wstring(          L"ÿ"), 1, WordClass::Noun }, // îáñëóãîâóâàíí~ÿ
			{ std::wstring(         L"àÿ"), 2, WordClass::Adjective }, // áåçïîñàäêîâ~àÿ áëèçüê~àÿ adj
			{ std::wstring(         L"ÿÿ"), 2, WordClass::Adjective }, // àâòîäîðîæí~ÿÿ
			{ std::wstring(         L"'ÿ"), 1, WordClass::Noun }, // ñ³ì'~ÿ
			// { std::wstring(         L"ñÿ"), 2 }, // can't detach unvoiced 'Sya'
			//{ std::wstring(        L"àñÿ"), 2 }, // no words
			{ std::wstring(       L"ëàñÿ"), 4 }, // áåðåã~ëàñÿ
			{ std::wstring(      L"àëàñÿ"), 4 }, // íàçèâà~ëàñÿ
			{ std::wstring(      L"îëàñÿ"), 4 }, // áîðî~ëàñÿ
			{ std::wstring(    L"óâàëàñÿ"), 6 }, // àêòóàë³çó~âàëàñÿ
			{ std::wstring(    L"þâàëàñÿ"), 6 }, // àí³ã³ëþ~âàëàñÿ
			{ std::wstring(      L"èëàñÿ"), 4 }, // áðèæè~ëàñÿ áè~ëàñÿ
			//{ std::wstring(      L"¿ëàñÿ"), 4 }, // áëàãîóñòðî¿~ëàñÿ
			{ std::wstring(     L"î¿ëàñÿ"), 5 }, // áëàãîóñòðî~¿ëàñÿ
			{ std::wstring(      L"óëàñÿ"), 4 }, // áåõíó~ëàñÿ
			{ std::wstring(      L"ÿëàñÿ"), 5 }, // áî~ÿëàñÿ
			{ std::wstring(       L"àâñÿ"), 3 }, // íàçèâà~âñÿ áðà~âñÿ
			{ std::wstring(     L"óâàâñÿ"), 5 }, // àêòóàë³çó~âàâñÿ
			{ std::wstring(     L"þâàâñÿ"), 5 }, // àí³ã³ëþ~âàâñÿ
			{ std::wstring(       L"èâñÿ"), 3 }, // áðèæè~âñÿ áè~âñÿ
			//{ std::wstring(       L"¿âñÿ"), 3 }, // áëàãîóñòðî¿~âñÿ
			{ std::wstring(      L"î¿âñÿ"), 4 }, // áëàãîóñòðî~¿âñÿ
			{ std::wstring(       L"îâñÿ"), 3 }, // áîðî~âñÿ
			{ std::wstring(       L"óâñÿ"), 3 }, // áåõíó~âñÿ
			{ std::wstring(       L"ÿâñÿ"), 3 }, // áîÿ~âñÿ
			//{ std::wstring(       L"³ãñÿ"), 3 }, // áåð³ãñ~ÿ (áåð is too common)
			{ std::wstring(      L"åòåñÿ"), 4 }, // áåðå~òåñÿ áåðåæå~òåñÿ
			{ std::wstring(    L"èìåòåñÿ"), 6 }, // áåðåãòè~ìåòåñÿ
			{ std::wstring(  L"àòèìåòåñÿ"), 8 }, // íàçèâà~òèìåòåñÿ
			{ std::wstring(L"óâàòèìåòåñÿ"), 10 }, // àêòóàë³çó~âàòèìåòåñÿ
			{ std::wstring(L"þâàòèìåòåñÿ"), 10 }, // àí³ã³ëþ~âàòèìåòåñÿ
			{ std::wstring(  L"èòèìåòåñÿ"), 8 }, // áðèæè~òèìåòåñÿ áè~òèìåòåñÿ
			//{ std::wstring(  L"¿òèìåòåñÿ"), 8 }, // ãíî¿~òèìåòåñÿ
			{ std::wstring( L"î¿òèìåòåñÿ"), 9 }, // ãíî~¿òèìåòåñÿ
			{ std::wstring(  L"îòèìåòåñÿ"), 8 }, // áîðî~òèìåòåñÿ
			{ std::wstring(  L"ÿòèìåòåñÿ"), 9 }, // áî~ÿòèìåòåñÿ
			{ std::wstring(      L"ºòåñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºòåñÿ"), 5 }, // çàáèðà~ºòåñÿ íàçèâà~ºòåñÿ
			//{ std::wstring(     L"èºòåñÿ"), 5 }, // âøè~ºòåñÿ
			//{ std::wstring(     L"³ºòåñÿ"), 5 }, // ðîçóì³~ºòåñÿ
			//{ std::wstring(     L"óºòåñÿ"), 5 }, // àêòóàë³çó~ºòåñÿ
			//{ std::wstring(     L"þºòåñÿ"), 5 }, // àí³ã³ëþ~ºòåñÿ
			//{ std::wstring(     L"ÿºòåñÿ"), 5 }, // ïîìèëÿ~ºòåñÿ
			//{ std::wstring(     L"'ºòåñÿ"), 5 }, // á'~ºòåñÿ
			{ std::wstring(      L"èòåñÿ"), 4 }, // áðèæè~òåñÿ
			{ std::wstring(      L"³òåñÿ"), 4 }, // áåð³~òåñÿ äèâ³~òåñÿ
			//{ std::wstring(      L"¿òåñÿ"), 4 }, // áî¿~òåñÿ áëàãîóñòðî¿~òåñÿ
			{ std::wstring(     L"î¿òåñÿ"), 5 }, // áî~¿òåñÿ áëàãîóñòðî~¿òåñÿ
			{ std::wstring(      L"éòåñÿ"), 5 }, // compound
			//{ std::wstring(     L"àéòåñÿ"), 5 }, // íàçèâà~éòåñÿ
			//{ std::wstring(     L"èéòåñÿ"), 5 }, // áè~éòåñÿ
			//{ std::wstring(     L"³éòåñÿ"), 5 }, // á³~éòåñÿ
			//{ std::wstring(     L"îéòåñÿ"), 5 }, // áëàãîóñòðî~éòåñÿ
			//{ std::wstring(     L"óéòåñÿ"), 5 }, // àêòóàë³çó~éòåñÿ
			//{ std::wstring(     L"þéòåñÿ"), 5 }, // àí³ã³ëþ~éòåñÿ
			{ std::wstring(      L"üòåñÿ"), 4 }, // àðêàíü~òåñÿ
			{ std::wstring(        L"èñÿ"), 3, WordClass::Verb }, // áåðè~ñÿ äèâè~ñÿ áåðåæ~èñÿ
			{ std::wstring(        L"èñÿ"), 3, WordClass::VerbalAdverb }, // áåð³ãø~èñÿ
			{ std::wstring(      L"àëèñÿ"), 4 }, // íàçèâà~ëèñÿ
			{ std::wstring(    L"óâàëèñÿ"), 6 }, // àêòóàë³çó~âàëèñÿ
			{ std::wstring(    L"þâàëèñÿ"), 6 }, // àí³ã³ëþ~âàëèñÿ
			{ std::wstring(      L"èëèñÿ"), 4 }, // áðèæè~ëèñÿ áè~ëèñÿ
			//{ std::wstring(      L"¿ëèñÿ"), 4 }, // áëàãîóñòðî¿~ëèñÿ
			{ std::wstring(     L"î¿ëèñÿ"), 5 }, // áëàãîóñòðî~¿ëèñÿ
			{ std::wstring(      L"îëèñÿ"), 5 }, // áîðî~ëèñÿ
			{ std::wstring(      L"óëèñÿ"), 5 }, // áåõíó~ëèñÿ
			{ std::wstring(      L"ÿëèñÿ"), 5 }, // áîÿ~ëèñÿ
			{ std::wstring(      L"àòèñÿ"), 4 }, // íàçèâà~òèñÿ
			{ std::wstring(    L"óâàòèñÿ"), 6 }, // àêòóàë³çó~âàòèñÿ
			{ std::wstring(    L"þâàòèñÿ"), 6 }, // àí³ã³ëþ~âàòèñÿ
			{ std::wstring(      L"èòèñÿ"), 4 }, // áðèæè~òèñÿ áè~òèñÿ
			{ std::wstring(      L"îòèñÿ"), 4 }, // áîðî~òèñÿ
			//{ std::wstring(      L"¿òèñÿ"), 4 }, // áëàãîóñòðî¿~òèñÿ
			{ std::wstring(     L"î¿òèñÿ"), 5 }, // áëàãîóñòðî~¿òèñÿ
			{ std::wstring(      L"óòèñÿ"), 4 }, // áåõíó~òèñÿ
			{ std::wstring(      L"ÿòèñÿ"), 4 }, // áî~ÿòèñÿ
			{ std::wstring(     L"àâøèñÿ"), 5, WordClass::VerbalAdverb }, // íàçèâà~âøèñÿ áðà~âøèñÿ
			{ std::wstring(     L"îâøèñÿ"), 5, WordClass::VerbalAdverb }, // áîðî~âøèñÿ
			{ std::wstring(   L"óâàâøèñÿ"), 7, WordClass::VerbalAdverb }, // àêòóàë³çó~âàâøèñÿ
			{ std::wstring(   L"þâàâøèñÿ"), 7, WordClass::VerbalAdverb }, // àí³ã³ëþ~âàâøèñÿ àñîö³þ~âàâøèñÿ
			{ std::wstring(     L"èâøèñÿ"), 5, WordClass::VerbalAdverb }, // áåç÷åñòè~âøèñÿ áè~âøèñÿ
			//{ std::wstring(     L"¿âøèñÿ"), 5, WordClass::VerbalAdverb }, // áëàãîóñòðî¿~âøèñÿ
			{ std::wstring(    L"î¿âøèñÿ"), 6, WordClass::VerbalAdverb }, // áëàãîóñòðî~¿âøèñÿ
			{ std::wstring(     L"óâøèñÿ"), 5, WordClass::VerbalAdverb }, // áîâòíó~âøèñÿ çâåðíó~âøèñÿ

			{ std::wstring(        L"éñÿ"), 3, WordClass::Participle }, // compound
			//{ std::wstring(       L"àéñÿ"), 3, WordClass::Participle }, // àéñÿ íàçèâà~éñÿ
			//{ std::wstring(       L"èéñÿ"), 3, WordClass::Participle }, // áåð³ãøè~éñÿ áè~éñÿ
			//{ std::wstring(       L"³éñÿ"), 3, WordClass::Participle }, // á³~éñÿ
			//{ std::wstring(       L"îéñÿ"), 3, WordClass::Participle }, // áëàãîóñòðî~éñÿ
			//{ std::wstring(       L"óéñÿ"), 3, WordClass::Participle }, // àêòóàë³çó~éñÿ
			//{ std::wstring(       L"þéñÿ"), 3, WordClass::Participle }, // àí³ã³ëþ~éñÿ
			{ std::wstring(    L"àâøèéñÿ"), 6, WordClass::Participle }, // áðà~âøèéñÿ
			{ std::wstring(  L"óâàâøèéñÿ"), 8, WordClass::Participle }, // àêóòàë³çó~âàâøèéñÿ
			{ std::wstring(  L"þâàâøèéñÿ"), 8, WordClass::Participle }, // àí³ã³ëþ~âàâøèéñÿ àñîö³þ~âàâøèéñÿ
			{ std::wstring(    L"èâøèéñÿ"), 6, WordClass::Participle }, // áðèæè~âøèéñÿ áè~âøèéñÿ
			//{ std::wstring(    L"¿âøèéñÿ"), 6 }, // áëàãîóñòðî¿~âøèéñÿ
			{ std::wstring(   L"î¿âøèéñÿ"), 7, WordClass::Participle  }, // áëàãîóñòðî~¿âøèéñÿ
			{ std::wstring(    L"îâøèéñÿ"), 6, WordClass::Participle }, // áîðî~âøèéñÿ
			{ std::wstring(    L"óâøèéñÿ"), 6, WordClass::Participle }, // áåõíó~âøèéñÿ
			{ std::wstring(    L"ÿâøèéñÿ"), 7, WordClass::Participle  }, // áî~ÿâøèéñÿ
			{ std::wstring(       L"åìñÿ"), 3 }, // áåðå~ìñÿ áåðåæå~ìñÿ çâåðíå~ìñÿ
			{ std::wstring(     L"èìåìñÿ"), 5 }, // áåðåãòè~ìåìñÿ
			{ std::wstring(       L"ºìñÿ"), 4 }, // compound
			//{ std::wstring(      L"àºìñÿ"), 4 }, // íàçèâà~ºìñÿ
			//{ std::wstring(      L"óºìñÿ"), 4 }, // àêòóàë³çó~ºìñÿ
			//{ std::wstring(      L"þºìñÿ"), 4 }, // àí³ã³ëþ~ºìñÿ
			//{ std::wstring(      L"'ºìñÿ"), 4 }, // á'~ºìñÿ
			{ std::wstring(   L"àòèìåìñÿ"), 7 }, // áðà~òèìåìñÿ
			{ std::wstring(   L"èòèìåìñÿ"), 7 }, // áðèæè~òèìåìñÿ áè~òèìåìñÿ
			//{ std::wstring(   L"¿òèìåìñÿ"), 7 }, // ãíî¿~òèìåìñÿ
			{ std::wstring(  L"î¿òèìåìñÿ"), 8 }, // ãíî~¿òèìåìñÿ
			{ std::wstring(   L"îòèìåìñÿ"), 7 }, // áîðî~òèìåìñÿ
			{ std::wstring( L"óâàòèìåìñÿ"), 9 }, // àêòóàë³çó~âàòèìåìñÿ
			{ std::wstring( L"þâàòèìåìñÿ"), 9 }, // àí³ã³ëþ~âàòèìåìñÿ
			{ std::wstring(   L"ÿòèìåìñÿ"), 8 }, // áî~ÿòèìåìñÿ
			{ std::wstring(       L"èìñÿ"), 3 }, // áðèæè~ìñÿ
			//{ std::wstring(       L"¿ìñÿ"), 3 }, // áëàãîóñòðî¿~ìñÿ
			{ std::wstring(      L"î¿ìñÿ"), 4 }, // áëàãîóñòðî~¿ìñÿ
			//{ std::wstring(        L"îñÿ"), 2 }, // no words á³éìî~ñÿ
			{ std::wstring(       L"ëîñÿ"), 4 }, // áåðåã~ëîñÿ
			{ std::wstring(      L"àëîñÿ"), 4 }, // íàçèâà~ëîñÿ
			{ std::wstring(    L"óâàëîñÿ"), 6 }, // àêòóàë³çó~âàëîñÿ
			{ std::wstring(    L"þâàëîñÿ"), 6 }, // àí³ã³ëþ~âàëîñÿ
			{ std::wstring(      L"åëîñÿ"), 4 }, // äîâå~ëîñÿ
			{ std::wstring(      L"èëîñÿ"), 4 }, // áðèæè~ëîñÿ áè~ëîñÿ
			//{ std::wstring(      L"¿ëîñÿ"), 4 }, // áëàãîóñòðî¿~ëîñÿ
			{ std::wstring(     L"î¿ëîñÿ"), 5 }, // áëàãîóñòðî~¿ëîñÿ
			{ std::wstring(      L"îëîñÿ"), 4 }, // áîðî~ëîñÿ
			{ std::wstring(      L"óëîñÿ"), 4 }, // áåõíó~ëîñÿ
			{ std::wstring(      L"ÿëîñÿ"), 5 }, // áî~ÿëîñÿ
			{ std::wstring(       L"ìîñÿ"), 4 }, // typo:ïîêâàï~ìîñÿ
			{ std::wstring(      L"àìîñÿ"), 4 }, // ïîäà~ìîñÿ
			{ std::wstring(      L"åìîñÿ"), 4 }, // áåðå~ìîñÿ ïîâåðíå~ìîñÿ
			{ std::wstring(    L"èìåìîñÿ"), 6 }, // áåðåãòè~ìåìîñÿ
			{ std::wstring(  L"àòèìåìîñÿ"), 8 }, // íàçèâà~òèìåìîñÿ
			{ std::wstring(L"óâàòèìåìîñÿ"), 10 }, // àêòóàë³çó~âàòèìåìîñÿ
			{ std::wstring(L"þâàòèìåìîñÿ"), 10 }, // àí³ã³ëþ~âàòèìåìîñÿ
			{ std::wstring(  L"èòèìåìîñÿ"), 8 }, // áðèæè~òèìåìîñÿ áè~òèìåìîñÿ
			//{ std::wstring(  L"¿òèìåìîñÿ"), 8 }, // ãíî¿~òèìåìîñÿ
			{ std::wstring( L"î¿òèìåìîñÿ"), 9 }, // ãíî~¿òèìåìîñÿ
			{ std::wstring(  L"îòèìåìîñÿ"), 8 }, // áîðî~òèìåìîñÿ
			{ std::wstring(  L"ÿòèìåìîñÿ"), 8 }, // áîÿ~òèìåìîñÿ
			{ std::wstring(      L"ºìîñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºìîñÿ"), 5 }, // ä³çíà~ºìîñÿ íàçèâà~ºìîñÿ
			//{ std::wstring(     L"óºìîñÿ"), 5 }, // àêòóàë³çó~ºìîñÿ
			//{ std::wstring(     L"þºìîñÿ"), 5 }, // àí³ã³ëþ~ºìîñÿ
			//{ std::wstring(     L"'ºìîñÿ"), 5 }, // á'~ºìîñÿ
			{ std::wstring(      L"èìîñÿ"), 4 }, // áðèæè~ìîñÿ îáìåæè-ìîñÿ
			{ std::wstring(      L"³ìîñÿ"), 4 }, // áåð~³ìîñÿ äèâ³~ìîñÿ
			//{ std::wstring(      L"¿ìîñÿ"), 4 }, // no words
			//{ std::wstring(     L"à¿ìîñÿ"), 4 }, // too little words (íà~¿ìîñÿ)
			{ std::wstring(     L"î¿ìîñÿ"), 5 }, // áî~¿ìîñÿ áëàãîóñòðî~¿ìîñÿ
			{ std::wstring(      L"éìîñÿ"), 5 }, // compound
			//{ std::wstring(     L"àéìîñÿ"), 5 }, // íàçèâà~éìîñÿ âåðòà~éìîñÿ
			//{ std::wstring(     L"èéìîñÿ"), 5 }, // áè~éìîñÿ
			//{ std::wstring(     L"³éìîñÿ"), 5 }, // á³~éìîñÿ
			//{ std::wstring(     L"îéìîñÿ"), 5 }, // áëàãîóñòðî~éìîñÿ
			//{ std::wstring(     L"óéìîñÿ"), 5 }, // àêòóàë³çó~éìîñÿ
			//{ std::wstring(     L"þéìîñÿ"), 5 }, // àí³ã³ëþ~éìîñÿ
			{ std::wstring(      L"üìîñÿ"), 4 }, // áåç÷åñòü~ìîñÿ ñêèíü~ìîñÿ çîñåðåäü~ìîñÿ
			{ std::wstring(        L"óñÿ"), 3 }, // áåð~óñÿ áåç÷åù~óñÿ
			{ std::wstring(      L"èìóñÿ"), 4 }, // áåðåãòè~ìóñÿ
			{ std::wstring(    L"àòèìóñÿ"), 6 }, // áðà~òèìóñÿ
			{ std::wstring(    L"îòèìóñÿ"), 6 }, // áîðî~òèìóñÿ
			//{ std::wstring(    L"¿òèìóñÿ"), 6 }, // ãíî¿~òèìóñÿ
			{ std::wstring(   L"î¿òèìóñÿ"), 7 }, // ãíî~¿òèìóñÿ
			{ std::wstring(  L"óâàòèìóñÿ"), 8 }, // àêòóàë³çó~âàòèìóñÿ
			{ std::wstring(  L"þâàòèìóñÿ"), 8 }, // àí³ã³ëþ~âàòèìóñÿ
			{ std::wstring(    L"èòèìóñÿ"), 6 }, // áðèæè~òèìóñÿ áè~òèìóñÿ
			{ std::wstring(    L"ÿòèìóñÿ"), 6 }, // áî~ÿòèìóñÿ
			{ std::wstring(       L"åøñÿ"), 4 }, // áåð~åøñÿ
			{ std::wstring(     L"èìåøñÿ"), 5 }, // áåðåãòè~ìåøñÿ
			{ std::wstring(   L"àòèìåøñÿ"), 7 }, // íàçèâà~òèìåøñÿ
			{ std::wstring(   L"îòèìåøñÿ"), 7 }, // áîðî~òèìåøñÿ
			{ std::wstring( L"óâàòèìåøñÿ"), 9 }, // àêòóàë³çó~âàòèìåøñÿ
			{ std::wstring( L"þâàòèìåøñÿ"), 9 }, // àí³ã³ëþ~âàòèìåøñÿ
			{ std::wstring(   L"èòèìåøñÿ"), 7 }, // áðèæè~òèìåøñÿ áè~òèìåøñÿ
			//{ std::wstring(   L"¿òèìåøñÿ"), 7 }, // ãíî¿~òèìåøñÿ
			{ std::wstring(  L"î¿òèìåøñÿ"), 8 }, // ãíî~¿òèìåøñÿ
			{ std::wstring(   L"ÿòèìåøñÿ"), 8 }, // áî~ÿòèìåøñÿ
			{ std::wstring(       L"ºøñÿ"), 4 }, // compound
			//{ std::wstring(      L"àºøñÿ"), 4 }, // íàçèâà~ºøñÿ
			//{ std::wstring(      L"óºøñÿ"), 4 }, // àêòóàë³çó~ºøñÿ
			//{ std::wstring(      L"þºøñÿ"), 4 }, // àí³ã³ëþ~ºøñÿ
			//{ std::wstring(      L"'ºøñÿ"), 4 }, // á'~ºøñÿ
			{ std::wstring(       L"èøñÿ"), 4 }, // áðèæ~èøñÿ
			//{ std::wstring(       L"¿øñÿ"), 4 }, // áî~¿øñÿ áëàãîóñòðî~¿øñÿ
			{ std::wstring(      L"î¿øñÿ"), 4 }, // áî~¿øñÿ áëàãîóñòðî~¿øñÿ
			{ std::wstring(        L"üñÿ"), 2 }, // áåç÷åñòü~ñÿ, do not work without SA
			//{ std::wstring(       L"òüñÿ"), 4 }, // Must have vowel (Ut1sa) NOT:áåç÷åñ*òü~ñÿ
			{ std::wstring(      L"àòüñÿ"), 4 }, // íàçèâà~òüñÿ
			{ std::wstring(    L"óâàòüñÿ"), 6 }, // àêòóàë³çó~âàòüñÿ
			{ std::wstring(    L"þâàòüñÿ"), 6 }, // àí³ã³ëþ~âàòüñÿ
			{ std::wstring(      L"åòüñÿ"), 4 }, // áåðå~òüñÿ áåðåæå~òüñÿ
			{ std::wstring(    L"èìåòüñÿ"), 6 }, // áåðåãòè~ìåòüñÿ
			{ std::wstring(  L"àòèìåòüñÿ"), 8 }, // íàçèâà~òèìåòüñÿ
			{ std::wstring(L"þâàòèìåòüñÿ"), 10 }, // àí³ã³ëþ~âàòèìåòüñÿ
			{ std::wstring(L"óâàòèìåòüñÿ"), 10 }, // àêòóàë³çó~âàòèìåòüñÿ
			{ std::wstring(L"èòèìåòüñÿ"), 8 }, // áðèæè~òèìåòüñÿ áè~òèìåòüñÿ
			//{ std::wstring(  L"¿òèìåòüñÿ"), 8 }, // ãíî¿~òèìåòüñÿ
			{ std::wstring( L"î¿òèìåòüñÿ"), 9 }, // ãíî~¿òèìåòüñÿ
			{ std::wstring(  L"îòèìåòüñÿ"), 8 }, // áîðî~òèìåòüñÿ
			{ std::wstring(  L"ÿòèìåòüñÿ"), 9 }, // áî~ÿòèìåòüñÿ

			{ std::wstring(      L"ºòüñÿ"), 5 }, // compound
			//{ std::wstring(     L"àºòüñÿ"), 5 }, // íàçèâà~ºòüñÿ
			//{ std::wstring(     L"óºòüñÿ"), 5 }, // àêòóàë³çó~ºòüñÿ
			//{ std::wstring(     L"þºòüñÿ"), 5 }, // àí³ã³ëþ~ºòüñÿ
			//{ std::wstring(     L"'ºòüñÿ"), 5 }, // á'~ºòüñÿ
			{ std::wstring(      L"èòüñÿ"), 4 }, // áðèæè~òüñÿ áè~òüñÿ
			{ std::wstring(      L"³òüñÿ"), 4 }, // äèâ³~òüñÿ áåð³~òüñÿ áåðåæ³~òüñÿ
			//{ std::wstring(      L"¿òüñÿ"), 5 }, // áëàãîóñòðî~¿òüñÿ
			{ std::wstring(     L"î¿òüñÿ"), 5 }, // áëàãîóñòðî~¿òüñÿ çàñïîêî~¿òüñÿ
			{ std::wstring(      L"îòüñÿ"), 4 }, // áîðî~òüñÿ
			{ std::wstring(      L"óòüñÿ"), 4 }, // áåõíó~òüñÿ áåðó~òüñÿ
			{ std::wstring(    L"èìóòüñÿ"), 6 }, // áåðåãòè~ìóòüñÿ
			{ std::wstring(  L"àòèìóòüñÿ"), 8 }, // íàçèâà~òèìóòüñÿ
			{ std::wstring(  L"îòèìóòüñÿ"), 8 }, // áîðî~òèìóòüñÿ
			{ std::wstring(L"óâàòèìóòüñÿ"), 10 }, // àêòóàë³çó~âàòèìóòüñÿ
			{ std::wstring(L"þâàòèìóòüñÿ"), 10 }, // àí³ã³ëþ~âàòèìóòüñÿ
			{ std::wstring(  L"èòèìóòüñÿ"), 8 }, // áðèæè~òèìóòüñÿ áè~òèìóòüñÿ
			//{ std::wstring(  L"¿òèìóòüñÿ"), 9 }, // ãíî~¿òèìóòüñÿ
			{ std::wstring( L"î¿òèìóòüñÿ"), 9 }, // ãíî~¿òèìóòüñÿ
			{ std::wstring(  L"ÿòèìóòüñÿ"), 9 }, // áî~ÿòèìóòüñÿ
			{ std::wstring(      L"þòüñÿ"), 5 }, // compound áîð~þòüñÿ
			//{ std::wstring(     L"àþòüñÿ"), 5 }, // íàçèâà~þòüñÿ
			//{ std::wstring(     L"þþòüñÿ"), 5 }, // àí³ã³ëþ~þòüñÿ
			//{ std::wstring(     L"'þòüñÿ"), 5 }, // á'~þòüñÿ
			//{ std::wstring(      L"¿òüñÿ"), 4 }, // çàñïîêî¿~òüñÿ
			{ std::wstring(     L"óþòüñÿ"), 5 }, // àêòóàë³çó~þòüñÿ
			{ std::wstring(      L"ÿòüñÿ"), 5}, // áåç÷åñò~ÿòüñÿ äèâë~ÿòüñÿ
			{ std::wstring(     L"îÿòüñÿ"), 5 }, // çàñïîêî~ÿòüñÿ ãíî~ÿòüñÿ áî~ÿòüñÿ
			{ std::wstring(        L"þñÿ"), 3 }, // compound àðêàí~þñÿ äèâë~þñÿ
			//{ std::wstring(       L"àþñÿ"), 3 }, // çíà~þñÿ íàçèâà~þñÿ
			//{ std::wstring(       L"îþñÿ"), 3 }, // áî~þñÿ áëàãîóñòðî~þñÿ ãíî~þñÿ
			//{ std::wstring(       L"óþñÿ"), 3 }, // àêòóàë³çó~þñÿ
			//{ std::wstring(       L"þþñÿ"), 3 }, // àí³ã³ëþ~þñÿ õâèëþ~þñÿ
			//{ std::wstring(       L"'þñÿ"), 3 }, // á'~þñÿ
		};

		static bool sureSuffixesInitialized = false;
		if (!sureSuffixesInitialized)
		{
			sureSuffixesInitialized = true;
			sureSuffixes = std::move(sureSuffixesStatic);;

			for (const SuffixEnd& suffixEnd : sureSuffixes)
			{
				if (suffixEnd.TakeCharsCount > suffixEnd.MatchSuffix.size())
				{
					PG_Assert2(false, "actual suffix size must be <= of possible suffix size");
				}
			}
			std::sort(sureSuffixes.begin(), sureSuffixes.end(), [](SuffixEnd& a, SuffixEnd& b)
			{
				if (a.MatchSuffix.size() != b.MatchSuffix.size())
					return a.MatchSuffix.size() > b.MatchSuffix.size();
				return a.MatchSuffix < b.MatchSuffix;
			});
			for (size_t i = 0; i<sureSuffixes.size()-1; ++i)
			{
				const auto& curSuffix = sureSuffixes[i].MatchSuffix;
				if (curSuffix == sureSuffixes[i + 1].MatchSuffix && sureSuffixes[i].WordClass == sureSuffixes[i+1].WordClass)
				{
					PG_Assert2(false, "Duplicate suffixs");
				}
			}
		}
	}

	bool isValidPhoneticSplit(wv::slice<wchar_t> word, int splitPos)
	{
		bool correct = splitPos > 0 && splitPos <= word.size();
		if (!correct)
			return false;

		PG_Assert(splitPos > 0);

		wchar_t prefixLastChar = word[splitPos - 1];
		wchar_t suffixFirstChar = word[splitPos];
		int suffixSize = word.size() - splitPos;

		// soft character modifies the previous character, the can't be separated
		if (suffixFirstChar == L'ü')
			return false;

		// WHY?
		// allow suffixes like "jmo"
		//if (suffixFirstChar == L'é' && suffixSize == 1)
		//	return false;

		// apostrophe makes previous consonant stronger, do not separate it from prefix
		if (suffixFirstChar == L'\'' || suffixFirstChar == L'\'')
			return false;

		return true;
	}

	void populatePronCodes(const std::vector<PhoneticWord>& phoneticDict, std::map<boost::wstring_view, PronunciationFlavour>& pronCodeToObj, std::vector<boost::wstring_view>& duplicatePronCodes)
	{
		for (const PhoneticWord& word : phoneticDict)
		{
			for (const PronunciationFlavour& pron : word.Pronunciations)
			{
				const auto& code = pron.PronCode;
				auto it = pronCodeToObj.find(code);
				if (it != pronCodeToObj.end())
					duplicatePronCodes.push_back(code);
				else
					pronCodeToObj.insert({ code, pron });
			}
		}
	}

	void mergePhoneticDictOnlyNew(std::map<boost::wstring_view, PhoneticWord>& basePhoneticDict, const std::vector<PhoneticWord>& extraPhoneticDict)
	{
		for (const PhoneticWord& extraWord : extraPhoneticDict)
		{
			boost::wstring_view wordRef = extraWord.Word;
			auto wordIt = basePhoneticDict.find(wordRef);
			if (wordIt == basePhoneticDict.end())
			{
				// new word; add the whole word with all prons
				basePhoneticDict.insert({ wordRef, extraWord });
				continue;
			}

			// existing word; try to integrate new prons into it
			PhoneticWord& baseWord = wordIt->second;
			for (const PronunciationFlavour& extraPron : extraWord.Pronunciations)
			{
				auto matchedPronIt = std::find_if(baseWord.Pronunciations.begin(), baseWord.Pronunciations.end(), [&extraPron](PronunciationFlavour& p)
				{
					return p.PronCode == extraPron.PronCode;
				});
				bool duplicatePron = matchedPronIt != baseWord.Pronunciations.end();
				if (duplicatePron)
					continue; // pron with the same code already exist
				baseWord.Pronunciations.push_back(extraPron);
			}
		}
	}

	// Tries to split the word into two parts, so that the phonetic transcription is not corrupted.
	// Returns prefix size or -1 if word can't be split.
	int phoneticSplitOfWord(wv::slice<wchar_t> word, boost::optional<WordClass> wordClass, int* pMatchedSuffixInd)
	{
		ensureSureSuffixesInitialized();

		for (size_t suffixInd = 0; suffixInd < sureSuffixes.size(); ++suffixInd)
		{
			const SuffixEnd& suffixEnd = sureSuffixes[suffixInd];
			WordClass suffixClass = suffixEnd.WordClass;

			//WordClass suffixClass = suffixEnd.WordClass;
			//if (suffixClass == WordClass::Participle || suffixClass == WordClass::VerbalAdverb)
			//	suffixClass = WordClass::Verb;

			//WordClass wordClassTmp = wordClass.get();
			//if (wordClassTmp == WordClass::Participle || wordClassTmp == WordClass::VerbalAdverb)
			//	wordClassTmp = WordClass::Verb;

			if (wordClass != boost::none)
			{
				// match word class and suffix (word) class
				WordClass wordClassTmp = wordClass.get();
				if (wordClassTmp != suffixClass)
					continue;
			}

			const std::wstring& suffix = suffixEnd.MatchSuffix;
			if (endsWith<wchar_t>(word, suffix))
			{
				int suffixSize = suffixEnd.TakeCharsCount;
				int prefixSize = (int)word.size() - suffixSize;
				
				// prohibit detaching the soft sign from prefix
				if (word[prefixSize] == L'ü' && prefixSize + 1 < word.size())
					prefixSize++;

				// trim vowels at the end of the prefix
				bool trimEndVowels = false;
				if (trimEndVowels)
				{
					bool isPrefixEndsVowel = true;
					while (prefixSize > 0 && isPrefixEndsVowel)
					{
						wchar_t prefixLastChar = word[prefixSize - 1];
						isPrefixEndsVowel = !PticaGovorun::isUkrainianConsonant(prefixLastChar);
						if (isPrefixEndsVowel)
							prefixSize--;
					}
				}

				// avoid short prefixes, as they will not participate in other words construction frequently
				// áîÿâøèéñÿ -> á
				// need prefixes with size>1 to distinguish (áè~éñÿ, á³~éñÿ)
				if (prefixSize <= 1) continue;

				if (!isValidPhoneticSplit(word, prefixSize))
					continue;

				if (wordClass == WordClass::Participle && suffixEnd.WordClass != WordClass::Participle)
				{
					participleSuffixToWord[suffixEnd.MatchSuffix] = std::wstring(word.data(), word.size());
				}
				if (wordClass == WordClass::VerbalAdverb && suffixEnd.WordClass != WordClass::VerbalAdverb)
				{
					participleSuffixToWord2[suffixEnd.MatchSuffix] = std::wstring(word.data(), word.size());
				}

				if (pMatchedSuffixInd != nullptr)
					*pMatchedSuffixInd = (int)suffixInd;
				
				return prefixSize;
			}
		}

		return -1;
	}

	boost::wstring_view fillerSilence()
	{
		return L"<sil>";
	}

	boost::wstring_view fillerStartSilence()
	{
		return L"<s>";
	}

	boost::wstring_view fillerEndSilence()
	{
		return L"</s>";
	}

	boost::wstring_view fillerShortPause()
	{
		return L"[sp]";
	}

	boost::wstring_view fillerInhale()
	{
		return L"[inh]";
	}

	boost::wstring_view fillerEee()
	{
		return L"[eee]";
	}

	boost::wstring_view fillerYyy()
	{
		return L"[yyy]";
	}

	boost::wstring_view fillerClick()
	{
		return L"[clk]";
	}

	boost::wstring_view fillerGlottal()
	{
		return L"[glt]";
	}

	// Returns number of made transformations or zero if the map was not changed.
	int reuseCommonPrefixesOneIteration(std::map<std::wstring, int>& mapPrefixToSize)
	{
		if (mapPrefixToSize.size() <= 1)
			return 0;

		std::vector<std::wstring> prefixes(mapPrefixToSize.size());
		std::transform(std::begin(mapPrefixToSize), std::end(mapPrefixToSize), std::begin(prefixes), [](const std::pair<std::wstring, int>& pair)
		{
			return pair.first;
		});
		std::sort(std::begin(prefixes), std::end(prefixes), [](std::wstring& a, std::wstring& b)
		{
			return a.size() < b.size();
		});

		int changesMade = 0;
		std::vector<uchar> processed(prefixes.size());
		for (size_t i = 0; i < processed.size(); ++i)
		{
			if (processed[i])
				continue;
			processed[i] = true;
			for (size_t j = i; j < processed.size(); ++j)
			{
				if (processed[j])
					continue;
				const std::wstring& s1 = prefixes[i];
				const std::wstring& s2 = prefixes[j];
				PG_DbgAssert2(s1.size() <= s2.size(), "Strings are ordered in ascending order");

				size_t prefixSize = commonPrefixSize<wchar_t>(s1, s2);
				auto countConsonant = [](wchar_t ch) { return isUkrainianConsonant(ch); };
				size_t conson1 = std::count_if(s1.begin() + prefixSize, s1.end(), countConsonant);
				size_t conson2 = std::count_if(s2.begin() + prefixSize, s2.end(), countConsonant);

				bool canSplit1 = isValidPhoneticSplit(s1, prefixSize);
				bool canSplit2 = isValidPhoneticSplit(s1, prefixSize);

				// can reduce two prefixes only if they differ in ending of all vowels
				bool canReduce = (prefixSize < s1.size() || prefixSize < s2.size()) && conson1 == 0 && conson2 == 0 && canSplit1 && canSplit2;
				if (!canReduce)
					continue;

				if (prefixSize < s1.size() ^ prefixSize < s2.size()) // one is the prefix of another
				{
					// keep shorter prefix, remove longer prefix
					const std::wstring *shorter = nullptr;
					const std::wstring *longer = nullptr;
					size_t longerWordInd;
					if (prefixSize < s1.size())
					{
						shorter = &s1;
						longer = &s2;
						longerWordInd = j;
					}
					else
					{
						shorter = &s2;
						longer = &s1;
						longerWordInd = i;
					}
					int usedCount = mapPrefixToSize[*longer];
					mapPrefixToSize.erase(*longer);

					mapPrefixToSize[*shorter] += usedCount;

					processed[longerWordInd] = true;
				}
				else
				{
					int usedCount1 = mapPrefixToSize[s1];
					int usedCount2 = mapPrefixToSize[s2];
					mapPrefixToSize.erase(s1);
					mapPrefixToSize.erase(s2);

					std::wstring prefix(s1.data(), prefixSize);
					mapPrefixToSize[prefix] += usedCount1 + usedCount2;
					processed[i] = true;
					processed[j] = true;
				}
				changesMade++;
			}
		}
		return changesMade;
	}

	void reuseCommonPrefixes(std::map<std::wstring, int>& mapPrefixToSize)
	{
		while (reuseCommonPrefixesOneIteration(mapPrefixToSize) > 0) {}
	}

	bool isVoiceless(wchar_t ch)
	{
		bool voiceless = ch == L'÷'; // áóðêî÷
		return voiceless;
	}

	UkrainianPhoneticSplitter::UkrainianPhoneticSplitter()
	{
		bool wasAdded = false;
		sentStartWordPart_ = wordUsage_.getOrAddWordPart(L"<s>", WordPartSide::WholeWord, &wasAdded);
		PG_Assert(wasAdded);
		sentEndWordPart_ = wordUsage_.getOrAddWordPart(L"</s>", WordPartSide::WholeWord, &wasAdded);
		PG_Assert(wasAdded);
	}

	void UkrainianPhoneticSplitter::bootstrapFromDeclinedWords(const std::unordered_map<std::wstring, std::unique_ptr<WordDeclensionGroup>>& words, const std::wstring& targetWord, const std::unordered_set<std::wstring>& processedWords)
	{
		for (const auto& pair : words)
		{
			const WordDeclensionGroup& wordGroup = *pair.second;
			bool contains = processedWords.find(wordGroup.Name) != processedWords.end();
			if (false && !contains)
				continue;

			if (!targetWord.empty() && wordGroup.Name != targetWord)
				continue;

			if (!allowPhoneticWordSplit_)
			{
				// put all word declination forms as whole word parts
				for (const WordDeclensionForm& declWord : wordGroup.Forms)
				{
					if (declWord.isNotAvailable()) continue;
					const WordPart* wordPart = wordUsage_.getOrAddWordPart(declWord.Name, WordPartSide::WholeWord);
				}
				continue;
			}

			if (wordGroup.WordClass == WordClass::Irremovable ||
				wordGroup.WordClass == WordClass::Preposition ||
				wordGroup.WordClass == WordClass::Pronoun ||
				wordGroup.WordClass == WordClass::Conjunction ||
				wordGroup.WordClass == WordClass::Interjection ||
				wordGroup.WordClass == WordClass::Particle ||
				wordGroup.WordClass == WordClass::Irremovable)
			{
				// keep the word intact
				continue;
			}
			else if (
				wordGroup.WordClass == WordClass::Adjective ||
				wordGroup.WordClass == WordClass::Adverb ||
				wordGroup.WordClass == WordClass::Noun ||
				wordGroup.WordClass == WordClass::Numeral ||
				wordGroup.WordClass == WordClass::Verb ||
				wordGroup.WordClass == WordClass::VerbalAdverb ||
				wordGroup.WordClass == WordClass::Participle)
			{
				std::vector<std::wstring> unsplitWords;
				std::map<std::wstring, int> mapPrefixSizeToCount;
				for (const WordDeclensionForm& wordForm : wordGroup.Forms)
				{
					const std::wstring& word = wordForm.Name;

					// split comma separated words into words
					size_t newOffset;
					for (size_t offset = 0; offset < word.size(); offset = newOffset + 1) // +1 to skip comma
					{
						if (word[offset] == L'*')
							offset++;
						newOffset = word.find(L",", offset);
						if (newOffset == (size_t)-1)
							newOffset = word.size();

						wv::slice<wchar_t> subWord = wv::make_view(word.data() + offset, newOffset - offset);

						int matchedSuffixInd = -1;
						WordClass curWordClass = wordGroup.WordClass.get();
						if (wordForm.WordClass != boost::none)
							curWordClass = wordForm.WordClass.get();

						int sepInd = phoneticSplitOfWord(subWord, curWordClass, &matchedSuffixInd);
						if (sepInd != -1)
							sureSuffixes[matchedSuffixInd].UsedCount++;

						if (sepInd == -1)
						{
							bool voiceless = isVoiceless(subWord[subWord.size() - 1]);

							wchar_t wordLastChar = subWord[subWord.size() - 1];
							bool ok =
								wordLastChar == L'ü' ||
								wordLastChar == L'æ' || // áðîäÿæ
								voiceless;

							// it is ok to not finding consonant+sa
							if (!ok && endsWith(subWord, (wv::slice<wchar_t>)std::wstring(L"ñÿ")))
							{
								wchar_t prefixLastChar = subWord[subWord.size() - 1 - 2];
								ok = isUkrainianConsonant(prefixLastChar);
							}
							if (!ok)
							{
								std::wstring subWordStr(subWord.data(), subWord.size());
								unsplitWords.push_back(subWordStr);
								//::DebugBreak();
								//::OutputDebugStringW(L"Suffix was not found for word: ");
								//::OutputDebugStringW(subWordStr.data());
								//::OutputDebugStringW(L"\n");
							}
						}

						//if (sepInd != -1)
						//{
						//	wv::slice<wchar_t> prefixWord = wv::make_view(subWord.data(), sepInd);
						//	static std::wstring suffixVa(L"âà");
						//	if (endsWith(prefixWord, wv::make_view(suffixVa)))
						//	{
						//		// skip -va words
						//		//continue;
						//	}
						//}

						// store prefix to usage count
						{
							int sepIndTmp = sepInd;
							if (sepIndTmp == -1)
								sepIndTmp = subWord.size();

							// separation position was not found, use the whole word
							std::wstring prefixStr(subWord.data(), 0, sepIndTmp);
							mapPrefixSizeToCount[prefixStr]++;
						}

						int partsCount;
						std::array<std::wstring, 2> partsStrings;
						std::array<WordPartSide, 2> partsSides;
						if (sepInd == -1)
						{
							// separation position was not found, use the whole word
							partsCount = 1;
							partsStrings[0] = toString(subWord);
							partsSides[0] = WordPartSide::WholeWord;
						}
						else
						{
							partsCount = 2;

							wv::slice<wchar_t> prefix = wv::make_view(subWord.data(), sepInd);
							wv::slice<wchar_t> suffix = wv::make_view(subWord.data() + sepInd, subWord.size() - sepInd);

							partsStrings[0] = toString(prefix);
							partsSides[0] = WordPartSide::LeftPart;
							partsStrings[1] = toString(suffix);
							partsSides[1] = WordPartSide::RightPart;
						}

						//
						ShortArray<int, 2> splitParts;
						splitParts.Array.fill(-1);
						splitParts.ActualSize = partsCount;

						for (int partInd = 0; partInd < partsCount; ++partInd)
						{
							const std::wstring& partStr = partsStrings[partInd];
							WordPartSide partSide = partsSides[partInd];

							const WordPart* wordPart = wordUsage_.getOrAddWordPart(partStr, partSide);

							//WordSeqKey wordIds({ wordPart->id() });
							//WordSeqUsage* wordSeq = wordUsage_.getOrAddWordSequence(wordIds);
							//wordSeq->UsedCount++;

							splitParts.Array[partInd] = wordPart->id();
						}
						wordStrToPartIds_[word] = splitParts;
					}
				}

				size_t diffPrefixCountBefore = mapPrefixSizeToCount.size();
				reuseCommonPrefixes(mapPrefixSizeToCount);

				size_t diffPrefixCount = mapPrefixSizeToCount.size();
				for (const auto& prefixToCountPair : mapPrefixSizeToCount)
				{
					const auto& prefix = prefixToCountPair.first;
					wchar_t ch = prefix[prefix.size() - 1];
					bool voiceless = isVoiceless(ch);
					if (ch == L'ü' || voiceless || ch == L'-')
						diffPrefixCount--;
				}
				//std::wcout << L"word finished diffPrefixCount=" << diffPrefixCount << std::endl;
			}
			else
				::DebugBreak(); // unknown word class
		}
		const auto& m1 = participleSuffixToWord;
		const auto& m2 = participleSuffixToWord2;
		OutputDebugStringW(L"PARTICIPLE\n");
		for (const auto& pair : participleSuffixToWord)
		{
			OutputDebugStringW(pair.first.c_str());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(pair.second.c_str());
			OutputDebugStringW(L"\n");
		}
		OutputDebugStringW(L"VERBALADVERB\n");
		for (const auto& pair : participleSuffixToWord2)
		{
			OutputDebugStringW(pair.first.c_str());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(pair.second.c_str());
			OutputDebugStringW(L"\n");
		}
	}

	const WordsUsageInfo& UkrainianPhoneticSplitter::wordUsage() const
	{
		return wordUsage_;
	}
	WordsUsageInfo& UkrainianPhoneticSplitter::wordUsage()
	{
		return wordUsage_;
	}

	void UkrainianPhoneticSplitter::printSuffixUsageStatistics() const
	{
		auto sureSuffixesCopy = sureSuffixes;
		std::sort(sureSuffixesCopy.begin(), sureSuffixesCopy.end(), [](SuffixEnd& a, SuffixEnd& b)
		{
			return a.UsedCount > b.UsedCount;
		});
		OutputDebugStringW(L"Suffix usage statistics:\n");
		for (const auto& suffixEnd : sureSuffixesCopy)
		{
			OutputDebugStringW(suffixEnd.MatchSuffix.data());
			OutputDebugStringW(L"\t");
			OutputDebugStringW(QString::number(suffixEnd.UsedCount).toStdWString().c_str());

			wchar_t* classStr = L"";
			if (suffixEnd.WordClass == WordClass::Verb)
				classStr = L"v";
			else if (suffixEnd.WordClass == WordClass::Noun)
				classStr = L"n";
			else if (suffixEnd.WordClass == WordClass::Adjective)
				classStr = L"adj";
			else if (suffixEnd.WordClass == WordClass::Adverb)
				classStr = L"adverb";
			OutputDebugStringW(L" ");
			OutputDebugStringW(classStr);
			OutputDebugStringW(L"\n");
		}
	}

	long UkrainianPhoneticSplitter::wordSeqCount(int wordsPerSeq) const
	{
		PG_Assert(wordsPerSeq <= 2);
		if (wordsPerSeq == 1)
			return seqOneWordCounter_;
		return seqTwoWordsCounter_;
	}

	const WordPart* UkrainianPhoneticSplitter::sentStartWordPart() const
	{
		return sentStartWordPart_;
	}

	const WordPart* UkrainianPhoneticSplitter::sentEndWordPart() const
	{
		return sentEndWordPart_;
	}

	void UkrainianPhoneticSplitter::setAllowPhoneticWordSplit(bool value)
	{
		allowPhoneticWordSplit_ = value;
	}

	bool UkrainianPhoneticSplitter::allowPhoneticWordSplit() const
	{
		return allowPhoneticWordSplit_;
	}

	void UkrainianPhoneticSplitter::setSentParser(std::shared_ptr<SentenceParser> sentParser)
	{
		sentParser_ = sentParser;
	}

	void UkrainianPhoneticSplitter::gatherWordPartsSequenceUsage(const wchar_t* textFilesDir, long& totalPreSplitWords, int maxFileToProcess)
	{
		QFile corpusFile;
		QTextStream corpusStream;
		if (outputCorpus_)
		{
			corpusFile.setFileName(toQString(corpusFilePath_.wstring()));
			if (!corpusFile.open(QIODevice::WriteOnly | QIODevice::Text))
				return;
			corpusStream.setDevice(&corpusFile);
			corpusStream.setCodec("UTF-8");
			log_ = &corpusStream;
		}

		QXmlStreamReader xml;
		totalPreSplitWords = 0;

		std::vector<wv::slice<wchar_t>> words;
		words.reserve(64);
		std::vector<const WordPart*> wordParts;
		wordParts.reserve(1024);
		TextParser wordsReader;

		QString textFilesDirQ = QString::fromStdWString(textFilesDir);
		QDirIterator it(textFilesDirQ, QStringList() << "*.fb2", QDir::Files, QDirIterator::Subdirectories);
		int processedFiles = 0;
		while (it.hasNext())
		{
			if (maxFileToProcess != -1 && processedFiles == maxFileToProcess)
				break;

			//if (processedFiles >= 2) break; // process less work

			QString txtPath = it.next();
			if (txtPath.contains("BROKEN", Qt::CaseSensitive))
			{
				std::wcout << L"SKIPPED " << txtPath.toStdWString() <<std::endl;
				continue;
			}
			std::wcout << txtPath.toStdWString() <<std::endl;

			//
			QFile file(txtPath);
			if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			{
				std::wcerr << L"Can't open file " << txtPath.toStdWString() <<std::endl;
				return;
			}

			// parse file
			xml.setDevice(&file);

			bool reachedBody = false;
			while (!xml.atEnd())
			{
				QXmlStreamReader::TokenType token = xml.readNext();

				auto nodeName = xml.name();

				if (xml.isStartElement() && xml.name() == "body")
				{
					reachedBody = true;
					continue;
				}

				//if (reachedBody && xml.isCharacters())
				if (xml.isCharacters())
				{
					// BUG: if the lines inside the text are separated using LF only on windows machines
					//      the function below will concatenate the lines. For now, fix LF->CRLF for such files externally
					QStringRef elementText = xml.text();

					wv::slice<wchar_t> textToParse = wv::make_view((wchar_t*)elementText.data(), elementText.size());
					wordsReader.setInputText(textToParse);

					// extract all sentences from paragraph
					while (true)
					{
						words.clear();
						if (!wordsReader.parseSentence(words))
							break;
						if (words.empty())
							continue;

						std::vector<RawTextLexeme> lexemes;
						lexemes.reserve(words.size());
						analyzeSentence(words, lexemes);

						AbbreviationExpanderUkr abbrExp;
						abbrExp.expandInplace(0, lexemes);

						bool isUkr = checkGoodSentenceUkr(lexemes);
						if (!isUkr)
						{
							if (outputCorpus_) // output sentence with bad words
							{
								corpusStream << "BAD: ";
								for (wv::slice<wchar_t> word : words)
								{
									corpusStream << toQString(boost::wstring_view(word.data(), word.size()));
									corpusStream << " ";
								}
								//for (const WordPart* wp : wordPartsStraight)
								//{
								//	printWordPart(wp, corpusStream);
								//	corpusStream << " ";
								//}
								corpusStream << "\n";
							}
							continue;
						}
						else
						{
							if (outputCorpus_)
							{
								for (const RawTextLexeme& lex : lexemes)
								{
									corpusStream << toQString(lex.ValueStr);
									corpusStream << " ";
								}
								corpusStream << "\n";
							}
						}

						{
							// augment the sentence with start/end terminators
							wordParts.push_back(sentStartWordPart_);

							selectWordParts(lexemes, wordParts, totalPreSplitWords);

							// augment the sentence with start/end terminators
							wordParts.push_back(sentEndWordPart_);
						}

						// calculate statistic only if enough word parts is accumulated
						size_t calcStatWordPartsCount = 1000000;
						if (wordParts.size() > calcStatWordPartsCount)
						{
							calcNGramStatisticsOnWordPartsBatch(wordParts);
						}
					}
				}
			}
			
			// flush the word parts buffer
			calcNGramStatisticsOnWordPartsBatch(wordParts);

			if (xml.hasError())
			{
				std::wcerr <<"XmlError: " << xml.errorString().toStdWString() << std::endl;
			}

			++processedFiles;
		}
	}

	/// Reads text from FB2 documents. FB2 is an xml format.
	class Fb2TextBlockReader : public TextBlockReader
	{
		QXmlStreamReader& xml_;
		bool skippedHeader = false;
	public:

		Fb2TextBlockReader(QXmlStreamReader& xml): xml_(xml)
		{
		}

		bool nextBlock(std::vector<wchar_t>& buff) override
		{
			if (!skippedHeader)
			{
				while (!xml_.atEnd())
				{
					QXmlStreamReader::TokenType token = xml_.readNext();
					auto nodeName = xml_.name();
					if (xml_.isStartElement() && nodeName == "body")
						break;
				}
				skippedHeader = true;
			}
			while (!xml_.atEnd())
			{
				QXmlStreamReader::TokenType token = xml_.readNext();
				auto nodeName = xml_.name();

				if (xml_.isCharacters())
				{
					// BUG: if the lines inside the text are separated using LF only on windows machines
					//      the function below will concatenate the lines. For now, fix LF->CRLF for such files externally
					QStringRef elementText = xml_.text();

					QString elementStr = elementText.toString();
					
					buff.resize(elementStr.size());
					int copyCount = elementStr.toWCharArray(buff.data());
					PG_DbgAssert2(copyCount == elementStr.size(), "Not all chars are copied");
					return true;
				}
			}
			return false;
		}

		bool hasError() const { return xml_.hasError(); }
		std::wstring errorStdWString() const { return xml_.errorString().toStdWString(); }
	};

	void UkrainianPhoneticSplitter::gatherWordPartsSequenceUsageFullSent(const wchar_t* textFilesDir, long& totalPreSplitWords, int maxFileToProcess)
	{
		QFile corpusFile;
		QTextStream corpusStream;
		if (outputCorpus_)
		{
			corpusFile.setFileName(toQString(corpusFilePath_.wstring()));
			if (!corpusFile.open(QIODevice::WriteOnly | QIODevice::Text))
				return;
			corpusStream.setDevice(&corpusFile);
			corpusStream.setCodec("UTF-8");
			log_ = &corpusStream;
		}
		QFile normalizDebugFile;
		QTextStream normalizDebugStream;
		if (outputCorpusNormaliz_)
		{
			normalizDebugFile.setFileName(toQString(corpusNormalizFilePath_.wstring()));
			if (!normalizDebugFile.open(QIODevice::WriteOnly | QIODevice::Text))
				return;
			normalizDebugStream.setDevice(&normalizDebugFile);
			normalizDebugStream.setCodec("UTF-8");
		}

		QXmlStreamReader xml;
		totalPreSplitWords = 0;

		std::vector<wv::slice<wchar_t>> words;
		words.reserve(64);
		std::vector<const WordPart*> wordParts;
		wordParts.reserve(1024*1024);

		QString textFilesDirQ = QString::fromStdWString(textFilesDir);
		QDirIterator it(textFilesDirQ, QStringList() << "*.fb2", QDir::Files, QDirIterator::Subdirectories);
		int processedFiles = 0;
		while (it.hasNext())
		{
			if (maxFileToProcess != -1 && processedFiles == maxFileToProcess)
				break;

			//if (processedFiles >= 2) break; // process less work

			QString txtPath = it.next();
			if (txtPath.contains("BROKEN", Qt::CaseSensitive))
			{
				std::wcout << L"SKIPPED " << txtPath.toStdWString() <<std::endl;
				continue;
			}
			std::wcout << txtPath.toStdWString() <<std::endl;

			//
			QFile file(txtPath);
			if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			{
				std::wcerr << L"Can't open file " << txtPath.toStdWString() <<std::endl;
				return;
			}
			xml.setDevice(&file);

			// parse file
			Fb2TextBlockReader fb2Reader(xml);

			auto onSent = [&](gsl::span<const RawTextLexeme>& sent)
			{
				gsl::span<const RawTextRun> runs = sentParser_->curSentRuns();

				// expansion is required for numbers (arabic and roman)
				auto needExpansionBefore = [&]() -> bool {
					return std::any_of(std::begin(runs), std::end(runs), [](const RawTextRun& x)
					{
						return x.Type == TextRunType::Digit ||
							x.Str == L"¬" ||
							std::all_of(std::begin(x.Str), std::end(x.Str), isRomanNumeral);
					});
				};

				std::vector<RawTextLexeme> oneSent(sent.begin(), sent.end());
				removeWhitespaceLexemes(oneSent);

				auto needExpansionAfter = [&]() -> bool {
					return std::any_of(std::begin(oneSent), std::end(oneSent), [](const RawTextLexeme& x)
					{
						return x.Class == WordClass::Numeral || // arabic or roman
							x.ValueStr == L"¬";
					});
				};

				//if (corpusNormalizDebug_ && needExpansionAfter())
				if (outputCorpusNormaliz_)
				{
					normalizDebugStream << "-- ";
					for (const RawTextRun& run : runs)
					{
						normalizDebugStream << toQString(run.Str);
					}
					normalizDebugStream << "\n";
					normalizDebugStream << "++ ";
					for (const RawTextLexeme& lex : oneSent)
					{
						normalizDebugStream << toQString(lex.ValueStr);
						normalizDebugStream << " ";
					}
					normalizDebugStream << "\n";
				}
				
				//
				if (needExpansionAfter())
					return; // keep language model clean

				// remove unnecessary lexemes
				{
					auto newEnd = std::remove_if(std::begin(oneSent), std::end(oneSent),
						[](auto& x)
					{
						return
							x.RunType == TextRunType::Whitespace ||
							x.RunType == TextRunType::Punctuation ||
							x.RunType == TextRunType::PunctuationStopSentence;
					});
					oneSent.erase(newEnd, std::end(oneSent));
				}

				if (outputCorpus_)
				{
					corpusStream << toQString(sentStartWordPart_->partText()) << " ";
					for (const RawTextLexeme& lex : oneSent)
					{
						corpusStream << toQString(lex.ValueStr);
						corpusStream << " ";
					}
					corpusStream << toQString(sentEndWordPart_->partText());
					corpusStream << "\n";
				}

				// augment the sentence with start/end terminators
				wordParts.push_back(sentStartWordPart_);

				selectWordParts(oneSent, wordParts, totalPreSplitWords);

				// augment the sentence with start/end terminators
				wordParts.push_back(sentEndWordPart_);
			};

			sentParser_->setTextBlockReader(&fb2Reader);
			sentParser_->setOnNextSentence(onSent);
			sentParser_->run();

			// collect statistics on all word parts from a file
			calcNGramStatisticsOnWordPartsBatch(wordParts);
			PG_DbgAssert(wordParts.empty())

			if (fb2Reader.hasError())
			{
				std::wcerr <<"XmlError: " << fb2Reader.errorStdWString() << std::endl;
			}

			++processedFiles;
		}
	}

	void UkrainianPhoneticSplitter::analyzeSentence(const std::vector<wv::slice<wchar_t>>& words, std::vector<RawTextLexeme>& lexemes) const
	{
		for (int i = 0; i < words.size(); ++i)
		{
			const wv::slice<wchar_t>& wordSlice = words[i];
			PG_Assert(!wordSlice.empty());

			int digitsCount = 0;
			int romanChCount = 0;
			int engCount = 0;
			int exclEngCount = 0;
			int rusCount = 0;
			int exclRusCount = 0;
			int hyphenCount = 0;

			auto wordCharUsage = [&](wv::slice<wchar_t> word)
			{
				for (size_t charInd = 0; charInd < word.size(); ++charInd)
				{
					wchar_t ch = word[charInd];
					bool isDigit = isDigitChar(ch);
					if (isDigit)
						digitsCount += 1;
					bool isRomanCh = isRomanNumeral(ch);
					if (isRomanCh)
						romanChCount += 1;
					bool isEng = isEnglishChar(ch);
					if (isEng)
						engCount++;
					bool isExclEng = isExclusiveEnglishChar(ch);
					if (isExclEng)
						exclEngCount++;
					bool isRus = isRussianChar(ch);
					if (isRus)
						rusCount++;
					bool isExclRus = isExclusiveRussianChar(ch);
					if (isExclRus)
						exclRusCount++;
					if (ch == L'-' || ch == L'\'')
						hyphenCount++;
				}
			};
			wordCharUsage(wordSlice);

			RawTextLexeme lex;
			lex.ValueStr = boost::wstring_view(wordSlice.data(), wordSlice.size());

			// output non-leterate words with digits, cryptic symbols, etc.
			if (digitsCount == wordSlice.size()) // Arabic number
			{
				lex.Class = WordClass::Numeral;
				lex.NumeralLexView = NumeralLexicalView::Arabic;
			}
			else if (romanChCount == wordSlice.size()) // Roman number
			{
				lex.Class = WordClass::Numeral;
				lex.NumeralLexView = NumeralLexicalView::Roman;
			}
			else if (exclEngCount > 0 && (engCount + hyphenCount) == wordSlice.size()) // english word
			{
				lex.Lang = TextLanguage::English;
			}
			else if (exclRusCount > 0 && (rusCount + hyphenCount) == wordSlice.size()) // russian word
			{
				lex.Lang = TextLanguage::Russian;
			}
			else if (digitsCount > 0 || romanChCount > 0 || exclEngCount > 0 || exclRusCount > 0)
				lex.NonLiterate = true;

			lexemes.push_back(lex);
		}
	}

	bool UkrainianPhoneticSplitter::checkGoodSentenceUkr(const std::vector<RawTextLexeme>& lexemes) const
	{
		int validWords = 0;
		for (const auto& lex : lexemes)
		{
			if (lex.NonLiterate)
			{
				if (log_ != nullptr) *log_ << QString("SKIPPED: %1, because: non-literate\n").arg(toQString(lex.ValueStr));
				continue;
			}
			if (lex.Lang == TextLanguage::Russian || lex.Lang == TextLanguage::English)
			{
				if (log_ != nullptr) *log_ << QString("SKIPPED: %1, because: lang is %2\n")
					.arg(toQString(lex.ValueStr)
					.arg(toQString(toString(lex.Lang.value()))));
				continue;
			}
			validWords += 1;
		}
		return validWords == static_cast<int>(lexemes.size());
	}

	void UkrainianPhoneticSplitter::selectWordParts(const std::vector<RawTextLexeme>& lexemes, std::vector<const WordPart*>& wordParts, long& preSplitWords)
	{
		for (const RawTextLexeme& lexeme : lexemes)
		{
			std::wstring str = lexeme.ValueStr.to_string();

			if (allowPhoneticWordSplit_)
			{
				auto preSplitWordIt = wordStrToPartIds_.find(str);
				if (preSplitWordIt != wordStrToPartIds_.end())
				{
					preSplitWords++;
					ShortArray<int, 2>& preSplit = preSplitWordIt->second;

					for (int splitInd = 0; splitInd < preSplit.ActualSize; ++splitInd)
					{
						int wordPartId = preSplit.Array[splitInd];
						const WordPart* wordPartPtr = wordUsage_.wordPartById(wordPartId);
						wordParts.push_back(wordPartPtr);
					}
				}
				else
				{
					doWordPhoneticSplit(str, wordParts);
				}
			}
			else
			{
				const WordPart* wordPart = wordUsage_.getOrAddWordPart(str, WordPartSide::WholeWord);
				wordParts.push_back(wordPart);
			}
		}
	}

	void UkrainianPhoneticSplitter::calcNGramStatisticsOnWordPartsBatch(std::vector<const WordPart*>& wordParts)
	{
		std::vector<const WordPart*> wordPartsStraight;

		// select sequantial word parts without separator
		size_t wordPartInd = 0;
		auto takeWordPartsTillNull = [this, &wordParts, &wordPartInd](std::vector<const WordPart*>& outWordParts) -> bool
		{
			// returns true if result contains data
			while (wordPartInd < wordParts.size())
			{
				for (; wordPartInd < wordParts.size(); ++wordPartInd)
				{
					const WordPart* wordPartPtr = wordParts[wordPartInd];
					if (wordPartPtr == wordPartSeparator_)
					{
						wordPartInd++; // skip separator
						break;
					}
					outWordParts.push_back(wordPartPtr);
				}
				if (!outWordParts.empty())
					return true;
			}
			return false;
		};
		while (true)
		{
			wordPartsStraight.clear();
			if (!takeWordPartsTillNull(wordPartsStraight))
				break;

			calcLangStatistics(wordPartsStraight);
		}
		// purge word parts buffer
		wordParts.clear();
	}

	void UkrainianPhoneticSplitter::calcLangStatistics(const std::vector<const WordPart*>& wordParts)
	{
		const WordPart* prevWordPart = nullptr;

		for (const WordPart* wordPart : wordParts)
		{
			if (wordPart->partText() == L"âàëóâàíí")
			{
				PG_Assert(true);
			}
			// unimodel
			WordSeqKey oneWordKey({ wordPart->id() });
			WordSeqUsage* oneWordSeq = wordUsage_.getOrAddWordSequence(oneWordKey);
			oneWordSeq->UsedCount++;
			seqOneWordCounter_++;

			// bimodel
			if (prevWordPart != nullptr)
			{
				WordSeqKey twoWordsKey({ prevWordPart->id(), wordPart->id() });
				WordSeqUsage* twoWordsSeq = wordUsage_.getOrAddWordSequence(twoWordsKey);
				twoWordsSeq->UsedCount++;
				seqTwoWordsCounter_++;
			}

			prevWordPart = wordPart;
		}
	}

	void UkrainianPhoneticSplitter::doWordPhoneticSplit(const wv::slice<wchar_t>& wordSlice, std::vector<const WordPart*>& wordParts)
	{
		//const std::wstring& word
		int matchedSuffixInd = -1;
		int sepInd = phoneticSplitOfWord(wordSlice, boost::none, &matchedSuffixInd);
		if (sepInd != -1)
			sureSuffixes[matchedSuffixInd].UsedCount++;

		int partsCount;
		std::array<std::wstring, 2> partsStrings;
		std::array<WordPartSide, 2> partsSides;
		if (sepInd == -1)
		{
			// separation position was not found, use the whole word
			partsCount = 1;
			partsStrings[0] = toString(wordSlice);
			partsSides[0] = WordPartSide::WholeWord;
		}
		else
		{
			partsCount = 2;

			wv::slice<wchar_t> prefix = wv::make_view(wordSlice.data(), sepInd);
			wv::slice<wchar_t> suffix = wv::make_view(wordSlice.data() + sepInd, wordSlice.size() - sepInd);

			partsStrings[0] = toString(prefix);
			partsSides[0] = WordPartSide::LeftPart;
			partsStrings[1] = toString(suffix);
			partsSides[1] = WordPartSide::RightPart;
		}

		for (int partInd = 0; partInd < partsCount; ++partInd)
		{
			const std::wstring& partStr = partsStrings[partInd];
			WordPartSide partSide = partsSides[partInd];

			const WordPart* wordPart = wordUsage_.getOrAddWordPart(partStr, partSide);
			wordParts.push_back(wordPart);
		}
	}
}